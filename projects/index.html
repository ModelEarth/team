<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Directory</title>
    <link rel="icon" type="image/x-icon" href="../img/logo/neighborhood/favicon.png">


    <link type="text/css" rel="stylesheet" href="../../localsite/css/base.css" id="/localsite/css/base.css" />
    <script src="../../localsite/js/localsite.js?showheader=true&showsearch=false"></script>

    <link rel="stylesheet" href="../css/common.css">
    <link rel="stylesheet" href="../css/shared-styles.css">
    <script>
        // Load submodule names by parsing .gitmodules from GitHub.
        if (!window.teamSubmodulesPromise) {
            window.teamSubmodulesPromise = (async function() {
                try {
                    const r = await fetch('https://raw.githubusercontent.com/ModelEarth/webroot/main/.gitmodules');
                    if (!r.ok) return [];
                    const txt = await r.text();
                    const names = [];
                    txt.split(/\r?\n/).forEach(l => {
                        const m = l.match(/^\[submodule "(.+)"\]/);
                        if (m) names.push(m[1]);
                    });
                    return names;
                } catch (err) {
                    console.warn('team: failed to load .gitmodules from GitHub', err);
                    return [];
                }
            })();
        }
    </script>
    
    <!-- Map and list displays -->

    <!-- Loads Leaflet via team/js/map.js and team/css/widget.css -->

    <!-- Leaflet + heatmap (CDN) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
    <script>
        // Patch leaflet.heat to create its canvas 2D context with
        // { willReadFrequently: true } to avoid repeated getImageData
        // readback warnings and improve performance when heatmap does
        // many pixel reads.
        (function() {
            try {
                if (window.heatLayer && window.heatLayer.HeatCanvas) {
                    // already loaded with named export (older bundles may differ)
                }
                // The plugin registers L.heatLayer which uses a HeatCanvas
                // implementation. Monkey-patch the prototype _initCanvas
                // function if present.
                if (window.L && L.HeatLayer && L.HeatLayer.prototype) {
                    var proto = L.HeatLayer.prototype;
                    if (proto._initCanvas && !proto._initCanvas.__patched_willReadFrequently) {
                        var originalInit = proto._initCanvas;
                        proto._initCanvas = function() {
                            // call original to create this._canvas and this._ctx if it does that,
                            // but if the plugin creates a canvas without the option we recreate
                            // the context with willReadFrequently for better readback performance.
                            originalInit.apply(this, arguments);
                            try {
                                if (this._canvas && this._canvas.getContext) {
                                    // If the existing context does not advertise willReadFrequently
                                    // we attempt to obtain a fresh context with that hint.
                                    var ctx = this._canvas.getContext('2d');
                                    // Some browsers ignore willReadFrequently after creation; create a new
                                    // offscreen canvas and copy the existing one into it.
                                    var preferOptions = { willReadFrequently: true };
                                    var newCtx = null;
                                    try {
                                        newCtx = this._canvas.getContext('2d', preferOptions);
                                    } catch (e) {
                                        // ignore - some browsers disallow re-creating context with options
                                        newCtx = null;
                                    }
                                    if (newCtx && newCtx !== ctx) {
                                        // Replace stored ctx reference if different
                                        this._ctx = newCtx;
                                    } else if (!newCtx) {
                                        // Try to create an offscreen canvas if environment supports it
                                        try {
                                            var off = null;
                                            if (typeof OffscreenCanvas !== 'undefined') {
                                                off = new OffscreenCanvas(this._canvas.width, this._canvas.height);
                                                var offCtx = off.getContext('2d', preferOptions) || off.getContext('2d');
                                                // draw existing canvas onto offscreen and then swap
                                                offCtx.drawImage(this._canvas, 0, 0);
                                                // Replace the backing canvas with the OffscreenCanvas where possible
                                                // (can't actually swap DOM element) but keep ctx reference for reads
                                                this._ctx = offCtx;
                                            }
                                        } catch (e) {
                                            // fallback: keep original ctx
                                        }
                                    }
                                }
                            } catch (err) {
                                console.warn('heatmap: willReadFrequently patch failed', err);
                            }
                        };
                        proto._initCanvas.__patched_willReadFrequently = true;
                    }
                }
            } catch (err) {
                console.warn('heatmap patch: unexpected error', err);
            }
        })();
    </script>
    <style>
        /* Participants heatmap container */
        #participants-map-container { margin-bottom: 12px; display: none; position: relative; }
    /* Ensure the map container has an explicit height so Leaflet can size itself */
    /* Increased height and stronger visual border to match desired look */
    #participants-map { position: relative; width: 100%; height: 380px; min-height: 320px; border: 3px solid #2563eb; border-radius: 12px; overflow: hidden; box-sizing: border-box; }
    #participants-map-container { margin-bottom: 12px; display: block; position: relative; padding: 8px; }
    /* Add a subtle blue inset shadow and thicker rounded outline on focus */
    #participants-map:focus, #participants-map:focus-within { outline: 3px solid rgba(37,99,235,0.12); box-shadow: 0 6px 20px rgba(37,99,235,0.12); }
    /* Make Leaflet's generated container absolutely fill our element (some global CSS can accidentally shrink it) */
    #participants-map > .leaflet-container, #participants-map .leaflet-container { position: absolute !important; left: 0 !important; top: 0 !important; right: 0 !important; bottom: 0 !important; width: 100% !important; height: 100% !important; box-sizing: border-box !important; }
    /* Also ensure common internal panes stretch */
    #participants-map .leaflet-map-pane, #participants-map .leaflet-tile-pane, #participants-map .leaflet-pane { width: 100% !important; height: 100% !important; left: 0 !important; top: 0 !important; }
        #participants-map-no-data { position: absolute; left: 0; top: 0; right: 0; bottom: 0; display: none; align-items: center; justify-content: center; pointer-events: none; color: var(--text-secondary); background: rgba(255,255,255,0.7); font-size: 14px; border-radius: 8px; }
        #participants-map-controls { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
    </style>

    <style>
        /* Legend for status colors on the map - improved contrast and z-index */
        .leaflet-control.status-legend {
            background: #ffffff;
            color: #111827;
            padding: 8px 10px;
            border-radius: 6px;
            box-shadow: 0 6px 18px rgba(15,23,42,0.08);
            font-size:13px;
            border: 1px solid rgba(2,6,23,0.06);
            z-index: 99999 !important; /* ensure legend sits above other overlays */
        }
        .status-legend .item { display:flex; align-items:center; gap:8px; margin-bottom:6px; }
        .status-legend .swatch { width:14px; height:14px; border-radius:4px; box-shadow: 0 0 0 1px rgba(0,0,0,0.04) inset; border: 1px solid rgba(0,0,0,0.04); }
        .status-legend .label { line-height:1; color:#111827; }
        /* Hide the 'Show states' control button - not needed when legend is visible */
        #toggle-state-counts-btn { display: none !important; }
    </style>

    <!--
    Activate after default map turned off
    <script type="text/javascript" src="../../localsite/js/embed.js?source=show.trade&map=cities.us"></script>
    -->

    <!-- Load Shared Auth Modal -->
    <script src="../js/auth-modal.js"></script>

    <style>
        /* Ensure all elements stay within container bounds */
        .card, .participants-table-card, .team-legend, .form-group, .input-button-group,
        .participants-table-container, .sort-dropdown, .status-dropdown {
            max-width: 100%;
            box-sizing: border-box;
        }
        
        /* Ensure form elements stay within bounds */
        .form-control, .form-row, .config-form {
            max-width: 100%;
            box-sizing: border-box;
        }
        
        /* Responsive table handling */
        .participants-table-container {
            overflow-x: auto;
            width: 100%;
        }
        
        .participants-table {
            width: 100%;
            min-width: 0;
        }
        
        .readme-content {
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            padding: 16px;
            background: var(--bg-tertiary);
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-control {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            font-size: 14px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: all 0.2s ease;
        }
        
        .form-control:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .form-control::placeholder {
            color: var(--text-muted);
        }

        /* PR card styles for Contributions panel */
        .pr-card {
            border: 1px solid var(--border-light);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            background: var(--bg-secondary);
        }

        /* Make nested PR cards visually distinct inside submodule cards */
        .submodule-card .pr-card {
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(59, 130, 246, 0.1);
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            padding: 14px;
            margin: 12px 0;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .submodule-card .pr-card:hover {
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
            border-color: rgba(59, 130, 246, 0.2);
        }

        .submodule-card .pr-card::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: linear-gradient(180deg, #3b82f6, #8b5cf6);
            opacity: 0.7;
        }

        /* PR card layout (non-expandable) */
        .pr-card {
            display: block;
        }

        .pr-card .pr-header {
            display: flex;
            gap: 12px;
            align-items: flex-start;
            justify-content: space-between;
        }

        .pr-card .pr-header > div:first-child { min-width: 0; flex: 1 1 auto; }

        .pr-meta {
            display: flex;
            gap: 8px;
            align-items: center;
            color: var(--text-secondary);
            font-size: 12px;
        }

        .pr-title {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 14px;
        }

        .pr-body-snippet {
            color: var(--text-secondary);
            font-size: 13px;
            margin-top: 8px;
            max-height: 6em;
            overflow: hidden;
            word-break: break-word;
        }

        /* Token control tweaks to avoid small box artifacts and keep alignment */
        #contributionsContent .form-control { max-width: 420px; }
        #contributionsContent .btn { height: 36px; padding: 6px 10px; }
        #contributionsContent label { margin: 0; }
        
        .form-select {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            font-size: 14px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: all 0.2s ease;
        }
        
        .form-select:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        /* Contributors row styling for submodule cards
           Use margin-top: auto so the contributors row sits at the bottom
           of the card when the card is a column flex container. */
        .contributors-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: auto;
            padding-top: 12px; /* visual spacing above the row */
            flex-wrap: wrap;
        }
        .contributors-row img {
            width: 28px;
            height: 28px;
            border-radius: 50%;
        }
        /* Modal contributors (header of PR diff modal) */
        .modal-contributors { display:flex; gap:8px; align-items:center; }
        .modal-contributor { display:inline-flex; align-items:center; gap:6px; font-size:13px; color:var(--text-primary); text-decoration:none; }
        .modal-contributor img { width:22px; height:22px; border-radius:50%; object-fit:cover; }
        .modal-contributor span { color: var(--text-primary); font-weight:600; }
        .modal-contrib-more { font-size:13px; padding:2px 6px; border-radius:999px; background:var(--muted-bg); }
        .contributors-label { font-size: 13px; color: var(--text-secondary); font-weight: 600; }
        .contributors-list { display: flex; gap: 6px; align-items: center; }
        .contributor-avatar { width: 28px; height: 28px; border-radius: 50%; border: 1px solid rgba(0,0,0,0.06); box-shadow: 0 1px 3px rgba(0,0,0,0.06); }
        .contributors-row .contrib-more { display: inline-flex; align-items: center; justify-content: center; width: 28px; height: 28px; border-radius: 50%; background: linear-gradient(135deg, #eef2ff, #e0f2fe); color: #0f172a; font-size: 12px; font-weight: 600; border: 1px solid rgba(0,0,0,0.06); box-shadow: 0 1px 3px rgba(0,0,0,0.06); }
    .contributors-row a.contributor-link { display: inline-flex; align-items: center; gap: 6px; padding: 0; border-radius: 0; text-decoration: none; color: inherit; background: transparent; }
    .contributors-row a.contributor-link:hover { background: transparent; transform: none; }
    .contributors-row .contrib-username { font-size: 12px; color: inherit; margin-left: 0; font-weight: 400; background: transparent; padding: 0; border-radius: 0; }
        .contributors-row a:hover img { transform: none; }
        .contributors-row .contrib-more { transition: none; }
        .contributors-row a:hover .contrib-more { transform: none; }

        /* Make submodule cards column flex containers so we can pin
           the contributors row to the bottom of the card. */
        .submodule-card {
            display: flex;
            flex-direction: column;
        }
        .submodule-card .card-body {
            flex: 1 1 auto;
        }
        /* PR diff modal */
        #prDiffModalOverlay {
            position: fixed;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2200;
            padding: 20px;
        }
        .pr-diff-modal {
            width: 100%;
            max-width: 1100px;
            max-height: 90vh;
            overflow: auto;
            background: var(--bg-primary);
            border-radius: 10px;
            box-shadow: 0 8px 30px rgba(2,6,23,0.6);
            padding: 18px;
            color: var(--text-primary);
            position: relative; /* allow absolute-positioned close button */
        }
        .pr-diff-modal h3 { margin: 0 0 12px 0; }
        .pr-diff-close {
            position: absolute;
            right: 18px;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            padding: 6px;
            line-height: 1;
        }
        .pr-diff-close:hover {
            background: rgba(0,0,0,0.06);
            color: var(--text-primary);
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(2,6,23,0.08);
        }
        .pr-diff-close:focus {
            outline: 3px solid rgba(59,130,246,0.18);
            outline-offset: 2px;
            border-radius: 6px;
        }
        .pr-diff-close:active {
            transform: translateY(-50%) scale(0.98);
        }
        /* Sticky header inside modal: remains fixed while content scrolls */
        .pr-diff-header {
            position: sticky;
            top: 0;
            background: var(--bg-primary);
            z-index: 6;
            padding-bottom: 10px;
            margin-bottom: 12px;
            border-bottom: 1px solid var(--border-light);
            position: relative; /* contain absolute-positioned close button */
        }
        .pr-diff-body {
            /* leave some breathing room; uses its own scrolling so header remains visible */
            overflow-y: auto;
            overflow-x: hidden;
            max-height: calc(80vh - 120px);
            padding-right: 6px;
        }
        .pr-diff-item { margin-bottom: 14px; border-top: 1px solid var(--border-light); padding-top: 12px; }
        .pr-diff-summary { display:flex; gap:8px; align-items:center; justify-content:space-between; }
        .pr-diff-pre {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-light);
            padding: 12px;
            overflow: auto;
            white-space: pre;
            font-family: monospace;
            font-size: 12px;
            margin-top: 8px;
            border-radius: 6px;
        }
        /* Two-column diff panes */
        .diff-container {
            display: flex;
            gap: 12px;
            align-items: flex-start;
            margin-top: 10px;
        }
        .diff-column {
            flex: 1 1 50%;
            min-width: 0;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid var(--border-light);
        }
    /* Base pane backgrounds; individual lines get highlights */
    /* Left pane: removed (tinted red). Right pane: added (tinted green). Keep subtle and readable. */
    .diff-left .pr-diff-pre { background: rgba(254, 202, 202, 0.26); color: var(--text-primary); border-right: 1px solid rgba(239,68,68,0.12); }
    .diff-right .pr-diff-pre { background: rgba(220, 252, 231, 0.28); color: var(--text-primary); border-left: 1px solid rgba(16,185,129,0.12); }
        .pr-diff-file { margin-bottom: 16px; }
        .pr-diff-file .pr-diff-filename { font-weight:600; margin-bottom:6px; display:flex; justify-content:space-between; gap:12px; align-items:center }
        .pr-diff-file .pr-diff-filename a { font-size:12px; color:var(--text-secondary); text-decoration:underline }
        /* Per-line styling inside diff panes */
    .pr-diff-pre { padding: 8px; font-family: monospace; font-size: 13px; white-space: pre; }
          /* Side-by-side table diff (GitHub-like) */
          /* Wrapper keeps table layout but hides overflow; individual code cells scroll */
          .sb-diff-wrap { width: 100%; overflow: hidden; border-radius: 6px; border: 1px solid var(--border-light); }
          .sb-diff { width: 100%; border-collapse: collapse; font-family: monospace; font-size: 13px; table-layout: fixed; }
          .sb-diff td { vertical-align: top; padding: 4px 8px; }
          /* Wrapper shouldn't clip the panes' scrollbars */
          .sb-diff-wrap { overflow: visible; }
          .sb-line-num { width: 56px; text-align: right; color: var(--text-secondary); font-size: 12px; padding-right: 12px; border-right: 1px solid rgba(0,0,0,0.03); }
          /* Make left/right code columns each scrollable and show visible scrollbars independently
              so both panes remain visible side-by-side even when content is tall. */
    /* Make each code pane a true scroll container with visible scrollbars */
    .sb-code { width: calc(50% - 56px); white-space: pre; max-height: 60vh; overflow-x: auto; overflow-y: auto; word-break: normal; padding-bottom: 6px; -webkit-overflow-scrolling: touch; scrollbar-gutter: stable both-edges; }
    /* Pre inside pane should not create its own scroll; allow the pane to handle scrolling */
    .sb-pre { margin: 0; white-space: pre; font-family: monospace; font-size: 13px; display: block; min-width: 100%; }
    /* Ensure rows don't collapse and allow visible separate scrollbars */
    .sb-diff td { vertical-align: top; }
    .sb-code.sb-left, .sb-code.sb-right { background-clip: padding-box; }
    /* Make scrollbars clearly visible on WebKit-based browsers (only on the pane container) */
    .sb-code::-webkit-scrollbar { width: 12px; }
    .sb-code::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.12); border-radius: 6px; }
    .sb-code::-webkit-scrollbar-track { background: transparent; }
    /* Per-row state */
    /* Removed lines: style the left-side code cell and its line number in red tones */
    .sb-row.sb-removed .sb-code.sb-left { background: rgba(254,202,202,0.26); }
    .sb-row.sb-removed .sb-code.sb-left .sb-pre { color: #7f1d1d; } /* darker red text for removed lines */
    .sb-row.sb-removed .sb-line-num:first-of-type { background: rgba(254,202,202,0.12); color: #991B1B; border-right-color: rgba(239,68,68,0.12); }

    /* Added lines: style the right-side code cell and its line number in green tones */
    .sb-row.sb-added .sb-code.sb-right { background: rgba(220,252,231,0.28); }
    .sb-row.sb-added .sb-code.sb-right .sb-pre { color: #065f46; } /* darker green text for added lines */
    .sb-row.sb-added .sb-line-num:last-of-type { background: rgba(220,252,231,0.10); color: #065f46; border-left-color: rgba(16,185,129,0.08); }

    /* Context lines remain muted (identical on both sides) */
    .sb-row.sb-context .sb-code { background: transparent; }
    .sb-row { border-bottom: 1px solid rgba(0,0,0,0.03); }

    /* Replacements: left side removed (red), right side added (green) with stronger tints */
    .sb-row.sb-replaced .sb-code.sb-left { background: rgba(254,202,202,0.34); }
    .sb-row.sb-replaced .sb-code.sb-left .sb-pre { color: #7f1d1d; }
    .sb-row.sb-replaced .sb-code.sb-right { background: rgba(220,252,231,0.36); }
    .sb-row.sb-replaced .sb-code.sb-right .sb-pre { color: #065f46; }
    /* New files list */
    .pr-new-files { padding: 8px 12px; background: var(--bg-tertiary); border-radius: 6px; margin: 8px 0; }
    .pr-new-files .new-files-tree { font-family: monospace; font-size: 13px; color: var(--text-primary); }
    .pr-new-files ul { list-style: none; margin: 6px 0 0 12px; padding-left: 12px; border-left: 1px dashed rgba(0,0,0,0.06); }
    .pr-new-files li { padding: 2px 0; }
    .pr-new-files a { color: var(--accent-blue); text-decoration: none; font-size: 13px; }
    .pr-new-files a:hover { text-decoration: underline; }
    /* removed per-line highlight styles (rendering as plain pre blocks now) */
    /* per-file preview buttons removed; use page-level preview instead */
        
        /* Snapshot dropdown specific styling */
        #snapshot {
            width: auto;
            max-width: 300px;
            min-width: fit-content;
            appearance: menulist;
            -webkit-appearance: menulist;
            -moz-appearance: menulist;
            background-image: none !important;
            padding-right: initial !important;
        }
        
        /* Custom dropdown arrow for fileSelect */
        #fileSelect {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%236b7280' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px 16px;
            padding-right: 40px;
        }

        .dark #fileSelect {
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ccc' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
        }
        
        /* Dark mode button backgrounds */
        .dark #status-toggle,
        .dark #sort-toggle,
        .dark #group-toggle,
        .dark #insights-btn,
        .dark .btn {
            background: var(--bg-tertiary);
        }
        
        /* Settings toggle styling */
        #settings-toggle {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-medium);
            transition: all 0.2s;
        }
        
        #settings-toggle:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        #settings-toggle svg {
            stroke-width: 1;
        }
        
        /* Dark mode styles for settings toggle */
        .dark #settings-toggle {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-medium);
            color: var(--text-secondary);
        }
        
        .dark #settings-toggle:hover {
            background: #666;
            color: var(--text-primary);
            border-color: #777;
        }
        
        .message-log {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            padding: 12px;
            margin-top: 16px;
            max-height: 1000px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
        }
        
        .message-log:empty {
            display: none;
        }
        
        .form-label {
            display: block;
            font-weight: 500;
            margin-bottom: 8px;
            color: var(--text-primary);
            font-size: 14px;
        }
        
        .input-button-group {
            display: flex;
            gap: 12px;
            align-items: flex-end;
        }
        
        .input-button-group .form-control {
            flex: 1;
        }
        
        @media (max-width: 500px) {
            .input-button-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .input-button-group .btn {
                width: 100%;
            }
        }
        
        .setup-steps {
            margin: 20px 0;
        }
        
        .step-item {
            display: flex;
            margin-bottom: 24px;
            padding: 16px;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            background: var(--bg-secondary);
        }
        
        .step-number {
            width: 32px;
            height: 32px;
            background: var(--accent-blue);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 16px;
            flex-shrink: 0;
        }
        
        .step-content {
            flex: 1;
        }
        
        .step-content h4 {
            margin-bottom: 8px;
            color: var(--text-primary);
            font-size: 16px;
        }
        
        .step-content p {
            color: var(--text-secondary);
            margin-bottom: 12px;
            font-size: 14px;
        }
        
        .status-message {
            margin-top: 8px;
            padding: 8px 12px;
            border-radius: var(--radius-md);
            font-size: 13px;
            display: none;
        }
        
        .status-message.success {
            background: rgba(16, 185, 129, 0.1);
            color: var(--accent-green);
            border: 1px solid rgba(16, 185, 129, 0.3);
        }
        
        .status-message.error {
            background: rgba(239, 68, 68, 0.1);
            color: var(--accent-red);
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        
        .status-message.info {
            background: rgba(59, 130, 246, 0.1);
            color: var(--accent-blue);
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        
        /* Dark mode status message styles */
        .dark .status-message.info {
            background: rgba(59, 130, 246, 0.15);
            color: white;
            border: 1px solid rgba(59, 130, 246, 0.4);
        }
        
        .dark .status-message.success {
            color: white;
        }
        
        .dark .status-message.error {
            color: white;
        }

        /* Button highlighting for cached insights */
        .btn.cached-insights {
            background: var(--accent-blue) !important;
            color: white !important;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
        }

        .dark .btn.cached-insights {
            background: var(--accent-blue) !important;
            color: white !important;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4);
        }

        /* Dark mode styling for insights content */
        .dark .insights-content {
            background: var(--bg-tertiary) !important;
            color: var(--text-primary);
        }

        .dark .insights-content .ai-insights-content {
            background: var(--bg-secondary) !important;
        }
        
        
        .config-form {
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: var(--radius-md);
            margin-bottom: 24px;
        }
        
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 16px;
        }
        
        .form-label {
            display: block;
            font-weight: 500;
            margin-bottom: 6px;
            color: var(--text-primary);
            font-size: 14px;
        }
        
        .config-actions {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .form-help {
            display: block;
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 4px;
        }
        
        textarea.form-control {
            resize: vertical;
            min-height: 80px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .button-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .table-container {
            overflow-x: auto;
            margin-bottom: 16px;
        }
        
        .participants-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        
        .participants-table th,
        .participants-table td {
            padding: 12px 8px;
            text-align: left;
            border-bottom: 1px solid var(--border-light);
        }
        
        .participants-table th {
            background: var(--bg-tertiary);
            font-weight: 600;
            color: var(--text-primary);
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .participants-table td {
            color: var(--text-secondary);
            max-width: 200px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            transition: all 0.2s ease;
            vertical-align: middle;
        }
        
        .participants-table td.expanded {
            white-space: normal;
            word-wrap: break-word;
            max-width: none;
            vertical-align: middle;
            display: table-cell;
        }
        
        .participants-table tr:hover {
            background: rgba(59, 130, 246, 0.05);
        }
        
        
        .table-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .pagination-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .pagination-btn {
            width: 32px;
            height: 32px;
            border: 1px solid var(--border-medium);
            border-radius: 6px;
            background: var(--bg-secondary);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s ease;
        }
        
        .pagination-btn:hover:not(:disabled) {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* 3-dot menu styles */
        .menu-container {
            position: relative;
            display: inline-block;
            margin-left: 8px;
        }
        
        .menu-button {
            width: 32px;
            height: 32px;
            border: 1px solid var(--border-medium);
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bolder;
            transition: all 0.2s;
        }
        
        .menu-button:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .menu-button.active {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }
        
        .menu-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-medium);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            min-width: 180px;
            z-index: 1000;
            margin-top: 4px;
            display: none;
        }
        
        .menu-item {
            padding: 12px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 14px;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border-light);
        }
        
        .menu-item:last-child {
            border-bottom: none;
        }
        
        .menu-item:hover {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .menu-item.active {
            background-color: var(--accent-blue);
            color: white;
        }
        
        /* Fullscreen styles */
        .fullscreen-mode {
            width: 100% !important;
            min-height: 100vh !important;
            z-index: 9999 !important;
            background: var(--bg-primary) !important;
            overflow-x: hidden !important;
            overflow-y: auto !important;
            padding: 0 !important;
            margin: 0 !important;
            box-sizing: border-box !important;
        }
        
        .fullscreen-mode .container {
            max-width: 100% !important;
            width: 100% !important;
            margin: 0 !important;
            padding: 20px !important;
            box-sizing: border-box !important;
            overflow-x: hidden !important;
        }
        
        .fullscreen-mode .breadcrumb {
            display: none !important;
        }
        
        .fullscreen-mode .header {
            display: none !important;
        }
        
        .fullscreen-mode table {
            table-layout: fixed !important;
            width: 100% !important;
            overflow-x: auto !important;
        }
        
        .fullscreen-mode .card {
            max-width: 100% !important;
            overflow-x: hidden !important;
        }
        
        /* Maintain 3-dot menu spacing in fullscreen mode */
        .fullscreen-mode .participants-table .columns-menu {
            right: 8px !important;
        }
        
        /* Ensure menu column has consistent width in all modes */
        .fullscreen-mode .participants-table td:last-child {
            width: 70px !important;
            min-width: 70px !important;
            padding: 8px 16px !important;
        }
        
        
        /* Condensed layout styles */
        .condensed-mode .view-buttons {
            display: none;
        }
        
        .condensed-mode .view-buttons-condensed {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .condensed-mode .legend-controls {
            display: none;
        }
        
        .condensed-mode .legend-controls-condensed {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .view-buttons-condensed {
            display: none;
        }
        
        .legend-controls-condensed {
            display: none;
        }
        
        .condensed-icon-btn {
            width: 32px;
            height: 32px;
            border: 1px solid var(--border-light);
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }
        
        .condensed-icon-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .condensed-icon-btn.active {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }
        
        @media (max-width: 600px) {
            .form-row {
                grid-template-columns: 1fr;
            }
            
            .config-actions {
                flex-direction: column;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .participants-table {
                font-size: 12px;
            }
            
            .participants-table th,
            .participants-table td {
                padding: 8px 4px;
            }
            
            .table-info {
                flex-direction: column;
                gap: 8px;
            }
            
            .upload-group {
                flex-direction: column;
                gap: 8px;
            }
        }
        
        .upload-group {
            display: flex;
            gap: 8px;
            align-items: flex-end;
        }
        
        .alternative-upload {
            border-left: 3px solid var(--accent-blue);
        }
        
        .alternative-upload h4 {
            font-size: 16px;
        }
        
        
        /* Snapshot controls layout */
        .snapshot-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            container-type: inline-size;
        }
        
        .snapshot-dropdown {
            flex: 1;
        }
        
        .snapshot-input-buttons {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }
        
        .snapshot-input {
            flex: 1;
        }
        
        .snapshot-buttons {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }
        
        @container (max-width: 600px) {
            /* Default narrow layout: stacked when input is visible */
            .snapshot-controls.editing {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }
            
            .snapshot-controls.editing .snapshot-dropdown {
                width: 100%;
                flex: none;
            }
            
            .snapshot-controls.editing .snapshot-input-buttons {
                width: 100%;
                flex: none;
            }
            
            .snapshot-controls.editing .snapshot-input {
                flex: 1;
                min-width: 0; /* Allow flex item to shrink below content size */
            }
            
            /* When input is hidden, keep everything on same line */
            .snapshot-controls:not(.editing) {
                flex-direction: row;
                align-items: center;
            }
            
            .snapshot-controls:not(.editing) .snapshot-dropdown {
                flex: 1;
            }
            
            .snapshot-controls:not(.editing) .snapshot-input-buttons {
                flex: 0 0 auto;
            }
        }
        
        /* Fallback for browsers without container queries support */
        @supports not (container-type: inline-size) {
            @media (max-width: 800px) {
                /* Default narrow layout: stacked when input is visible */
                .snapshot-controls.editing {
                    flex-direction: column;
                    align-items: stretch;
                    gap: 8px;
                }
                
                .snapshot-controls.editing .snapshot-dropdown {
                    width: 100%;
                    flex: none;
                }
                
                .snapshot-controls.editing .snapshot-input-buttons {
                    width: 100%;
                    flex: none;
                }
                
                .snapshot-controls.editing .snapshot-input {
                    flex: 1;
                    min-width: 0; /* Allow flex item to shrink below content size */
                }
                
                /* When input is hidden, keep everything on same line */
                .snapshot-controls:not(.editing) {
                    flex-direction: row;
                    align-items: center;
                }
                
                .snapshot-controls:not(.editing) .snapshot-dropdown {
                    flex: 1;
                }
                
                .snapshot-controls:not(.editing) .snapshot-input-buttons {
                    flex: 0 0 auto;
                }
            }
        }
        
        #edit-snapshot-btn, #delete-snapshot-btn {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            flex-shrink: 0;
        }
        
        #delete-snapshot-btn {
            font-size: 24px;
            font-weight: bold;
            line-height: 1;
        }
        
        .add-snapshot {
            display: flex;
            gap: 8px;
        }
        
        .add-snapshot input {
            flex: 1;
        }
        
        /* Group Participants Control */
        .group-control {
            margin-bottom: 20px;
            padding: 16px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-light);
            display: none; /* Hidden by default, shown only for modelteam list */
        }
        
        .group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .group-snapshot-info {
            font-size: 12px;
            color: var(--text-muted);
        }
        
        .group-snapshot-info a {
            color: var(--accent-blue);
            text-decoration: none;
        }
        
        .group-snapshot-info a:hover {
            text-decoration: underline;
        }
        
        .group-input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .group-input-group input {
            flex: 1;
        }
        
        #group {
            text-align: right;
            caret-color: var(--text-primary) !important;
            padding-right: 18px !important; /* Extra padding to ensure cursor visibility */
            box-sizing: border-box;
        }
        
        #group:focus {
            caret-color: var(--accent-blue) !important;
        }
        
        #group-toggle {
            white-space: nowrap;
            min-width: 100px;
        }
        
        /* Button backgrounds for consistent styling */
        #status-toggle,
        #sort-toggle {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-light);
        }
        
        #group-toggle.active {
            background: var(--accent-green);
            color: white;
            border-color: var(--accent-green);
        }
        
        #group-toggle-text[contenteditable="true"] {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            padding: 2px 4px;
            outline: 2px solid var(--accent-blue);
            outline-offset: 1px;
        }
        
        #group-toggle-text {
            cursor: pointer;
        }
        
        #group-toggle-text:hover {
            text-decoration: underline;
        }
        
        /* Group participant highlighting */
        .columns-group {
            border: 3px solid var(--accent-green) !important;
            box-shadow: 0 0 0 1px var(--accent-green) !important;
        }
        
        .columns-group .columns-name {
            color: var(--accent-green) !important;
            font-weight: 700 !important;
        }
        
        /* Keep gallery names white when group border is added */
        .columns-group .gallery-name {
            color: white !important;
            font-weight: 700 !important;
        }
        
        /* Table row highlighting */
        .participants-table tr.columns-group {
            background: rgba(16, 185, 129, 0.1) !important;
            border-left: 4px solid var(--accent-green) !important;
        }
        
        .participants-table tr.columns-group td:first-child {
            color: var(--accent-green) !important;
            font-weight: 600 !important;
        }
        
        /* Raw Data Control */
        .raw-data-control {
            margin-bottom: 20px;
            padding: 16px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-light);
        }
        
        .raw-data-control textarea {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: auto;
        }
        
        /* View Controls */
        .view-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 12px;
        }
        
        .view-buttons {
            display: flex;
            gap: 8px;
        }
        
        .view-btn {
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid var(--border-light);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }
        
        .view-btn.active {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }
        
        .view-btn:hover:not(.active) {
            background: var(--border-light);
        }
        
        #add-visit-btn {
            text-decoration: none !important;
            background: #22c55e !important;
            color: white !important;
            border-color: #22c55e !important;
            opacity: 0.8;
            padding: 8px 16px !important;
        }
        
        #add-visit-btn:hover {
            opacity: 1;
            background: #16a34a !important;
            border-color: #16a34a !important;
        }
        
        #map-btn {
            text-decoration: none !important;
            background: #3b82f6 !important;
            color: white !important;
            border-color: #3b82f6 !important;
            opacity: 0.8;
            padding: 8px 16px !important;
        }
        
        #map-btn:hover {
            opacity: 1;
            background: #2563eb !important;
            border-color: #2563eb !important;
        }
        
        #sign-in-btn {
            padding: 8px 16px !important;
        }
        
        #insights-btn {
            padding: 8px 16px !important;
            background: linear-gradient(180deg, #7c3aed, #6d28d9) !important; /* purple gradient */
            color: white !important;
            border-color: #6d28d9 !important;
            box-shadow: 0 1px 0 rgba(0,0,0,0.06);
            opacity: 0.95;
            transition: all 0.2s ease;
        }

        #insights-btn:hover {
            opacity: 1 !important;
            filter: brightness(1.15);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(124, 58, 237, 0.3);
        }

        /* Repos button styling - similar size to insights but distinct color */
        #contribs-btn {
            padding: 8px 16px !important;
            background: linear-gradient(180deg, #10b981, #059669) !important; /* green gradient */
            color: white !important;
            border-color: #059669 !important;
            box-shadow: 0 1px 0 rgba(0,0,0,0.06);
            opacity: 0.95;
            transition: all 0.2s ease;
        }

        #contribs-btn:hover {
            opacity: 1 !important;
            filter: brightness(1.15);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(16, 185, 129, 0.3);
        }

        /* Submodule GitHub link icon styling */
        .submodule-gh-link {
            color: var(--text-secondary);
        }
        .submodule-gh-link:hover {
            color: var(--accent-blue);
        }

        /* Local model.earth link on the left of the repo name */
        .submodule-local-link {
            color: var(--text-secondary);
            margin-right: 12px;
            display: inline-flex;
            align-items: center;
            text-decoration: none;
            padding: 6px;
            border-radius: 8px;
            transition: all 0.2s ease;
            background: rgba(59, 130, 246, 0.05);
        }
        .submodule-local-link:hover {
            color: var(--accent-blue);
            background: rgba(59, 130, 246, 0.1);
            transform: scale(1.1);
        }

        .submodule-gh-link {
            color: var(--text-secondary);
            margin-left: 8px;
            display: inline-flex;
            align-items: center;
            text-decoration: none;
            padding: 6px;
            border-radius: 8px;
            transition: all 0.2s ease;
            background: rgba(100, 116, 139, 0.05);
        }
        .submodule-gh-link:hover {
            color: var(--text-primary);
            background: rgba(100, 116, 139, 0.1);
            transform: scale(1.1);
        }

        /* Submodule cards layout */
        .submodule-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
            margin-top: 20px;
            align-items: start; /* keep cards top-aligned */
        }

        .submodule-card {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(255, 255, 255, 0.02) 100%);
            border: 1px solid var(--border-light);
            border-radius: 16px;
            padding: 20px;
            box-sizing: border-box;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            display: flex;
            flex-direction: column;
            min-height: 180px;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .submodule-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            border-color: rgba(59, 130, 246, 0.3);
        }

        .submodule-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6, #06b6d4);
            border-radius: 16px 16px 0 0;
        }

        /* Filter button active state */
        #prsFilters .btn.active {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }

        /* Make the filter buttons more visible (pill-like) */
        #prsFilters .btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-light);
            color: var(--text-primary);
            padding: 6px 10px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            transition: background 0.15s ease, transform 0.06s ease;
        }

        #prsFilters .btn:hover {
            background: var(--bg-secondary);
            transform: translateY(-1px);
            color: var(--text-primary); /* keep text readable on hover */
        }

        .submodule-card h4 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            display: inline-block;
            vertical-align: middle;
            letter-spacing: -0.025em;
        }

        .submodule-card .card-body {
            margin-top: 16px;
            overflow: auto;
            max-height: 380px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .submodule-card .card-body strong {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            display: block;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid rgba(59, 130, 246, 0.2);
        }
        
        #list-title {
            border: none !important;
        }
        
        #aiInsights {
            margin-bottom: 12px;
            display: none; /* Hidden by default */
            background: var(--bg-primary);
            border-radius: var(--radius-md);
            padding: 16px;
            border: 1px solid var(--border-light);
        }
        
        /* Column View (Default) - Using table-list style */
        .participants-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-top: 16px;
        }
        
        .columns-card {
            background: var(--bg-tertiary);
            padding: 16px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-light);
            transition: all 0.2s;
            position: relative;
        }
        
        .columns-card:hover {
            background: var(--bg-secondary);
            box-shadow: var(--shadow-sm);
        }
        
        .columns-name {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
            font-size: 16px;
            display: flex;
            align-items: center;
        }
        
        .columns-checkbox {
            width: 18px;
            height: 18px;
            margin-right: 8px;
            vertical-align: middle;
            cursor: pointer;
            z-index: 10;
        }
        
        /* 3-dot menu for participant cards */
        .columns-menu {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            z-index: 5;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-size: 18px;
            color: var(--text-secondary);
        }
        
        .columns-menu:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        
        .columns-menu-dropdown {
            position: absolute;
            top: 100%;
            right: 26px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            min-width: 150px;
            z-index: 999999;
            display: none;
            margin-top: -20px;
        }

        /* Specific positioning for table view dropdown */
        .participants-table .columns-menu-dropdown {
            right: 32px;
            margin-top: -34px;
        }
        
        
        /* Override table container z-index issues */
        .table-container {
            position: relative;
            z-index: 1;
            overflow-x: auto;
            overflow-y: visible;
        }
        
        /* Only allow overflow for menu cells to show dropdowns */
        .participants-table td {
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Menu cells need overflow visible for dropdown */
        .participants-table td:last-child {
            overflow: visible;
            width: 50px !important;
            min-width: 50px !important;
            padding: 8px 12px !important;
        }
        
        /* 3-dot menu vertical centering only in table view */
        .participants-table .columns-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-size: 18px;
            color: var(--text-secondary);
            cursor: pointer;
            z-index: 5;
            background: transparent;
        }

        /* Hover effect for the menu button */
        .participants-table .columns-menu:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* Ensure the menu cell is sticky as well */
        .participants-table td:last-child {
            position: sticky !important;
            right: 0 !important;
            background: var(--bg-secondary) !important;
            border-left: 1px solid var(--border-light) !important;
            box-shadow: -2px 0 4px rgba(0, 0, 0, 0.1) !important;
            z-index: 10 !important;
        }

        /* Make the menu header column sticky too */
        .participants-table th:last-child {
            position: sticky !important;
            right: 0 !important;
            background: var(--bg-tertiary) !important;
            border-left: 1px solid var(--border-light) !important;
            box-shadow: -2px 0 4px rgba(0, 0, 0, 0.1) !important;
            z-index: 11 !important;
            width: 50px !important;
            min-width: 50px !important;
        }

        /* Dark mode support for sticky menu column */
        .dark .participants-table td:last-child,
        .dark .participants-table th:last-child {
            background: var(--bg-secondary) !important;
            border-left: 1px solid var(--border-medium) !important;
            box-shadow: -2px 0 4px rgba(0, 0, 0, 0.3) !important;
        }

        .dark .participants-table .columns-menu {
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-medium);
            box-shadow: -2px 0 4px rgba(0, 0, 0, 0.3);
        }
        
        /* 3-dot menu dark color for gallery view visibility */
        .gallery-card .columns-menu {
            color: #000000 !important;
        }
        
        .gallery-card .columns-menu:hover {
            color: #000000 !important;
            background: rgba(255, 255, 255, 0.2);
        }
        
        /* Ensure participants table container doesn't clip dropdowns */
        .participants-table-container {
            overflow-x: auto;
            overflow-y: visible;
        }
        
        /* Table right-click context menu */
        .table-context-menu {
            position: fixed;
            z-index: 999999;
            background: var(--bg-secondary);
            border: 1px solid var(--border-medium);
            border-radius: var(--radius-md);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            min-width: 150px;
            padding: 4px 0;
            opacity: 1;
        }
        
        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background-color 0.2s ease;
        }
        
        .context-menu-item:hover {
            background: var(--bg-tertiary);
        }
        
        
        .columns-menu-item {
            padding: 12px 16px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            min-height: 40px;
            text-align: center;
        }
        
        .columns-menu-item:hover {
            background: var(--bg-tertiary);
        }
        
        .columns-menu-item a {
            color: inherit;
            text-decoration: none;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            padding: 0;
            text-align: center;
        }
        
        /* Table-specific checkbox styling */
        table .columns-checkbox {
            position: relative;
            top: auto;
            right: auto;
            margin: 0;
            display: inline-block;
        }
        
        .columns-info {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 2px;
        }
        
        .columns-info strong {
            color: var(--text-primary);
            font-weight: 500;
        }
        
        .columns-projects {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 8px;
            line-height: 1.4;
            border-top: 1px solid var(--border-light);
            padding-top: 8px;
        }
        
        .columns-projects strong {
            color: var(--text-primary);
            font-weight: 500;
        }
        
        /* Gallery View */
        .participants-gallery {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 16px;
        }
        
        .gallery-card {
            background: linear-gradient(135deg, var(--card-bg-1), var(--card-bg-2));
            border-radius: var(--radius-lg);
            padding: 20px;
            text-align: center;
            color: white;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .gallery-card:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: var(--shadow-lg);
        }
        
        .gallery-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.1) 50%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .gallery-card:hover::before {
            opacity: 1;
        }
        
        .gallery-name {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        
        .gallery-info {
            font-size: 12px;
            opacity: 0.9;
            font-weight: 500;
        }
        
        /* Team-based color variations for gallery cards */
        .gallery-card.team-js { --card-bg-1: #667eea; --card-bg-2: #764ba2; }
        .gallery-card.team-ml { --card-bg-1: #f093fb; --card-bg-2: #f5576c; }
        .gallery-card.team-react { --card-bg-1: #4facfe; --card-bg-2: #00f2fe; }
        .gallery-card.team-io { --card-bg-1: #43e97b; --card-bg-2: #38f9d7; }
        .gallery-card.team-ai { --card-bg-1: #fa709a; --card-bg-2: #fee140; }
        .gallery-card.team-flask { --card-bg-1: #ff9a9e; --card-bg-2: #fecfef; }
        .gallery-card.team-suite { --card-bg-1: #a8edea; --card-bg-2: #fed6e3; }
        .gallery-card.team-us { --card-bg-1: #ffecd2; --card-bg-2: #fcb69f; }
        .gallery-card.team-auth { --card-bg-1: #89f7fe; --card-bg-2: #66a6ff; }
        .gallery-card.team-discord { --card-bg-1: #c2e9fb; --card-bg-2: #a1c4fd; }
        .gallery-card.team-default { --card-bg-1: #d299c2; --card-bg-2: #fef9d7; }
        
        /* Team Legend */
        .team-legend {
            margin-bottom: 20px;
            padding: 16px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-light);
        }
        
        .legend-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .legend-header h4 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }
        
        .btn-sm {
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 4px;
        }
        
        /* Larger X for dropdown close buttons */
        #close-sort, #close-status {
            font-size: 24px;
            line-height: 1;
            padding: 0;
            min-width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: auto;
        }
        
        .legend-items {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
        }
        
        .legend-item:hover {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }
        
        .legend-item.active {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            flex-shrink: 0;
        }
        
        /* Legend Controls */
        .legend-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            position: relative;
        }
        
        .button-with-dropdown {
            position: relative;
            display: inline-block;
        }
        
        /* Sort Dropdown */
        .sort-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            min-width: 200px;
            z-index: 1000;
            margin-top: 4px;
        }
        
        .sort-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-light);
        }
        
        .sort-header h4 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }
        
        .sort-items {
            padding: 8px 0;
        }
        
        .sort-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .sort-item:hover {
            background-color: var(--bg-tertiary);
        }
        
        .sort-item.active {
            background-color: var(--accent-blue);
            color: white;
        }
        
        .sort-arrow {
            font-size: 12px;
            font-weight: bold;
            min-width: 16px;
            text-align: center;
        }
        
        /* Status Dropdown */
        .status-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            min-width: 220px;
            z-index: 1000;
            margin-top: 4px;
        }
        
        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-light);
        }
        
        .status-header h4 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }
        
        .status-items {
            padding: 8px 0;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .status-item {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .status-item:hover {
            background-color: var(--bg-tertiary);
        }
        
        .status-checkbox {
            margin-right: 8px;
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        .status-label {
            flex: 1;
            cursor: pointer;
        }
        
        /* Responsive Design */
        @media (max-width: 1000px) {
            .participants-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 900px) {
            .container {
                padding: 0 16px;
            }
            
            .view-controls {
                flex-wrap: wrap;
                gap: 8px;
            }
            
            .table-info {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            
            .form-row {
                grid-template-columns: 1fr;
            }
            
            .config-actions {
                flex-direction: column;
                gap: 8px;
            }
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 0 16px;
            }
            
            .participants-grid {
                grid-template-columns: 1fr;
            }
            
            .participants-gallery {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .view-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .participants-table-container {
                overflow-x: auto;
            }
            
            .participants-table {
                min-width: 600px;
            }
            
            .table-info {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            
            .pagination-controls {
                align-self: flex-end;
            }
            
            .view-buttons {
                justify-content: center;
            }
            
            .legend-items {
                justify-content: center;
            }
        }
        
        @media (max-width: 480px) {
            .participants-gallery {
                grid-template-columns: 1fr;
            }
            
            .view-buttons {
                flex-direction: column;
            }
        }
        
        /* Loading and error states */
        .loading-state, .error-state {
            text-align: center;
            padding: 40px 20px;
            font-size: 16px;
            color: var(--text-secondary);
        }
        
        .error-state {
            color: #dc2626;
        }
        
        /* Clickable meta list items */
        .columns-card[style*="cursor: pointer"]:hover,
        .gallery-card[style*="cursor: pointer"]:hover,
        .participants-table tr[style*="cursor: pointer"]:hover {
            background-color: rgba(59, 130, 246, 0.1) !important;
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
            transition: all 0.2s ease;
        }
        
        
        /* Raw Data Editor Close Button */
        #raw-data-close {
            transition: all 0.2s ease;
            border-radius: var(--radius-sm);
            min-width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #raw-data-close:hover {
            background-color: var(--bg-tertiary);
            border-color: var(--border-medium);
            color: var(--text-primary);
        }
        
        /* Button Groups for AI Insights */
        .insights-status {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .insight-button-group {
            display: flex;
            gap: 1px;
            align-items: center;
        }

        .insight-button-group:hover {
            box-shadow: var(--shadow-md);
            background: var(--bg-secondary);
        }

        .insight-button-group .btn {
            margin: 0;
            border-radius: 8px;
            flex: 1;
        }

        /* When refresh button is visible, adjust border radius for tighter connection */
        .insight-button-group .btn:has(+ .refresh-btn:not([style*="display: none"])),
        .insight-button-group .btn:has(+ .refresh-btn[style*="display: block"]),
        .insight-button-group .btn:has(+ .refresh-btn[style=""]) {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }

        .insight-button-group .refresh-btn:not([style*="display: none"]),
        .insight-button-group .refresh-btn[style*="display: block"],
        .insight-button-group .refresh-btn[style=""] {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }

        .refresh-btn {
            width: 40px;
            height: 34px;
            min-width: 40px;
            max-width: 40px;
            padding: 0;
            margin: 0;
            border-radius: 6px;
            color: white;
            border: 1px solid var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            box-shadow: var(--shadow-sm);
            transition: all 0.2s;
            cursor: pointer;
            flex-shrink: 0;
            box-sizing: border-box;
        }

        .refresh-btn:hover {
            background: #2563EB;
            box-shadow: var(--shadow-md);
        }

        .refresh-btn:active {
            transform: scale(0.95);
        }

        .refresh-btn span {
            font-size: 32px;
            line-height: 1;
            font-weight: normal;
            margin-top: -4px;
        }

        /* AI Insights Styles */
        .insights-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .ai-icon {
            font-size: 24px;
        }

        .loading-status {
            margin-bottom: 16px;
            padding: 12px;
            border-radius: var(--radius-md);
            text-align: left;
            font-style: italic;
            font-weight: bold;
        }

        /* Prompt Modal */
        .prompt-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .prompt-modal.hidden {
            display: none;
        }

        .prompt-modal-content {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            padding: 24px;
            max-width: 500px;
            width: 90%;
            box-shadow: var(--shadow-lg);
        }

        .prompt-modal-content h3 {
            margin-bottom: 16px;
            color: var(--text-primary);
            font-size: 20px;
            font-weight: 600;
        }

        .prompt-modal-content textarea {
            width: 100%;
            min-height: 120px;
            padding: 12px;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
            margin-bottom: 16px;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        /* Image Gallery Styles */
        .columns-image-container {
            position: relative;
            width: 100%;
            height: 120px;
            margin-bottom: 12px;
            overflow: hidden;
            border-radius: var(--radius-md);
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .columns-image {
            width: 100%;
            height: 120px;
            object-fit: cover;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .columns-image:hover {
            transform: scale(1.02);
        }

        .image-dots-container {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 6px;
            z-index: 2;
        }

        .image-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(128, 128, 128, 0.7);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .image-dot.active {
            background: rgba(255, 255, 255, 0.9);
            transform: scale(1.2);
        }

        .image-dot:hover {
            background: rgba(255, 255, 255, 0.8);
        }

        /* Gallery View Image Styles */
        .gallery-card {
            position: relative;
            overflow: hidden;
            min-height: 180px;
        }

        .gallery-card .columns-image-container {
            height: 140px;
            margin-bottom: 0;
            border-radius: var(--radius-md) var(--radius-md) 0 0;
        }

        .gallery-card .columns-image {
            height: 140px;
        }

        .gallery-card .gallery-content {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: transparent;
            padding: 12px;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: flex-start;
            text-align: left;
        }
        
        /* Dark overlay for cards with background images */
        .gallery-card.has-background-image .gallery-content {
            background: rgba(0, 0, 0, 0.7);
            color: white;
        }
        
        
        .gallery-card.has-background-image .gallery-name {
            color: white;
        }
        
        .gallery-card.has-background-image .gallery-info {
            color: rgba(255, 255, 255, 0.9);
        }

        .gallery-card.text-mode .gallery-content {
            background: rgba(0, 0, 0, 0.85);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: flex-start;
            text-align: left;
        }
        
        /* Text mode for cards without images */
        .gallery-card.text-mode:not(.has-background-image) .gallery-content {
            top: 0;
            bottom: 0;
        }

        .gallery-toggle-btn {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: none;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 3;
            padding: 4px;
        }

        .gallery-toggle-btn:hover {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 4px;
            transform: scale(1.1);
        }

        .no-image-placeholder {
            width: 100%;
            height: 120px;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            font-size: 12px;
            border-radius: var(--radius-md);
        }

        /* Auto-advance indicator */
        .image-container.auto-advancing .image-dot.active {
            animation: pulse 0.3s ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1.2); }
            50% { transform: scale(1.4); }
        }

        /* Image loading placeholder */
        .columns-image-container.loading {
            background: linear-gradient(90deg, var(--bg-tertiary) 25%, var(--bg-secondary) 50%, var(--bg-tertiary) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        .dark .view-btn:hover:not(.active) {
            color: #fff !important;
        }
    </style>
</head>
<body>
    <div class="container">

        <!-- Top Message Display Area -->
        <div id="top-message-area" style="display: none; margin-bottom: 20px;">
            <div class="card" style="border-left: 4px solid #f59e0b; background: #fef3c7; color: #92400e;">
                <div id="top-message-content"></div>
            </div>
        </div>

        <div class="contentpadding" style="padding-bottom: 0px">
            <div class="breadcrumb">
                <a href="../admin/">Partner Tools</a>
            </div>
            <div id="pageControls" class="input-button-group" style="display:flex; width: 100%; align-items: center;">
                <div style="display: flex; gap: 12px; align-items: center;">
                    <select id="fileSelect" class="form-control" style="width: auto; min-width: 200px; max-width: calc(100% - 32px); flex: none;">
                        <option value="custom">Choose File...</option>
                    </select>
                    <button class="btn btn-primary" id="get-participants">
                        <span class="loading-spinner" id="participants-spinner" style="display: none;"></span>
                        Get List
                    </button>
                </div>
                <div class="menu-container" style="display: flex; align-items: flex-start; gap: 8px; margin-left: auto;">
                    <button class="btn btn-secondary" id="settings-toggle" onclick="toggleReadmeSection()" style="padding: 4px 6px; font-size: 14px; color: var(--text-secondary); min-width: 32px; height: 32px;" title="Documentation & Cache">
                        <i data-feather="settings"></i>
                    </button>
                    <button class="menu-button" id="menu-toggle">
                        ⋯
                    </button>
                    <div class="menu-dropdown" id="menu-dropdown">
                        <div class="menu-item" id="fullscreen-toggle">
                            <span id="fullscreen-text">View Fullscreen</span>
                        </div>
                        <div class="menu-item" id="condensed-toggle">
                            <span id="condensed-text">Condense Layout</span>
                        </div>
                        <div class="menu-item" id="raw-data-toggle">
                            <span id="raw-data-text">View Raw Data</span>
                        </div>
                        <div class="menu-item" id="export-csv-menu">
                            <span>Export CSV</span>
                        </div>
                        <div class="menu-item" id="full-url-toggle">
                            <span>Full URL</span>
                        </div>
                        <div class="menu-item" id="list-feeds-toggle">
                            <span>All Lists</span>
                        </div>
                        <div class="menu-item" id="refresh-csv-toggle" style="display: none;">
                            <span>Refresh lists.csv</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Custom file upload (hidden by default) -->
            <div class="form-group" id="customFileSection" style="display: none;">
                <div class="file-input-wrapper">
                    <input type="file" id="excelFile" class="file-input" accept=".xlsx,.xls,.csv" style="display: none;" />
                    <div class="file-input-display" id="fileDisplay" style="border: 1px solid var(--border-light); border-radius: var(--radius-md); padding: 16px; background: var(--bg-secondary); cursor: pointer; text-align: center;">
                        <div class="file-info">
                            <div class="file-name">Click to upload file</div>
                            <div class="file-details" style="color: var(--text-muted); font-size: 12px;">Supports .csv, .xls and .xlsx formats</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="contentpadding" id="teamHeader" style="display: none; padding-bottom: 0px">
            <h1>
                Coding Meetup Integration
            </h1>
            <p>Filters a Google Sheet to share member details <a href="../admin/cloud/">during meetups</a>.
                <!--  will eventually pull a list from a Google Meetup to filter the  -->
            </p>
        </div>

        <div id="mapwidget"></div>

        <!-- README Documentation Section -->
        <div class="card" id="readme-section" style="margin-top: 20px; display: none;">
            <div style="margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center;">
                <h3 style="margin: 0; color: var(--text-primary);">📋 Page Documentation & Cache</h3>
                <button class="btn btn-secondary" id="toggle-readme" onclick="toggleReadmeSection()" style="font-size: 12px; padding: 6px 12px;">
                    Hide Documentation
                </button>
            </div>
            
            <!-- Browser Cache YAML Editor -->
            <div style="margin-bottom: 20px;">
                <div style="margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                    <h4 style="margin: 0; color: var(--text-primary);">🗄️ Browser Cache (YAML)</h4>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-secondary" id="copy-cache-btn" onclick="copyCacheYaml()" style="font-size: 11px; padding: 4px 8px;">
                            📋 Copy
                        </button>
                        <button class="btn btn-primary" id="save-cache-btn" onclick="saveCacheFromYaml()" style="font-size: 11px; padding: 4px 8px;">
                            💾 Save
                        </button>
                        <button class="btn btn-secondary" id="refresh-cache-btn" onclick="refreshCacheYaml()" style="font-size: 11px; padding: 4px 8px;">
                            🔄 Refresh
                        </button>
                    </div>
                </div>
                <textarea id="pageCacheYaml" style="width: 100%; height: 250px; padding: 20px" placeholder="Browser cache will appear here..."></textarea>
                <div style="font-size: 11px; color: var(--text-muted); margin-top: 5px;">
                    Edit the YAML above and click Save to update your browser cache. Click Refresh to reload current cache values.
                </div>
            </div>
            
            <div style="border-top: 1px solid var(--border-light); padding-top: 20px;">
                <div id="readme-content"></div>
            </div>
        </div>

        <div class="card" id="participants-table-card" style="display: none;">

            <div id="list-title-holder" style="margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-light); padding-bottom: 15px;">
                <h2 class="card-title" id="list-title" style="margin: 0;">📊 Participants List</h2>
                <div style="display: flex; gap: 10px;">
                    <button id="contribs-btn" class="btn btn-secondary view-btn" style="display: none;" onclick="toggleContributions()">Repos</button>
                    <button id="insights-btn" class="btn btn-secondary view-btn" style="display: none;" onclick="toggleInsights()">Insights</button>
                    <a href="edit.html?add=visit" id="add-visit-btn" class="btn btn-secondary view-btn" style="display: none;">Add City Visit</a>
                    <a href="map/#list=cities" id="map-btn" class="btn btn-primary view-btn" style="display: none;">Map</a>
                    <button id="sign-in-btn" class="btn btn-primary" style="display: none;" onclick="showAuthModal()">Sign In</button>
                </div>
            </div>

            <!-- AI Insights -->
            <div id="aiInsights" style="display: none;">
                <div class="insights-header">
                    <div class="insights-status" id="insightsStatus">
                        <div class="insight-button-group">
                            <button id="claudeInsightsBtn" class="btn btn-secondary" onclick="handleClaudeInsightsClick()">
                                <span id="claudeInsightsText">Claude Insights</span>
                            </button>
                            <button id="claudeRefreshBtn" class="btn btn-secondary refresh-btn" onclick="showRefreshPrompt('claude')" title="Refresh with custom prompt" style="display: none;">
                                <span>↻</span>
                            </button>
                        </div>
                        <div class="insight-button-group">
                            <button id="geminiInsightsBtn" class="btn btn-primary" onclick="handleGeminiInsightsClick()">
                                <span id="geminiInsightsText">Gemini Insights</span>
                            </button>
                            <button id="geminiRefreshBtn" class="btn btn-primary refresh-btn" onclick="showRefreshPrompt('gemini')" title="Refresh with custom prompt" style="display: none;">
                                <span>↻</span>
                            </button>
                        </div>
                        <div class="max-rows-control" style="display: flex; align-items: center; gap: 6px; margin-top: 8px; font-size: 12px;">
                            <label for="maxRowsInput" style="color: var(--text-secondary); white-space: nowrap;">Max rows:</label>
                            <input type="number" id="maxRowsInput" value="20" min="1" max="100" style="width: 50px; padding: 4px 6px; border: 1px solid var(--border-light); border-radius: 4px; font-size: 12px;" title="Maximum number of rows to send to Gemini API">
                        </div>
                    </div>
                </div>
                <div id="insightsContent" class="insights-content">
                    <div style="color: var(--text-secondary); font-style: italic; text-align: center; padding: 20px;">
                        Click "Claude Insights" or "Gemini Insights" for AI analysis. Use the ↻ refresh button for custom prompts.
                    </div>
                </div>
            </div>
            
            <!-- Contributions Panel -->
            <div id="contributionsPanel" style="display: none; margin-top: 16px;">
                <div class="insights-header">
                    <div class="insights-status" id="contribsStatus">
                        <div style="display:flex; gap:8px; align-items:center;">
                                <div style="color: var(--text-secondary); font-size: 13px;">Show contributions summary and links for selected members.</div>
                            </div>
                    </div>
                </div>
                <div id="contributionsContent" class="insights-content">
                    <div id="githubTokenPrompt" style="color: var(--text-secondary); font-style: italic; text-align: center; padding: 8px 20px 4px 20px;">
                        Contributions panel — optionally paste a GitHub personal access token to raise API limits for live PR fetches.
                    </div>
                    <div style="display:flex; gap:8px; align-items:center; margin:8px 0; flex-wrap:wrap;">
                        <div id="githubTokenControls" style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                            <input id="githubTokenInput" type="password" class="form-control" placeholder="Paste GitHub token" style="max-width:420px;" aria-label="GitHub token input">
                            <button class="btn btn-primary" id="saveGithubTokenBtn" onclick="saveGithubToken()">Save</button>
                            <button class="btn btn-secondary" id="clearGithubTokenBtn" onclick="clearGithubToken()">Clear</button>
                        </div>
                        <div id="githubTokenStatus" style="color:var(--text-secondary); font-size:12px; flex:1; min-width:160px;"></div>
                    </div>
                    
                    <!-- Filter row for submodule cards -->
                    <div id="prsFilters" style="margin-top:8px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                        <div style="color:var(--text-secondary); font-size:13px; margin-right:6px;">Show:</div>
                        <button class="btn" data-pr-filter="all" onclick="applyPrFilter('all')">All Repos</button>
                        <button class="btn" data-pr-filter="with" onclick="applyPrFilter('with')">With PRs</button>
                        <button class="btn" data-pr-filter="without" onclick="applyPrFilter('without')">Without PRs</button>
                    </div>
                    <div id="prsContainer" style="margin-top:12px;"></div>
                </div>
            </div>
            
            <div class="group-control" id="group-control">
                <!-- Snapshot Selection moved to top -->
                <label class="form-label">Snapshot</label>
                <div class="snapshot-controls">
                    <select id="snapshot" class="form-select snapshot-dropdown">
                        <option value="" disabled selected>Snapshots...</option>
                    </select>
                    <div class="snapshot-input-buttons">
                        <input type="text" id="snapshot-name-input" class="form-control snapshot-input" placeholder="Enter snapshot name..." style="display: none;">
                        <div class="snapshot-buttons">
                            <button class="btn btn-secondary" id="edit-snapshot-btn" title="Edit snapshot name" style="display: none;">Edit</button>
                            <button class="btn btn-secondary" id="delete-snapshot-btn" title="Delete snapshot" style="display: none;">×</button>
                            <button class="btn btn-primary" id="save-snapshot-btn" style="display: none;">Save</button>
                            <button class="btn btn-secondary" id="cancel-snapshot-btn" style="display: none;">Cancel</button>
                        </div>
                    </div>
                </div>
                
                <div class="group-header">
                    <span id="group-snapshot-info" class="group-snapshot-info"></span>
                </div>
                <div class="group-input-group">
                    <input type="text" id="group" class="form-control" placeholder="Enter names separated by commas (e.g., Loren, Ivy, Gary)...">
                    <button class="btn btn-secondary" id="group-toggle">
                        <span id="group-toggle-text">Group</span>
                        <span id="group-count">(0)</span>
                    </button>
                </div>
                <small class="form-help">Type names and press comma or enter to highlight. Click "Group" to show only marked participants.</small>
            </div>
            
            <!-- Raw Data Editor -->
            <div class="raw-data-control" id="raw-data-control" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <label class="form-label" style="margin-bottom: 0;">Raw Data Editor</label>
                    <button class="btn" id="raw-data-close" style="padding: 4px 8px; font-size: 16px; line-height: 1; background: none; border: 1px solid var(--border-light); color: var(--text-secondary);" title="Close Raw Data Editor">×</button>
                </div>
                <div class="form-group" style="margin-bottom: 12px;">
                    <label class="form-label" style="font-size: 12px; margin-bottom: 4px;">Data Source</label>
                    <input type="text" id="raw-data-source" class="form-control" readonly style="font-size: 11px; background-color: var(--bg-tertiary); color: var(--text-secondary);" placeholder="Data source path will appear here...">
                </div>
                <div class="form-group">
                    <textarea id="raw-data-editor" class="form-control" rows="10" placeholder="Raw JSON data will appear here..."></textarea>
                    <div style="margin-top: 8px;">
                        <button class="btn btn-primary" id="apply-raw-data">Display Changes</button>
                        <button class="btn btn-secondary" id="revert-raw-data">Revert</button>
                    </div>
                    <small class="form-help">Edit the JSON data and click "Display Changes" to update the participant list. Click "Revert" to restore original data.</small>
                </div>
            </div>
            
            <!-- Team Legend and Sort Controls (Shared across all views) -->
            <div class="team-legend" id="team-legend" style="display: none;">
                <div class="legend-header">
                    <h4>Filter by Team</h4>
                    <div class="legend-controls">
                        <div class="button-with-dropdown">
                            <button class="btn btn-sm btn-secondary" id="sort-toggle">Sort by</button>
                            <div class="sort-dropdown" id="sort-dropdown" style="display: none;">
                                <div class="sort-header">
                                    <h4>Sort by</h4>
                                    <button class="btn btn-sm btn-secondary" id="close-sort">×</button>
                                </div>
                                <div class="sort-items" id="sort-items"></div>
                            </div>
                        </div>
                        <div class="button-with-dropdown">
                            <button class="btn btn-sm btn-secondary" id="status-toggle">Status</button>
                            <div class="status-dropdown" id="status-dropdown" style="display: none;">
                                <div class="status-header">
                                    <h4>Filter by Status</h4>
                                    <button class="btn btn-sm btn-secondary" id="close-status">×</button>
                                </div>
                                <div class="status-items" id="status-items"></div>
                            </div>
                        </div>
                    </div>
                    <div class="legend-controls-condensed">
                        <button class="condensed-icon-btn" id="filters-toggle" title="Filters">
                            ⚙
                        </button>
                        <div class="menu-dropdown" id="filters-dropdown" style="display: none;">
                            <div class="menu-item" id="condensed-sort-toggle">Sort by</div>
                            <div class="menu-item" id="condensed-status-toggle">Status</div>
                        </div>
                    </div>
                </div>
                <div class="legend-items" id="legend-items"></div>
            </div>
            
            <!-- View Toggle Controls -->
            <div class="view-controls">
                <div class="view-buttons">
                    <button class="btn btn-secondary view-btn active" id="column-view-btn" data-view="column">
                        Columns
                    </button>
                    <button class="btn btn-secondary view-btn" id="table-view-btn" data-view="table">
                        Table
                    </button>
                    <button class="btn btn-secondary view-btn" id="gallery-view-btn" data-view="gallery">
                        Gallery
                    </button>
                </div>
                <div class="view-buttons-condensed">
                    <button class="condensed-icon-btn" id="column-view-condensed" data-view="column" title="Columns">
                        ▦
                    </button>
                    <button class="condensed-icon-btn" id="table-view-condensed" data-view="table" title="Table">
                        ☰
                    </button>
                    <button class="condensed-icon-btn" id="gallery-view-condensed" data-view="gallery" title="Gallery">
                        ⊞
                    </button>
                </div>
                <div class="table-info">
                    <span id="results-count" style="margin-right:10px">0 results</span>
                    <div class="pagination-controls" style="display: none;">
                        <button id="prev-page" class="pagination-btn" title="Previous page">‹</button>
                        <button id="next-page" class="pagination-btn" title="Next page">›</button>
                    </div>
                </div>
            </div>
            
            
            <!-- Column View (Default) -->
            <!-- Map (heat) inserted above views -->
            <div id="participants-map-container">
                <div id="participants-map-controls">
                    <div style="font-size:13px; color:var(--text-secondary)">Participants density</div>
                    <div style="display:flex; gap:8px; align-items:center;">
                        <button id="toggle-heatmap-btn" class="btn btn-sm btn-secondary">Hide map</button>
                        <button id="toggle-state-counts-btn" class="btn btn-sm btn-secondary">Show states</button>
                    </div>
                </div>
                <div id="participants-map"></div>
                <div id="participants-map-no-data">No latitude/longitude data available for heatmap.</div>
            </div>
            <div class="view-container" id="column-view">
                <div class="participants-grid" id="participants-column-grid"></div>
            </div>
            
            <!-- Table View -->
            <div class="view-container" id="table-view" style="display: none;">
                <div class="table-container">
                    <table id="participants-table" class="participants-table">
                        <thead id="table-header"></thead>
                        <tbody id="table-body"></tbody>
                    </table>
                </div>
            </div>
            
            <!-- Gallery View -->
            <div class="view-container" id="gallery-view" style="display: none;">
                <div class="participants-gallery" id="participants-gallery-grid"></div>
            </div>
            
            <!-- Email List (Admin Mode Only) -->
            <div id="emailListContainer" style="display: none; margin-top: 20px; border-top: 1px solid var(--border-light); padding-top: 20px;">
                <h3 style="margin-bottom: 12px; color: var(--text-primary); font-size: 16px; font-weight: 600;">
                    📧 Extracted Emails
                </h3>
                <textarea 
                    id="emailList" 
                    readonly 
                    style="width: 100%; min-height: 80px; padding: 12px; border: 1px solid var(--border-light); border-radius: var(--radius-md); background: var(--bg-tertiary); color: var(--text-secondary); font-family: 'Courier New', monospace; font-size: 13px; resize: vertical; line-height: 1.4;"
                    placeholder="No emails found in the dataset"
                ></textarea>
                <div style="margin-top: 8px; font-size: 12px; color: var(--text-muted);">
                    <span id="emailCount">0 emails</span> • Click to select all
                </div>
            </div>
        </div>
        
        <!-- Gemini Setup Container (shown when Gemini key is not available) -->
        <div id="gemini-setup-container" style="display: none;"></div>
        
        <!-- Prompt Modal for custom AI prompts -->
        <div class="prompt-modal hidden" id="promptModal">
            <div class="prompt-modal-content">
                <h3 id="promptModalTitle">Refresh AI Insights</h3>
                <div style="margin-bottom: 16px; color: var(--text-secondary); font-size: 14px;">
                    Enter a custom prompt to send with your dataset:
                </div>
                <textarea id="promptInput" placeholder="Tell me an amazing poem about this data.">Tell me an amazing poem about this data.</textarea>
                <div class="modal-actions">
                    <button class="btn btn-secondary" onclick="closePromptModal()">Cancel</button>
                    <button id="promptSubmitBtn" class="btn btn-primary" onclick="submitPrompt()">Refresh Insights</button>
                </div>
            </div>
        </div>
        
        <!-- Status Messages (external to card) -->
        <div id="statusMessages" class="message-log" style="margin-bottom: 20px;"></div>
        
        <!-- Load Status Panel -->
        <div class="card" id="loadStatus" style="display: none;">
            <div id="participants-result"></div>
        </div>

    </div>

    <script src="../js/common.js"></script>
    <script src="../js/setup.js"></script>
    <script src="../js/list.js"></script>
    <script>
            // Leaflet heatmap helpers
            let _participantsMap = null;
            let _participantsHeatLayer = null;
            let _participantsStateLayer = null;
            let _cityDetailLayer = null;
            let heatmapVisible = true;

            // Simple state centroids (abbr -> { name, lat, lng }) for US states
            // Used to render state-count circle markers without needing full GeoJSON.
            const US_STATE_CENTROIDS = {
                'AL': { name: 'Alabama', lat: 32.806671, lng: -86.791130 },
                'AK': { name: 'Alaska', lat: 61.370716, lng: -152.404419 },
                'AZ': { name: 'Arizona', lat: 33.729759, lng: -111.431221 },
                'AR': { name: 'Arkansas', lat: 34.969704, lng: -92.373123 },
                'CA': { name: 'California', lat: 36.116203, lng: -119.681564 },
                'CO': { name: 'Colorado', lat: 39.059811, lng: -105.311104 },
                'CT': { name: 'Connecticut', lat: 41.597782, lng: -72.755371 },
                'DE': { name: 'Delaware', lat: 39.318523, lng: -75.507141 },
                'FL': { name: 'Florida', lat: 27.766279, lng: -81.686783 },
                'GA': { name: 'Georgia', lat: 33.040619, lng: -83.643074 },
                'HI': { name: 'Hawaii', lat: 21.094318, lng: -157.498337 },
                'ID': { name: 'Idaho', lat: 44.240459, lng: -114.478828 },
                'IL': { name: 'Illinois', lat: 40.349457, lng: -88.986137 },
                'IN': { name: 'Indiana', lat: 39.849426, lng: -86.258278 },
                'IA': { name: 'Iowa', lat: 42.011539, lng: -93.210526 },
                'KS': { name: 'Kansas', lat: 38.526600, lng: -96.726486 },
                'KY': { name: 'Kentucky', lat: 37.668140, lng: -84.670067 },
                'LA': { name: 'Louisiana', lat: 31.169546, lng: -91.867805 },
                'ME': { name: 'Maine', lat: 44.693947, lng: -69.381927 },
                'MD': { name: 'Maryland', lat: 39.063946, lng: -76.802101 },
                'MA': { name: 'Massachusetts', lat: 42.230171, lng: -71.530106 },
                'MI': { name: 'Michigan', lat: 43.326618, lng: -84.536095 },
                'MN': { name: 'Minnesota', lat: 45.694454, lng: -93.900192 },
                'MS': { name: 'Mississippi', lat: 32.741646, lng: -89.678696 },
                'MO': { name: 'Missouri', lat: 38.456085, lng: -92.288368 },
                'MT': { name: 'Montana', lat: 46.921925, lng: -110.454353 },
                'NE': { name: 'Nebraska', lat: 41.125370, lng: -98.268082 },
                'NV': { name: 'Nevada', lat: 38.313515, lng: -117.055374 },
                'NH': { name: 'New Hampshire', lat: 43.452492, lng: -71.563896 },
                'NJ': { name: 'New Jersey', lat: 40.298904, lng: -74.521011 },
                'NM': { name: 'New Mexico', lat: 34.840515, lng: -106.248482 },
                'NY': { name: 'New York', lat: 42.165726, lng: -74.948051 },
                'NC': { name: 'North Carolina', lat: 35.630066, lng: -79.806419 },
                'ND': { name: 'North Dakota', lat: 47.528912, lng: -99.784012 },
                'OH': { name: 'Ohio', lat: 40.388783, lng: -82.764915 },
                'OK': { name: 'Oklahoma', lat: 35.565342, lng: -96.928917 },
                'OR': { name: 'Oregon', lat: 44.572021, lng: -122.070938 },
                'PA': { name: 'Pennsylvania', lat: 40.590752, lng: -77.209755 },
                'RI': { name: 'Rhode Island', lat: 41.680893, lng: -71.511780 },
                'SC': { name: 'South Carolina', lat: 33.856892, lng: -80.945007 },
                'SD': { name: 'South Dakota', lat: 44.299782, lng: -99.438828 },
                'TN': { name: 'Tennessee', lat: 35.747845, lng: -86.692345 },
                'TX': { name: 'Texas', lat: 31.054487, lng: -97.563461 },
                'UT': { name: 'Utah', lat: 40.150032, lng: -111.862434 },
                'VT': { name: 'Vermont', lat: 44.045876, lng: -72.710686 },
                'VA': { name: 'Virginia', lat: 37.769337, lng: -78.169968 },
                'WA': { name: 'Washington', lat: 47.400902, lng: -121.490494 },
                'WV': { name: 'West Virginia', lat: 38.491226, lng: -80.954456 },
                'WI': { name: 'Wisconsin', lat: 44.268543, lng: -89.616508 },
                'WY': { name: 'Wyoming', lat: 42.755966, lng: -107.302490 }
            };

            // Map of lowercased state names to abbr for parsing full names
            const US_STATE_NAME_TO_ABBR = (function(){
                const m = {};
                Object.keys(US_STATE_CENTROIDS).forEach(abbr => { m[US_STATE_CENTROIDS[abbr].name.toLowerCase()] = abbr; });
                return m;
            })();

            function initParticipantsHeatmap() {
                if (_participantsMap) return _participantsMap;
                const mapEl = document.getElementById('participants-map');
                if (!mapEl) return null;
                if (typeof L === 'undefined') {
                    console.warn('Leaflet (L) is not defined - check that the Leaflet script was loaded');
                    return null;
                }
                // Disable the built-in zoom controls (remove + / - buttons)
                // and disable other interactive zoom gestures (wheel/double-click/touch).
                // Initialize the map and later fit bounds to the continental USA so
                // the map reliably shows the states on first render.
                _participantsMap = L.map(mapEl, {
                    zoomControl: false,
                    attributionControl: false,
                    scrollWheelZoom: false,
                    doubleClickZoom: false,
                    boxZoom: false,
                    touchZoom: false,
                    // Allow deeper zoom so city-level views can be reached programmatically
                    minZoom: 4,
                    maxZoom: 15
                });
                const tile = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 18,
                }).addTo(_participantsMap);
                // Fit the map to the contiguous United States bounds so the states are visible
                // on initial load. These bounds roughly cover the continental US (lat, lng).
                try {
                    // Raise the southern bound further (28.0) to avoid showing Mexican states
                    // on the initial view while still covering the continental US.
                    const usaSouthWest = [28.0, -124.848974]; // SW corner (approx, raised lat)
                    const usaNorthEast = [49.384358, -66.885444];  // NE corner (approx)
                    const usaBounds = L.latLngBounds(usaSouthWest, usaNorthEast);
                    // Fit bounds with a tighter padding after tiles load to zoom in more on the continental USA.
                    // Only fit bounds on the initial tile load. Using `once` prevents
                    // subsequent tile loads (triggered by programmatic zooms) from
                    // resetting the view back to the country overview.
                    tile.once('load', function() {
                        try {
                            // Use a slightly larger pad to keep the view comfortably within the US
                            _participantsMap.fitBounds(usaBounds.pad(0.04));
                        } catch (e) {
                            // fallback to setView if fitBounds fails
                            _participantsMap.setView([39.8283, -98.5795], 5);
                        }
                    });
                    // Also set max bounds so panning stays roughly within the US region
                    try { _participantsMap.setMaxBounds(usaBounds.pad(0.35)); } catch (e) {}
                } catch (e) {
                    // If anything goes wrong, fall back to centered view
                    try { _participantsMap.setView([39.8283, -98.5795], 4); } catch (err) {}
                }
                // Don't create the heat layer immediately if the container hasn't
                // been laid out yet (canvas width/height 0 can cause getImageData errors).
                // Defer creation to ensure the map container has non-zero size.
                function createHeatLayerIfReady() {
                    try {
                        const mapElRect = mapEl.getBoundingClientRect();
                        if (mapElRect.width > 0 && mapElRect.height > 0) {
                            if (!_participantsHeatLayer) {
                                _participantsHeatLayer = L.heatLayer([], { radius: 25, blur: 15, maxZoom: 10 }).addTo(_participantsMap);
                            }
                            return true;
                        }
                    } catch (e) {
                        // ignore
                    }
                    return false;
                }

                // Try to create the heat layer now; if not ready, schedule retries.
                if (!createHeatLayerIfReady()) {
                    let attempts = 0;
                    const maxAttempts = 8;
                    const tryCreate = function() {
                        attempts++;
                        if (createHeatLayerIfReady()) return;
                        if (attempts < maxAttempts) {
                            setTimeout(tryCreate, 150 * attempts);
                        }
                    };
                    setTimeout(tryCreate, 120);
                }

                // Add a small status legend control to the map (bottom-right)
                try {
                    function addStatusLegendTo(map) {
                        if (!map || !L) return;
                        if (map._statusLegendAdded) return;
                        const legend = L.control({ position: 'topright' });
                        legend.onAdd = function () {
                            const div = L.DomUtil.create('div', 'leaflet-control status-legend');
                            const rows = [
                                { color: '#22c55e', label: 'Active' },
                                { color: '#9ca3af', label: 'Inactive' },
                                { color: '#3b82f6', label: 'New' },
                                { color: '#8b5cf6', label: 'Lead' }
                            ];
                            rows.forEach(r => {
                                const item = L.DomUtil.create('div', 'item', div);
                                const sw = L.DomUtil.create('span', 'swatch', item);
                                sw.style.background = r.color;
                                const lbl = L.DomUtil.create('span', 'label', item);
                                lbl.innerText = r.label;
                            });
                            L.DomEvent.disableClickPropagation(div);
                            return div;
                        };
                        legend.addTo(map);
                        map._statusLegendAdded = true;
                    }
                    // Try to add immediately (if map already ready) and also when tiles load
                    addStatusLegendTo(_participantsMap);
                    try { tile.on('load', function() { addStatusLegendTo(_participantsMap); }); } catch (e) {}
                    // Add simple custom zoom controls (top-left) so users can zoom without wheel/dblclick
                    try {
                        if (!_participantsMap._customZoomAdded) {
                            const zoomCtl = L.control({ position: 'topleft' });
                            zoomCtl.onAdd = function() {
                                const container = L.DomUtil.create('div', 'leaflet-bar custom-zoom-control');
                                const zin = L.DomUtil.create('a', 'leaflet-control-zoom-in', container);
                                zin.innerHTML = '+';
                                zin.href = '#';
                                zin.title = 'Zoom in';
                                const zout = L.DomUtil.create('a', 'leaflet-control-zoom-out', container);
                                zout.innerHTML = '−';
                                zout.href = '#';
                                zout.title = 'Zoom out';
                                L.DomEvent.disableClickPropagation(container);
                                L.DomEvent.on(zin, 'click', L.DomEvent.stop).on(zin, 'click', function(e) { try { _participantsMap.zoomIn(); } catch(e){} });
                                L.DomEvent.on(zout, 'click', L.DomEvent.stop).on(zout, 'click', function(e) { try { _participantsMap.zoomOut(); } catch(e){} });
                                return container;
                            };
                            zoomCtl.addTo(_participantsMap);
                            _participantsMap._customZoomAdded = true;
                        }
                    } catch (e) { console.debug('custom zoom control add failed', e); }
                } catch (e) { console.debug('status legend add failed', e); }

                return _participantsMap;
            }

            // Ensure the heat layer exists; returns a Promise that resolves when created or rejects after retries
            function ensureParticipantsHeatLayer(retries = 6, delay = 150) {
                return new Promise((resolve, reject) => {
                    if (_participantsHeatLayer) return resolve(_participantsHeatLayer);
                    let attempts = 0;
                    const tryOnce = () => {
                        attempts++;
                        try {
                            const mapEl = document.getElementById('participants-map');
                            if (mapEl) {
                                const rect = mapEl.getBoundingClientRect();
                                if (rect.width > 0 && rect.height > 0) {
                                    if (!_participantsHeatLayer && _participantsMap) {
                                        _participantsHeatLayer = L.heatLayer([], { radius: 25, blur: 15, maxZoom: 10 }).addTo(_participantsMap);
                                    }
                                }
                            }
                        } catch (e) {}
                        if (_participantsHeatLayer) return resolve(_participantsHeatLayer);
                        if (attempts >= retries) return reject(new Error('heat layer not ready'));
                        setTimeout(tryOnce, delay);
                    };
                    tryOnce();
                });
            }

            // Extract a US state abbreviation from a participant row by checking common keys
            function extractStateFromRow(row) {
                if (!row || typeof row !== 'object') return null;
                const keys = Object.keys(row || {});
                // common columns
                const stateKey = keys.find(k => ['state','province','region','State','STATE'].includes(k));
                if (stateKey && row[stateKey]) {
                    const v = String(row[stateKey]).trim();
                    const up = v.toUpperCase();
                    if (US_STATE_CENTROIDS[up]) return up;
                    // try abbreviation inside string
                    const abbrMatch = v.match(/\b([A-Z]{2})\b/);
                    if (abbrMatch && US_STATE_CENTROIDS[abbrMatch[1]]) return abbrMatch[1];
                    // try full name
                    const nm = v.toLowerCase();
                    if (US_STATE_NAME_TO_ABBR[nm]) return US_STATE_NAME_TO_ABBR[nm];
                }
                // fallback: try parsing 'location' or address-like fields
                const locKey = keys.find(k => ['location','Location','address','city'].includes(k));
                if (locKey && row[locKey]) {
                    const s = String(row[locKey]).trim();
                    // look for ', XX' at end like 'City, ST' or 'City, State'
                    const m = s.match(/,\s*([A-Za-z]{2})\.?\s*$/);
                    if (m && m[1]) {
                        const ab = m[1].toUpperCase();
                        if (US_STATE_CENTROIDS[ab]) return ab;
                    }
                    // try full state name somewhere in the string
                    Object.keys(US_STATE_NAME_TO_ABBR).forEach(nm => {
                        if (s.toLowerCase().includes(nm) && !US_STATE_CENTROIDS[US_STATE_NAME_TO_ABBR[nm]]) {
                            // noop - defensive
                        }
                    });
                    for (const nm in US_STATE_NAME_TO_ABBR) {
                        if (s.toLowerCase().indexOf(nm) !== -1) return US_STATE_NAME_TO_ABBR[nm];
                    }
                }
                return null;
            }

            function updateStateCountsFromData(data) {
                if (!_participantsMap) return;
                if (!Array.isArray(data) || data.length === 0) {
                    // clear layer
                    if (_participantsStateLayer) { _participantsStateLayer.clearLayers(); }
                    return;
                }
                // Aggregate counts per city (preferred) falling back to state centroids.
                // cityCounts keyed by either a lat,lng pair or state-abbr when coords unavailable.
                const cityCounts = {}; // { key: { lat, lng, label, counts: {active,inactive,new,lead} } }
                const statusOf = function(row) {
                    if (!row) return 'inactive';
                    const keys = Object.keys(row || {});
                    const statusKey = keys.find(k => ['status','member_status','membership_status','role','type','membership'].includes(k.toLowerCase()));
                    let v = null;
                    if (statusKey) v = String(row[statusKey]).trim().toLowerCase();
                    // fallback heuristics
                    if (!v && row.title) v = String(row.title).toLowerCase();
                    if (!v && row.role) v = String(row.role).toLowerCase();
                    if (!v) return 'inactive';
                    if (v.indexOf('lead') !== -1 || v.indexOf('owner') !== -1 || v.indexOf('maintain') !== -1 || v.indexOf('admin') !== -1) return 'lead';
                    if (v.indexOf('new') !== -1 || v.indexOf('joined') !== -1 || v.indexOf('recent') !== -1) return 'new';
                    if (v.indexOf('inactive') !== -1 || v.indexOf('former') !== -1 || v.indexOf('left') !== -1) return 'inactive';
                    if (v.indexOf('active') !== -1 || v.indexOf('member') !== -1 || v.indexOf('contributor') !== -1) return 'active';
                    // default fallback
                    return 'inactive';
                };
                // Helper: try to extract city name and/or lat/lng from row
                function getCityInfo(row) {
                    if (!row || typeof row !== 'object') return null;
                    const keys = Object.keys(row);
                    // detect lat/lng keys (case-insensitive)
                    const lowerKeys = keys.map(k => k.toLowerCase());
                    const latKey = lowerKeys.includes('latitude') ? keys[lowerKeys.indexOf('latitude')] : (lowerKeys.includes('lat') ? keys[lowerKeys.indexOf('lat')] : null);
                    const lngKey = lowerKeys.includes('longitude') ? keys[lowerKeys.indexOf('longitude')] : (lowerKeys.includes('lng') ? keys[lowerKeys.indexOf('lng')] : (lowerKeys.includes('lon') ? keys[lowerKeys.indexOf('lon')] : (lowerKeys.includes('long') ? keys[lowerKeys.indexOf('long')] : null)));
                    let lat = null, lng = null;
                    if (latKey && lngKey) {
                        lat = parseFloat(row[latKey]);
                        lng = parseFloat(row[lngKey]);
                        if (isNaN(lat) || isNaN(lng)) { lat = null; lng = null; }
                    }
                    // try to parse combined location field if lat/lng not present
                    if ((lat == null || lng == null)) {
                        const locKeyIndex = lowerKeys.findIndex(k => ['location','address','city','place'].includes(k));
                        if (locKeyIndex !== -1) {
                            const locVal = String(row[keys[locKeyIndex]] || '').trim();
                            if (locVal) {
                                // try to parse numeric pair
                                const pair = locVal.match(/([+-]?\d{1,3}(?:\.\d+)?)[^0-9+-]+([+-]?\d{1,3}(?:\.\d+)?)/);
                                if (pair && pair.length >= 3) {
                                    const la = parseFloat(pair[1]);
                                    const lo = parseFloat(pair[2]);
                                    if (!isNaN(la) && !isNaN(lo)) { lat = la; lng = lo; }
                                }
                            }
                        }
                    }
                    // Try to get city name separately
                    let city = null;
                    const cityKeyIndex = lowerKeys.findIndex(k => ['city','town','locality','place'].includes(k));
                    if (cityKeyIndex !== -1) city = String(row[keys[cityKeyIndex]] || '').trim();
                    // Fallback: try to extract city from a 'location' field like 'City, ST'
                    if (!city) {
                        const locKeyIndex2 = lowerKeys.findIndex(k => ['location','address'].includes(k));
                        if (locKeyIndex2 !== -1) {
                            const s = String(row[keys[locKeyIndex2]] || '');
                            const m = s.match(/^\s*([^,]+),/);
                            if (m && m[1]) city = m[1].trim();
                        }
                    }
                    // Also attempt to extract state (abbr) to build a nicer label
                    const state = extractStateFromRow(row);
                    // If we don't have explicit coordinates but have a city and state,
                    // approximate a deterministic location near the state centroid so
                    // the city marker points roughly to the city's region instead of
                    // the state center for all cities.
                    if ((lat == null || lng == null) && city && state && US_STATE_CENTROIDS[state]) {
                        try {
                            const cent = US_STATE_CENTROIDS[state];
                            // deterministic hash from city name
                            let sum = 0;
                            for (let i = 0; i < city.length; i++) sum = (sum * 31 + city.charCodeAt(i)) | 0;
                            const angle = (Math.abs(sum) % 360) * (Math.PI / 180);
                            const dist = 0.2 + (Math.abs(sum) % 100) / 1000; // ~0.2 - 0.299 degrees
                            const approxLat = cent.lat + Math.sin(angle) * dist;
                            const approxLng = cent.lng + Math.cos(angle) * dist;
                            return { city: city || null, state: state || null, lat: approxLat, lng: approxLng };
                        } catch (e) {
                            // fallback to null coords
                        }
                    }

                    return { city: city || null, state: state || null, lat: lat, lng: lng };
                }

                data.forEach(r => {
                    try {
                        const info = getCityInfo(r);
                        const stat = statusOf(r) || 'inactive';
                        if (info && info.lat != null && info.lng != null) {
                            // prefer aggregating by exact lat/lng if available
                            const key = `${info.lat.toFixed(5)},${info.lng.toFixed(5)}`;
                            cityCounts[key] = cityCounts[key] || { lat: info.lat, lng: info.lng, label: info.city || `${info.lat.toFixed(2)},${info.lng.toFixed(2)}`, counts: { active:0, inactive:0, new:0, lead:0 } };
                            cityCounts[key].counts[stat] = (cityCounts[key].counts[stat] || 0) + 1;
                        } else if (info && info.state) {
                            // fallback to state centroid aggregation
                            const st = info.state;
                            const cent = US_STATE_CENTROIDS[st];
                            if (!cent) return;
                            const key = `STATE:${st}`;
                            cityCounts[key] = cityCounts[key] || { lat: cent.lat, lng: cent.lng, label: cent.name, counts: { active:0, inactive:0, new:0, lead:0 } };
                            cityCounts[key].counts[stat] = (cityCounts[key].counts[stat] || 0) + 1;
                        }
                    } catch (e) {}
                });
                // Create or clear state layer
                if (!_participantsStateLayer) {
                    _participantsStateLayer = L.layerGroup().addTo(_participantsMap);
                } else {
                    _participantsStateLayer.clearLayers();
                }

                // For visualization, render one small colored bubble per status category per state
                const STATE_STATUS_COLORS = {
                    active: '#22c55e',    // green
                    inactive: '#9ca3af',  // gray
                    new: '#3b82f6',       // blue
                    lead: '#8b5cf6'       // purple
                };
                const entries = Object.keys(cityCounts);
                if (entries.length === 0) return;
                // compute max single-status count for sizing
                let maxSingle = 0;
                entries.forEach(key => {
                    const s = cityCounts[key].counts;
                    Object.keys(s).forEach(k => { if (s[k] > maxSingle) maxSingle = s[k]; });
                });
                if (maxSingle === 0) maxSingle = 1;

                // small offset generator so multiple bubbles don't overlap exactly
                const offsetForIndex = function(i, total) {
                    const angle = (i / total) * Math.PI * 2 - Math.PI/2;
                    const dist = 0.02; // degrees ~ smaller offset for city clusters
                    return [Math.sin(angle) * dist, Math.cos(angle) * dist];
                };

                entries.forEach(k => {
                    const item = cityCounts[k];
                    if (!item) return;
                    const s = item.counts;
                    const statusList = Object.keys(s).filter(st => s[st] > 0);
                    const totalStatuses = statusList.length || 1;
                    statusList.forEach((status, idx) => {
                        const cnt = s[status];
                        const pct = cnt / maxSingle;
                        const radius = 5 + Math.round(18 * Math.sqrt(pct));
                        const color = STATE_STATUS_COLORS[status] || '#6b7280';
                        const off = offsetForIndex(idx, totalStatuses);
                        const lat = item.lat + off[0];
                        const lng = item.lng + off[1];
                        const circle = L.circleMarker([lat, lng], {
                            radius: radius,
                            fillColor: color,
                            color: '#111827',
                            weight: 1,
                            opacity: 0.6,
                            fillOpacity: 0.85
                        });
                        const popupHtml = `<strong>${escapeHtml(item.label)}</strong><br/>${escapeHtml(status)}: <strong>${cnt}</strong>`;
                        circle.bindPopup(popupHtml);
                        // click to zoom into this city and show detailed participant markers
                        circle.on('click', function() {
                            try { zoomToCity(item.lat, item.lng, item.label); } catch(e){}
                        });
                        _participantsStateLayer.addLayer(circle);
                    });
                    // Add a small invisible marker to show full breakdown when clicked
                    const breakdown = Object.keys(item.counts).map(k => `${k}: ${item.counts[k]}`).join('<br/>');
                    const centerMarker = L.circleMarker([item.lat, item.lng], { radius: 0.5, opacity: 0 });
                    centerMarker.bindPopup(`<strong>${escapeHtml(item.label)}</strong><br/>${breakdown}`);
                    centerMarker.on('click', function() { try { zoomToCity(item.lat, item.lng, item.label); } catch(e){} });
                    _participantsStateLayer.addLayer(centerMarker);
                });
            }

            // Zoom into a city and show individual participant markers for that city
            function zoomToCity(lat, lng, label) {
                if (!_participantsMap) return;
                try {
                    // zoom in
                    const targetZoom = 10; // adjustable zoom for city level
                    _participantsMap.setView([lat, lng], targetZoom);

                    // clear previous detail layer
                    if (!_cityDetailLayer) _cityDetailLayer = L.layerGroup();
                    _cityDetailLayer.clearLayers();

                    const rows = window.participantsData || [];
                    if (!Array.isArray(rows) || rows.length === 0) return;

                    // helper to parse lat/lng from a row (similar to earlier logic)
                    function parseRowLatLng(r) {
                        if (!r || typeof r !== 'object') return null;
                        const keys = Object.keys(r);
                        const lower = keys.map(k => k.toLowerCase());
                        const latKey = lower.includes('latitude') ? keys[lower.indexOf('latitude')] : (lower.includes('lat') ? keys[lower.indexOf('lat')] : null);
                        const lngKey = lower.includes('longitude') ? keys[lower.indexOf('longitude')] : (lower.includes('lng') ? keys[lower.indexOf('lng')] : (lower.includes('lon') ? keys[lower.indexOf('lon')] : (lower.includes('long') ? keys[lower.indexOf('long')] : null)));
                        if (latKey && lngKey) {
                            let la = parseFloat(r[latKey]);
                            let lo = parseFloat(r[lngKey]);
                            if (!isNaN(la) && !isNaN(lo)) {
                                // Correct swapped lat/lng if detected
                                if (Math.abs(la) > 90 && Math.abs(lo) <= 90) { const tmp = la; la = lo; lo = tmp; }
                                return [la, lo];
                            }
                        }
                        // try combined location
                        const locIndex = lower.findIndex(k => ['location','address','place'].includes(k));
                        if (locIndex !== -1) {
                            const s = String(r[keys[locIndex]] || '');
                            const m = s.match(/([+-]?\d{1,3}(?:\.\d+)?)[^0-9+-]+([+-]?\d{1,3}(?:\.\d+)?)/);
                            if (m && m.length >= 3) {
                                const la = parseFloat(m[1]);
                                const lo = parseFloat(m[2]);
                                if (!isNaN(la) && !isNaN(lo)) return [la, lo];
                            }
                        }
                        return null;
                    }

                    // find participants near the city (within ~0.05 degrees) or matching label
                    const tol = 0.05;
                    const matches = [];
                    for (const r of rows) {
                        try {
                            const coords = parseRowLatLng(r);
                            if (coords) {
                                const dlat = Math.abs(coords[0] - lat);
                                const dlng = Math.abs(coords[1] - lng);
                                if (dlat <= tol && dlng <= tol) {
                                    matches.push({ row: r, lat: coords[0], lng: coords[1] });
                                    continue;
                                }
                            }
                            // fallback: match by city label in a 'city' or 'location' field
                            const keys = Object.keys(r || {});
                            const lowKeys = keys.map(k => k.toLowerCase());
                            const cityIndex = lowKeys.findIndex(k => ['city','town','place','location'].includes(k));
                            if (cityIndex !== -1) {
                                const val = String(r[keys[cityIndex]] || '').toLowerCase();
                                if (label && val && label.toLowerCase().includes(val) || (val && label && val.includes(label.toLowerCase()))) {
                                    // try to parse coords for marker positioning
                                    const coords2 = parseRowLatLng(r) || [lat + (Math.random()-0.5)*0.005, lng + (Math.random()-0.5)*0.005];
                                    matches.push({ row: r, lat: coords2[0], lng: coords2[1] });
                                }
                            }
                        } catch (e) {}
                    }

                    // If no matches, show a temporary marker at center
                    if (matches.length === 0) {
                        const temp = L.circleMarker([lat, lng], { radius: 8, fillColor: '#2563eb', color:'#0f172a', weight:1, fillOpacity:0.9 });
                        temp.bindPopup(`<strong>${escapeHtml(label || 'Location')}</strong><br/><small>No individual participant coordinates found.</small>`);
                        _cityDetailLayer.addLayer(temp);
                    } else {
                        // create markers for each participant
                        matches.forEach(m => {
                            const p = m.row;
                            const name = p.name || p.Name || p.fullname || p['Full Name'] || (p.user && p.user.login) || 'participant';
                            const info = escapeHtml(String(name));
                            const marker = L.circleMarker([m.lat, m.lng], { radius: 6, fillColor: '#2563eb', color: '#0f172a', weight: 1, fillOpacity: 0.95 });
                            const popup = `<strong>${info}</strong><br/>${escapeHtml(p.org || p.organization || p.company || p.Company || '')}`;
                            marker.bindPopup(popup);
                            _cityDetailLayer.addLayer(marker);
                        });
                    }

                    _cityDetailLayer.addTo(_participantsMap);

                    // (Overview reset control removed - user requested no overview button.)

                } catch (e) {
                    console.warn('zoomToCity failed', e);
                }
            }

            function updateParticipantsHeatmapFromData(data) {
                // data: array of participant objects. Look for lat/lng fields (case-insensitive)
                if (!data || !Array.isArray(data) || data.length === 0) {
                    // No data: still ensure the map is created so tiles load and the
                    // "no data" overlay can be shown on top of a real map.
                    const contEl = document.getElementById('participants-map-container');
                    if (contEl) contEl.style.display = 'block';
                    initParticipantsHeatmap();
                    document.getElementById('participants-map-no-data').style.display = 'flex';
                    return;
                }

                // Detect lat/lng keys
                const sample = data.find(d => d && typeof d === 'object');
                if (!sample) {
                    const contEl = document.getElementById('participants-map-container');
                    if (contEl) contEl.style.display = 'block';
                    initParticipantsHeatmap();
                    document.getElementById('participants-map-no-data').style.display = 'flex';
                    return;
                }

                const keys = Object.keys(sample).map(k => k.toLowerCase());
                const originalKeys = Object.keys(sample);
                const latKey = keys.includes('latitude') ? originalKeys.find(k => k.toLowerCase()==='latitude') : (keys.includes('lat') ? originalKeys.find(k => k.toLowerCase()==='lat') : null);
                const lngKey = keys.includes('longitude') ? originalKeys.find(k => k.toLowerCase()==='longitude') : (keys.includes('lng') ? originalKeys.find(k => k.toLowerCase()==='lng') : (keys.includes('lon') ? originalKeys.find(k => k.toLowerCase()==='lon') : (keys.includes('long') ? originalKeys.find(k => k.toLowerCase()==='long') : null)));
                const locationKey = keys.includes('location') ? originalKeys.find(k => k.toLowerCase()==='location') : null;

                // Helper: try to parse two numeric coords from a location string
                function parseLatLngFromLocation(val) {
                    if (val === null || val === undefined) return null;
                    const s = String(val).trim();
                    // common: "lat, lng" or "lat;lng" or "lat lng"
                    const pair = s.match(/([+-]?\d{1,3}(?:\.\d+)?)[^\d+-]+([+-]?\d{1,3}(?:\.\d+)?)/);
                    if (pair && pair.length >= 3) {
                        let la = parseFloat(pair[1]);
                        let lo = parseFloat(pair[2]);
                        if (!isNaN(la) && !isNaN(lo)) {
                            // if latitude appears out of range but longitude looks like a latitude,
                            // assume values were swapped and correct them
                            if (Math.abs(la) > 90 && Math.abs(lo) <= 90) {
                                const tmp = la; la = lo; lo = tmp;
                            }
                            return [la, lo];
                        }
                    }
                    // try explicit labels: "lat: X ... lon|lng: Y"
                    const laMatch = s.match(/lat[^0-9+-]*([+-]?\d{1,3}(?:\.\d+)?)/i);
                    const loMatch = s.match(/(?:lon|lng|long|longitude)[^0-9+-]*([+-]?\d{1,3}(?:\.\d+)?)/i);
                    if (laMatch && laMatch[1] && loMatch && loMatch[1]) {
                        let la = parseFloat(laMatch[1]);
                        let lo = parseFloat(loMatch[1]);
                        if (!isNaN(la) && !isNaN(lo)) {
                            if (Math.abs(la) > 90 && Math.abs(lo) <= 90) { const tmp = la; la = lo; lo = tmp; }
                            return [la, lo];
                        }
                    }
                    return null;
                }

                // Build heat points [lat, lng, weight]
                const points = [];
                data.forEach(r => {
                    try {
                        if (latKey && lngKey) {
                            let lat = parseFloat(r[latKey]);
                            let lng = parseFloat(r[lngKey]);
                            if (!isNaN(lat) && !isNaN(lng)) {
                                // Correct swapped lat/lng when necessary
                                if (Math.abs(lat) > 90 && Math.abs(lng) <= 90) { const tmp = lat; lat = lng; lng = tmp; }
                                points.push([lat, lng, 0.8]);
                                return;
                            }
                        }
                        // Fallback: try parsing a combined 'location' column
                        if (locationKey) {
                            const parsed = parseLatLngFromLocation(r[locationKey]);
                            if (parsed && parsed.length === 2) {
                                points.push([parsed[0], parsed[1], 0.8]);
                                return;
                            }
                        }
                    } catch (e) {
                        // Ignore malformed rows
                    }
                });

                if (points.length === 0) {
                    // Ensure map exists so tiles are visible even when there are no points
                    initParticipantsHeatmap();
                    document.getElementById('participants-map-no-data').style.display = 'flex';
                    try {
                        const listParam = (typeof getHash === 'function') ? getHash().list : null;
                        const pmc = document.getElementById('participants-map-container');
                        if (pmc) {
                            if (listParam === 'modelteam') pmc.style.display = 'block'; else pmc.style.display = 'none';
                        }
                    } catch(e) { try { document.getElementById('participants-map-container').style.display = 'block'; } catch(e){} }
                    try { if (_participantsMap && typeof _participantsMap.invalidateSize === 'function') _participantsMap.invalidateSize(); } catch(e){}
                    return;
                }

                document.getElementById('participants-map-no-data').style.display = 'none';
                try {
                    const listParam = (typeof getHash === 'function') ? getHash().list : null;
                    const pmc2 = document.getElementById('participants-map-container');
                    if (pmc2) {
                        if (listParam === 'modelteam') pmc2.style.display = 'block'; else pmc2.style.display = 'none';
                    }
                } catch(e) { try { document.getElementById('participants-map-container').style.display = 'block'; } catch(e){} }
                initParticipantsHeatmap();
                // Ensure the heat layer exists and the map container has non-zero size
                ensureParticipantsHeatLayer().then(() => {
                    try {
                        _participantsHeatLayer.setLatLngs(points);
                    } catch (e) {
                        console.warn('Failed to set heat layer latlngs', e);
                    }
                }).catch(err => {
                    console.warn('Heat layer not ready, skipping setLatLngs', err);
                });
                // After making the container visible, invalidate size so Leaflet can render correctly,
                // then fit bounds to the points. Use a short timeout to allow the DOM to layout.
                // attempt invalidateSize + fitBounds with retries to handle late layout/styling changes
                (function tryInvalidate(retriesLeft, delay){
                    setTimeout(() => {
                        try {
                            if (_participantsMap && typeof _participantsMap.invalidateSize === 'function') {
                                _participantsMap.invalidateSize();
                            }
                            // small nudge: panBy then pan back to force repaint of tiles in some browsers
                            try { if (_participantsMap && typeof _participantsMap.panBy === 'function') { _participantsMap.panBy([1,0]); _participantsMap.panBy([-1,0]); } } catch(e){}
                            // Use current heat layer latlngs if available
                            let latLngs = [];
                            try {
                                if (_participantsHeatLayer && typeof _participantsHeatLayer.getLatLngs === 'function') {
                                    latLngs = _participantsHeatLayer.getLatLngs();
                                    if (!Array.isArray(latLngs) || !latLngs.length || !Array.isArray(latLngs[0])) {
                                        latLngs = points.map(p => [p[0], p[1]]);
                                    }
                                } else {
                                    latLngs = points.map(p => [p[0], p[1]]);
                                }
                            } catch (e) {
                                latLngs = points.map(p => [p[0], p[1]]);
                            }

                            if (latLngs && latLngs.length) {
                                const bounds = L.latLngBounds(latLngs);
                                _participantsMap.fitBounds(bounds.pad(0.25));
                            }
                        } catch (e) {
                            // ignore
                        }
                        if (retriesLeft > 0) tryInvalidate(retriesLeft - 1, Math.min(600, delay * 2));
                    }, delay || 120);
                })(4, 100);
            }

            // Toggle control
            document.addEventListener('click', function(e){
                if (e.target && (e.target.id === 'toggle-heatmap-btn' || e.target.id === 'toggle-state-counts-btn')) {
                        const id = e.target.id;
                        if (id === 'toggle-heatmap-btn') {
                            heatmapVisible = !heatmapVisible;
                            const cont = document.getElementById('participants-map-container');
                            const mapEl = document.getElementById('participants-map');
                            const noDataEl = document.getElementById('participants-map-no-data');
                            if (!cont || !mapEl) return;
                            // Keep the container and controls visible; hide only the map pane so the toggle button remains accessible
                            const listParamToggle = (typeof getHash === 'function') ? getHash().list : null;
                            if (listParamToggle !== 'modelteam') {
                                // Map is only available for modelteam; do not allow toggling otherwise
                                heatmapVisible = false;
                                e.target.textContent = 'Show map';
                                try { if (cont && cont.dataset) cont.dataset.userHidden = '1'; } catch(e){}
                                return;
                            }
                            if (heatmapVisible) {
                                mapEl.style.display = 'block';
                                if (noDataEl) noDataEl.style.display = 'none';
                                e.target.textContent = 'Hide map';
                                try { if (cont && cont.dataset) delete cont.dataset.userHidden; } catch(e){}
                                setTimeout(() => {
                                    try { if (_participantsMap && typeof _participantsMap.invalidateSize === 'function') _participantsMap.invalidateSize(); } catch (err){}
                                }, 120);
                            } else {
                                // hide the map area but keep controls
                                mapEl.style.display = 'none';
                                if (noDataEl) noDataEl.style.display = 'none';
                                e.target.textContent = 'Show map';
                                try { if (cont && cont.dataset) cont.dataset.userHidden = '1'; } catch(e){}
                            }
                        } else if (id === 'toggle-state-counts-btn') {
                            // Toggle the state counts overlay visibility
                            try {
                                if (!_participantsStateLayer) {
                                    // If layer not created yet, create it from current data
                                    updateStateCountsFromData(window.participantsData || []);
                                }
                                const btn = e.target;
                                // If layer exists and has layers, we consider it visible
                                const isVisible = _participantsStateLayer && _participantsStateLayer.getLayers && _participantsStateLayer.getLayers().length > 0 && _participantsMap && _participantsMap.hasLayer && _participantsMap.hasLayer(_participantsStateLayer);
                                if (isVisible) {
                                    try { if (_participantsMap && _participantsStateLayer) _participantsMap.removeLayer(_participantsStateLayer); } catch(e){}
                                    btn.textContent = 'Show states';
                                } else {
                                    try { if (_participantsMap && _participantsStateLayer) _participantsStateLayer.addTo(_participantsMap); } catch(e){}
                                    btn.textContent = 'Hide states';
                                    // Ensure map redraw
                                    setTimeout(() => { try { if (_participantsMap && typeof _participantsMap.invalidateSize === 'function') _participantsMap.invalidateSize(); } catch(e){} }, 120);
                                }
                            } catch (err) {
                                console.debug('state counts toggle failed', err);
                            }
                        }
                    }
            });
        const GEMINI_API_BASE = 'http://localhost:8081/api';
        
        // AI Insights variables
        let currentActiveAI = null;
        let currentPromptAI = null;
        const aiInsightsCache = JSON.parse(localStorage.getItem('aiInsightsCache') || '{}');
        const claudeInsightsCache = JSON.parse(localStorage.getItem('claudeInsightsCache') || '{}');
        
        // Pending analysis storage (like admin page)
        let pendingGeminiAnalysis = null;
        let pendingClaudeAnalysis = null;
        
        // AI Insights Functions
        function showAIInsightsSection() {
            const aiInsights = document.getElementById('aiInsights');
            if (aiInsights && window.participantsData && window.participantsData.length > 0) {
                // Only show if insights=all is in URL, otherwise respect the hidden state
                const insightsParam = getHash().insights;
                if (insightsParam === 'all') {
                    aiInsights.style.setProperty('display', 'block', 'important');
                }
                showAIInsightsButtons();
            }
        }

        // Contributions panel functions
        function toggleContributions() {
            const panel = document.getElementById('contributionsPanel');
            if (!panel) return;
            const visible = panel.style.display === 'block';
            if (visible) {
                panel.style.display = 'none';
            } else {
                panel.style.display = 'block';
                // Ensure insights panel is hidden when showing contributions
                const ai = document.getElementById('aiInsights'); if (ai) ai.style.display = 'none';
                showContributionsSection();
                // Load aggregated submodule PRs (if available)
                try { loadSubmodulePRs(); } catch (e) { console.warn('loadSubmodulePRs missing', e); }
            }
        }

        // Fetch aggregated PRs file generated by GitHub Action and render them
        async function loadSubmodulePRs() {
            const content = document.getElementById('contributionsContent');
            if (!content) return;
            // Ensure there's a place for PRs
            let prsContainer = document.getElementById('prsContainer');
            if (!prsContainer) {
                prsContainer = document.createElement('div');
                prsContainer.id = 'prsContainer';
                prsContainer.style.marginTop = '12px';
                content.appendChild(prsContainer);
            }

            prsContainer.innerHTML = '<div style="padding:12px; color:var(--text-secondary);">Loading open PRs across submodules...</div>';
            try {
                // Fetch .gitmodules from GitHub repository
                const gmResp = await fetch('https://raw.githubusercontent.com/ModelEarth/webroot/main/.gitmodules', { cache: 'no-store' });
                if (!gmResp.ok) {
                    prsContainer.innerHTML = `<div style="padding:12px; color:var(--text-secondary);">.gitmodules not available from GitHub repository. Live PR fetch requires access to the .gitmodules file.</div>`;
                    return;
                }
                const gitmodulesText = await gmResp.text();
                // Extract GitHub owner/repo pairs
                const urlRegex = /url = (.*)/g;
                const repos = [];
                let m;
                while ((m = urlRegex.exec(gitmodulesText)) !== null) {
                    const url = m[1].trim();
                    const gh = url.match(/github.com[:\\/](.+?)\/(.+?)(?:\.git)?$/);
                    if (gh) {
                        const owner = gh[1];
                        const repo = gh[2];
                        repos.push({ owner, repo });
                    }
                }

                // Also fetch .siterepos from the webroot repository and merge any
                // additional site repositories into the list (de-duplicated).
                try {
                    const siteResp = await fetch('https://raw.githubusercontent.com/ModelEarth/webroot/main/.siterepos', { cache: 'no-store' });
                    if (siteResp && siteResp.ok) {
                        const siteText = await siteResp.text();
                        const lines = siteText.split(/\r?\n/).map(l => l.trim()).filter(l => l && !l.startsWith('#'));
                        const existing = new Set(repos.map(r => `${r.owner}/${r.repo}`));
                        for (const line of lines) {
                            // Accept formats like 'owner/repo', full GitHub URLs, or git@github.com:owner/repo.git
                            let match = line.match(/github.com[:\\/](.+?)\/(.+?)(?:\.git)?$/);
                            let owner = null, repo = null;
                            if (match) {
                                owner = match[1];
                                repo = match[2];
                            } else if (/^[\w.-]+\/[\w.-]+$/.test(line)) {
                                const parts = line.split('/');
                                owner = parts[0];
                                repo = parts[1].replace(/\.git$/, '');
                            }
                            if (owner && repo) {
                                const key = `${owner}/${repo}`;
                                if (!existing.has(key)) {
                                    repos.push({ owner, repo });
                                    existing.add(key);
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.warn('.siterepos fetch failed', e);
                }

                // Ensure ModelEarth/webroot is included in the aggregated list
                try {
                    const finalSet = new Set(repos.map(r => `${r.owner}/${r.repo}`));
                    if (!finalSet.has('ModelEarth/webroot')) {
                        repos.push({ owner: 'ModelEarth', repo: 'webroot' });
                    }
                } catch (e) {
                    // non-fatal
                }


                if (repos.length === 0) {
                    prsContainer.innerHTML = '<div style="padding:12px; color:var(--text-secondary);">No GitHub submodules found in .gitmodules.</div>';
                    return;
                }

                prsContainer.innerHTML = '<div style="padding:12px; color:var(--text-secondary);">Fetching PRs for ' + repos.length + ' repositories...</div>';

                // Attempt proxy for each repo first (no global /api/github/ping). If proxy
                // returns OK or 403 (auth issue), use its response; otherwise fall back to
                // the public GitHub API. Include token when available for both paths.
                // Check localStorage first (shared with Projects Hub), then sessionStorage
                const sessionToken = (function(){
                    try {
                        return localStorage.getItem('github_token') || sessionStorage.getItem('github_token') || null;
                    } catch(e){ return null }
                })();

                const fetches = repos.map(r => (async () => {
                    const publicUrl = `https://api.github.com/repos/${encodeURIComponent(r.owner)}/${encodeURIComponent(r.repo)}/pulls?state=open&per_page=100`;
                    const acceptHeader = { Accept: 'application/vnd.github.v3+json' };
                    try {
                        const publicHeaders = Object.assign({}, acceptHeader);
                        if (sessionToken) publicHeaders.Authorization = `token ${sessionToken}`;
                        const pubRes = await fetch(publicUrl, { headers: publicHeaders });
                        return { res: pubRes, r, usedProxy: false };
                    } catch (err) {
                        return { err, r };
                    }
                })());

                const responses = await Promise.all(fetches);

                // Build a responsive grid of submodule cards using DOM nodes (safer than string concat)
                const cardsContainer = document.createElement('div');
                cardsContainer.className = 'submodule-cards';
                for (const entry of responses) {
                    const r = entry.r;
                    function displayRepo(owner, repo) {
                        if (!repo) return '';
                        // Show only the repository name with first letter capitalized
                        return repo.charAt(0).toUpperCase() + repo.slice(1);
                    }

                    const ghUrl = `https://github.com/${encodeURIComponent(r.owner)}/${encodeURIComponent(r.repo)}`;

                    const card = document.createElement('div');
                    card.className = 'submodule-card';

                    const header = document.createElement('div');
                    header.style.display = 'flex';
                    header.style.alignItems = 'center';
                    header.style.justifyContent = 'space-between';
                    header.style.gap = '8px';

                    const localUrl = `https://model.earth/${encodeURIComponent(r.repo)}`;
                    const localLink = document.createElement('a');
                    localLink.className = 'submodule-local-link';
                    localLink.href = localUrl;
                    localLink.target = '_blank';
                    localLink.rel = 'noopener noreferrer';
                    localLink.title = `Open model.earth/${r.repo}`;
                    localLink.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="display:block;"><path d="M14 3h7v7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M10 14L21 3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M21 21H3V3h7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" opacity="0"/></svg>`;

                    const h4 = document.createElement('h4');
                    h4.style.margin = '0';
                    h4.style.fontSize = '15px';
                    h4.textContent = displayRepo(r.owner, r.repo);

                    const ghLink = document.createElement('a');
                    ghLink.className = 'submodule-gh-link';
                    ghLink.href = ghUrl;
                    ghLink.target = '_blank';
                    ghLink.rel = 'noopener noreferrer';
                    ghLink.title = `Open ${r.owner}/${r.repo} on GitHub`;
                    ghLink.setAttribute('aria-label', `Open ${r.owner}/${r.repo} on GitHub`);
                    ghLink.style.marginLeft = '8px';
                    ghLink.style.verticalAlign = 'middle';
                    ghLink.innerHTML = `<svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor" xmlns="http://www.w3.org/2000/svg" style="display:block;"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.28.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg>`;

                    header.appendChild(localLink);
                    header.appendChild(h4);
                    header.appendChild(ghLink);
                    card.appendChild(header);

                    if (entry.err) {
                        const errDiv = document.createElement('div');
                        errDiv.style.color = 'var(--text-danger)';
                        errDiv.textContent = 'Network error: ' + String(entry.err);
                        card.appendChild(errDiv);
                        // append contributors row to cards (non-blocking)
                        try {
                            fetchAndRenderContributors(r.owner, r.repo, card, sessionToken);
                        } catch (e) { console.warn('contributors: failed to init fetch', e); }

                        cardsContainer.appendChild(card);
                        continue;
                    }

                    const res = entry.res;
                    if (!res.ok) {
                        const msg = document.createElement('div');
                        if (res.status === 403) {
                            msg.style.color = 'var(--text-danger)';
                            msg.innerHTML = entry.usedProxy ? `Proxy returned HTTP 403 for ${escapeHtml(displayRepo(r.owner, r.repo))}. Check the proxy's GitHub token permissions.` : `GitHub API rate limit or access denied (HTTP 403). To avoid this, run a small authenticated proxy on your server that forwards requests to the GitHub API using a token. Example proxy path used by this page: <code>/api/github/repos/${escapeHtml(r.owner)}/${escapeHtml(r.repo)}/pulls?state=open</code>.`;
                        } else if (res.status === 404) {
                            msg.style.color = 'var(--text-secondary)';
                            msg.textContent = 'Repository not found (404).';
                        } else {
                            msg.style.color = 'var(--text-danger)';
                            msg.textContent = `Error fetching PRs (HTTP ${res.status}).`;
                        }
                        card.appendChild(msg);
                        cardsContainer.appendChild(card);
                        continue;
                    }

                    const prs = await res.json();
                    if (!Array.isArray(prs) || prs.length === 0) {
                        const bodyEmpty = document.createElement('div');
                        bodyEmpty.className = 'card-body';
                        bodyEmpty.style.color = 'var(--text-secondary)';
                        bodyEmpty.textContent = '';
                        card.appendChild(bodyEmpty);

                        // mark card as having zero PRs for filtering
                        try { card.dataset.prCount = '0'; card.dataset.hasPrs = 'false'; } catch(e){}

                        // Try to fetch repo metadata and commit count to show extra info
                        try {
                            const owner = r.owner;
                            const repo = r.repo;
                            const acceptHeader = { Accept: 'application/vnd.github.v3+json' };
                            const repoUrl = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}`;
                            const commitsUrl = `${repoUrl}/commits?per_page=1`;
                            const headers = Object.assign({}, acceptHeader);
                            if (sessionToken) headers.Authorization = `token ${sessionToken}`;

                            // Fetch repo info
                            let repoRes = null;
                            try {
                                repoRes = await fetch(repoUrl, { headers });
                            } catch(e) { repoRes = null; }

                            // Fetch commits (1) to get latest commit and Link header for count (fallback)
                            let commitsRes = null;
                            try {
                                commitsRes = await fetch(commitsUrl, { headers });
                            } catch(e) { commitsRes = null; }

                            let commitsCount = null;
                            let updatedAt = null;

                            // If we prefetched repository summaries at page load, prefer those values
                            try {
                                const cacheKey = `${owner}/${repo}`;
                                if (window._repoSummaries && window._repoSummaries[cacheKey]) {
                                    const pre = window._repoSummaries[cacheKey];
                                    if (pre && typeof pre === 'object') {
                                        if (pre.commitsCount != null) commitsCount = pre.commitsCount;
                                        if (pre.updatedAt) updatedAt = pre.updatedAt;
                                    }
                                }
                            } catch (e) { /* non-fatal */ }

                            // If we have a session token, prefer GraphQL for an accurate commit total on default branch
                            // but skip GraphQL if the prefetched cache already provided a commitsCount
                            if (sessionToken && commitsCount == null) {
                                try {
                                    const gqlQuery = `query { repository(owner: \"${owner}\", name: \"${repo}\") { defaultBranchRef { target { ... on Commit { history { totalCount } } } } pushedAt updatedAt } }`;
                                    const gqlRes = await fetch('https://api.github.com/graphql', {
                                        method: 'POST',
                                        headers: Object.assign({}, { 'Content-Type': 'application/json', Authorization: `bearer ${sessionToken}` }),
                                        body: JSON.stringify({ query: gqlQuery })
                                    });
                                    if (gqlRes && gqlRes.ok) {
                                        const gqlJson = await gqlRes.json();
                                        const repoNode = gqlJson && gqlJson.data && gqlJson.data.repository;
                                        if (repoNode) {
                                            const hist = repoNode.defaultBranchRef && repoNode.defaultBranchRef.target && repoNode.defaultBranchRef.target.history;
                                            if (hist && typeof hist.totalCount === 'number') commitsCount = hist.totalCount;
                                            updatedAt = repoNode.pushedAt || repoNode.updatedAt || null;
                                        }
                                    }
                                } catch(e) {
                                    // GraphQL failed - we'll fall back to Link header parsing
                                }
                            }

                            // Fallback: try Link header parsing from commitsRes
                            if (commitsCount == null && commitsRes) {
                                try {
                                    const link = commitsRes.headers.get('Link');
                                    if (link) {
                                        const m = link.match(/&?page=(\d+)[^>]*>; rel="last"/);
                                        if (m && m[1]) commitsCount = parseInt(m[1], 10);
                                    }
                                } catch(e){}
                                if (commitsCount == null) {
                                    try {
                                        const commitsJson = await commitsRes.json();
                                        if (Array.isArray(commitsJson)) commitsCount = commitsJson.length;
                                    } catch(e){}
                                }
                            }

                            if (!updatedAt && repoRes && repoRes.ok) {
                                try {
                                    const repoJson = await repoRes.json();
                                    updatedAt = repoJson.pushed_at || repoJson.updated_at || null;
                                } catch(e){}
                            }

                            // Format and show the info
                            const infoParts = [];
                            if (commitsCount != null) infoParts.push(`<strong>Commits ${commitsCount}</strong>`);
                            if (updatedAt) infoParts.push(`${timeAgo(updatedAt)} updated`);
                            if (infoParts.length > 0) {
                                const infoDiv = document.createElement('div');
                                infoDiv.style.marginTop = '8px';
                                infoDiv.style.color = 'var(--text-secondary)';
                                infoDiv.style.fontSize = '13px';
                                infoDiv.innerHTML = infoParts.join(' ');
                                bodyEmpty.appendChild(infoDiv);
                            }
                        } catch(e) {
                            // non-fatal; keep the empty card for repos without PRs
                        }

                        // append contributors row to cards (non-blocking)
                        try {
                            fetchAndRenderContributors(r.owner, r.repo, card, sessionToken);
                        } catch (e) { console.warn('contributors: failed to init fetch', e); }

                        cardsContainer.appendChild(card);
                        continue;
                    }

                    const cardBody = document.createElement('div');
                    cardBody.className = 'card-body';
                    
                    // Create header container for Updates title and count badge
                    const headerContainer = document.createElement('div');
                    headerContainer.style.display = 'flex';
                    headerContainer.style.alignItems = 'center';
                    headerContainer.style.gap = '8px';
                    headerContainer.style.marginBottom = '12px';
                    headerContainer.style.paddingBottom = '8px';
                    headerContainer.style.borderBottom = '2px solid rgba(59, 130, 246, 0.2)';
                    headerContainer.style.cursor = 'pointer';
                    headerContainer.style.borderRadius = '6px';
                    headerContainer.style.padding = '4px 6px';
                    headerContainer.style.margin = '-4px -6px 8px -6px';
                    headerContainer.style.transition = 'all 0.2s ease';
                    
                    // Add hover effects
                    headerContainer.addEventListener('mouseenter', function() {
                        this.style.backgroundColor = 'rgba(59, 130, 246, 0.08)';
                        this.style.transform = 'translateX(2px)';
                    });
                    
                    headerContainer.addEventListener('mouseleave', function() {
                        this.style.backgroundColor = 'transparent';
                        this.style.transform = 'translateX(0)';
                    });
                    
                    // Add click functionality to open an in-page PR diff modal
                    headerContainer.addEventListener('click', function(e) {
                        // Prevent any default navigation or event bubbling that might
                        // cause the browser to open links. We want an in-page modal.
                        try { e.preventDefault(); } catch (err) {}
                        try { e.stopPropagation(); } catch (err) {}
                        // Call async helper; don't fall back to navigation here.
                        try {
                            showPrDiffs(r.owner, r.repo, prs);
                        } catch (e) {
                            console.warn('showPrDiffs threw synchronously', e);
                        }
                    });

                    headerContainer.title = `Click to view pull request diffs for ${r.owner}/${r.repo}`;
                    
                    const strong = document.createElement('strong');
                    strong.textContent = 'Updates';
                    strong.style.fontSize = '14px';
                    strong.style.fontWeight = '600';
                    strong.style.color = 'var(--text-primary)';
                    strong.style.border = 'none';
                    strong.style.marginBottom = '0';
                    strong.style.paddingBottom = '0';
                    
                    // Create green circle badge with PR count
                    const countBadge = document.createElement('span');
                    countBadge.textContent = prs.length;
                    countBadge.style.backgroundColor = '#10b981';
                    countBadge.style.color = 'white';
                    countBadge.style.borderRadius = '50%';
                    countBadge.style.width = '20px';
                    countBadge.style.height = '20px';
                    countBadge.style.display = 'flex';
                    countBadge.style.alignItems = 'center';
                    countBadge.style.justifyContent = 'center';
                    countBadge.style.fontSize = '11px';
                    countBadge.style.fontWeight = '600';
                    countBadge.style.boxShadow = '0 2px 4px rgba(16, 185, 129, 0.3)';
                    countBadge.title = `${prs.length} open PR${prs.length !== 1 ? 's' : ''}`;
                    
                    headerContainer.appendChild(strong);
                    headerContainer.appendChild(countBadge);
                    cardBody.appendChild(headerContainer);
                    const prListWrap = document.createElement('div');
                    prListWrap.style.marginTop = '6px';

                    prs.forEach(p => {
                        const created = new Date(p.created_at).toLocaleString();
                        const labels = (p.labels || []).map(l => l.name).join(', ');

                        const prTile = document.createElement('div');
                        prTile.className = 'pr-card';

                        const prHeader = document.createElement('div');
                        prHeader.className = 'pr-header';
                        prHeader.style.display = 'flex';
                        prHeader.style.justifyContent = 'space-between';
                        prHeader.style.gap = '12px';
                        prHeader.style.alignItems = 'flex-start';

                        const left = document.createElement('div');
                        left.style.flex = '1';
                        left.style.minWidth = '0';
                        const titleLink = document.createElement('a');
                        titleLink.className = 'pr-title';
                        // Do NOT set href/target to avoid navigation to GitHub.
                        // Keep the original URL in a data attribute for reference.
                        try { titleLink.dataset.htmlUrl = p.html_url; } catch (e) {}
                        titleLink.setAttribute('role', 'button');
                        titleLink.setAttribute('tabindex', '0');
                        titleLink.style.cursor = 'pointer';
                        titleLink.textContent = `#${p.number} — ${p.title}`;
                        // Clicking the title opens the modal for this single PR (no external navigation)
                        titleLink.addEventListener('click', function(ev) {
                            try { ev.preventDefault(); ev.stopPropagation(); } catch (e) {}
                            try { showPrDiffs(r.owner, r.repo, [p]); } catch (err) { console.warn('showPrDiffs failed for single PR', err); }
                        });
                        // support keyboard activation
                        titleLink.addEventListener('keydown', function(ev) {
                            if (ev.key === 'Enter' || ev.key === ' ') {
                                try { ev.preventDefault(); ev.stopPropagation(); } catch (e) {}
                                this.click();
                            }
                        });
                        titleLink.style.textDecoration = 'none';
                        titleLink.style.color = 'var(--text-primary)';
                        titleLink.style.display = 'block';
                        titleLink.style.padding = '6px 8px';
                        titleLink.style.margin = '-6px -8px';
                        titleLink.style.borderRadius = '6px';
                        titleLink.style.transition = 'all 0.2s ease';
                        titleLink.style.border = '1px solid transparent';
                        titleLink.addEventListener('mouseenter', function() {
                            this.style.backgroundColor = 'rgba(59, 130, 246, 0.1)';
                            this.style.borderColor = 'rgba(59, 130, 246, 0.2)';
                            this.style.color = '#3b82f6';
                            this.style.transform = 'translateY(-1px)';
                            this.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.1)';
                        });
                        titleLink.addEventListener('mouseleave', function() {
                            this.style.backgroundColor = 'transparent';
                            this.style.borderColor = 'transparent';
                            this.style.color = 'var(--text-primary)';
                            this.style.transform = 'translateY(0)';
                            this.style.boxShadow = 'none';
                        });
                        const metaDiv = document.createElement('div');
                        metaDiv.className = 'pr-meta';
                        metaDiv.textContent = `${p.user?.login || 'unknown'} · ${created}${labels ? ' · ' + labels : ''}`;
                        left.appendChild(titleLink);
                        left.appendChild(metaDiv);

                        prHeader.appendChild(left);
                        prTile.appendChild(prHeader);

                        prListWrap.appendChild(prTile);
                    });

                    cardBody.appendChild(prListWrap);
                    card.appendChild(cardBody);

                    // mark card with PR count for filtering
                    try { card.dataset.prCount = String(prs.length); card.dataset.hasPrs = prs.length > 0 ? 'true' : 'false'; } catch(e){}

                    // Try to fetch and render contributors for this repository (non-blocking)
                    // We call this just before appending the card so the contributors
                    // container becomes the bottom-most element and can be pinned there
                    // by CSS (using margin-top: auto).
                    // append contributors row to cards (non-blocking)
                    try {
                        fetchAndRenderContributors(r.owner, r.repo, card, sessionToken);
                    } catch (e) { console.warn('contributors: failed to init fetch', e); }

                    cardsContainer.appendChild(card);
                }
                // Replace container content with the constructed nodes
                prsContainer.innerHTML = '';
                prsContainer.appendChild(cardsContainer);
                // initialize filters view after rendering cards
                try { renderPrFilters(); } catch(e){}
            } catch (e) {
                prsContainer.innerHTML = `<div style="padding:12px; color:var(--text-danger);">Error loading PRs: ${escapeHtml(String(e))}</div>`;
            }
        }

        function showContributionsSection() {
            const panel = document.getElementById('contributionsPanel');
            if (!panel) return;
            // Only show if participantsData exists
            if (window.participantsData && window.participantsData.length > 0) {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        // Contributions summary is shown automatically when the panel is opened; manual refresh button removed.

        // Basic HTML escape helper
        function escapeHtml(unsafe) {
            if (unsafe == null) return '';
            return String(unsafe)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        // human-friendly time ago (accepts ISO string or Date)
        function timeAgo(iso) {
            if (!iso) return '';
            const t = typeof iso === 'string' ? new Date(iso) : new Date(iso);
            if (isNaN(t)) return '';
            const seconds = Math.floor((Date.now() - t.getTime()) / 1000);
            const intervals = [
                ['year', 31536000],
                ['month', 2592000],
                ['week', 604800],
                ['day', 86400],
                ['hour', 3600],
                ['minute', 60],
                ['second', 1]
            ];
            for (const [name, secs] of intervals) {
                const val = Math.floor(seconds / secs);
                if (val >= 1) return `${val} ${name}${val > 1 ? 's' : ''} ago`;
            }
            return 'just now';
        }

        // Fetch and render contributors into the provided card element.
        // Uses sessionToken (if provided) for authenticated requests to avoid rate limits.
        async function fetchAndRenderContributors(owner, repo, cardEl, sessionToken) {
            if (!owner || !repo || !cardEl) return;

            const container = document.createElement('div');
            container.className = 'contributors-row';

            const label = document.createElement('div');
            label.textContent = 'Contributors:';
            label.className = 'contributors-label';
            container.appendChild(label);

            const list = document.createElement('div');
            list.className = 'contributors-list';
            container.appendChild(list);

            // Append container to card (below existing content)
            try { cardEl.appendChild(container); } catch(e){}

            const apiUrl = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/contributors?per_page=10`;
            const headers = Object.assign({}, { Accept: 'application/vnd.github.v3+json' });
            if (sessionToken) headers.Authorization = `token ${sessionToken}`;

            try {
                const res = await fetch(apiUrl, { headers });
                if (!res.ok) {
                    // Do not show error UI; silently return
                    return;
                }
                const contributors = await res.json();
                if (!Array.isArray(contributors) || contributors.length === 0) return;

                // Optional debug: set sessionStorage.setItem('debug_contribs','1') to enable
                try {
                    if (sessionStorage.getItem && sessionStorage.getItem('debug_contribs') === '1') {
                        console.debug('[debug_contribs] fetched', owner + '/' + repo, 'contributors:', contributors.length);
                    }
                } catch (e) {}

                // Show top 5 contributors with an overflow indicator like GitHub
                const totalContribs = contributors.length;
                const topN = 5;
                contributors.slice(0, topN).forEach(c => {
                    const a = document.createElement('a');
                    const profileUrl = c.html_url || `https://github.com/${c.login}`;
                    a.href = profileUrl;
                    a.target = '_blank';
                    a.rel = 'noopener noreferrer';
                    a.className = 'contributor-link';
                    a.title = `${c.login} — ${c.contributions || ''} contributions`;

                    const avatar = document.createElement('img');
                    avatar.src = c.avatar_url;
                    avatar.alt = c.login;
                    avatar.className = 'contributor-avatar';

                    a.appendChild(avatar);
                    list.appendChild(a);
                });

                if (totalContribs > topN) {
                    const remaining = totalContribs - topN;
                    const moreLink = document.createElement('a');
                    moreLink.href = `https://github.com/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/graphs/contributors`;
                    moreLink.target = '_blank';
                    moreLink.rel = 'noopener noreferrer';
                    moreLink.title = `${remaining} more contributors`;

                    const more = document.createElement('div');
                    more.className = 'contrib-more';
                    more.textContent = `+${remaining}`;

                    moreLink.appendChild(more);
                    list.appendChild(moreLink);
                }
            } catch (e) {
                // ignore fetch errors
                console.warn('contributors: fetch error', owner, repo, e);
            }
        }

        // PR filters for submodule cards
        function applyPrFilter(filter) {
            const buttons = document.querySelectorAll('#prsFilters .btn');
            buttons.forEach(b => b.classList.remove('active'));
            const activeBtn = document.querySelector(`#prsFilters .btn[data-pr-filter="${filter}"]`);
            if (activeBtn) activeBtn.classList.add('active');

            const cards = document.querySelectorAll('.submodule-card');
            cards.forEach(card => {
                const hasPrs = (card.dataset.hasPrs === 'true');
                if (filter === 'all') {
                    card.style.display = '';
                } else if (filter === 'with') {
                    card.style.display = hasPrs ? '' : 'none';
                } else if (filter === 'without') {
                    card.style.display = hasPrs ? 'none' : '';
                }
            });
        }

        // Show PR diffs in a modal for a given repo. Accepts the already-fetched PR list to avoid refetch.
        async function showPrDiffs(owner, repo, prs) {
                    // Debugging gate: set sessionStorage.setItem('debug_pr_modal','1') to enable logs
                    try {
                        if (sessionStorage && sessionStorage.getItem && sessionStorage.getItem('debug_pr_modal') === '1') {
                            console.debug('showPrDiffs invoked for', owner, repo, 'prsCount=', Array.isArray(prs) ? prs.length : 'not-provided');
                        }
                    } catch (e) {}

                    const overlay = document.getElementById('prDiffModalOverlay');
            const content = document.getElementById('prDiffModalContent');
            if (!overlay || !content) return;
            content.innerHTML = '<div style="text-align:center; padding:20px">Loading pull request diffs...</div>';
            overlay.style.display = 'flex';

            // Check localStorage first (shared with Projects Hub), then sessionStorage
            const token = (function(){
                try {
                    return localStorage.getItem('github_token') || sessionStorage.getItem('github_token') || null;
                } catch(e){ return null }
            })();
            const headers = { Accept: 'application/vnd.github.v3+json' };
            if (token) headers.Authorization = `token ${token}`;

            try {
                // Ensure we have PRs; if not provided, fetch list
                let prList = prs;
                if (!Array.isArray(prList)) {
                    const pullsUrl = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/pulls?state=open&per_page=50`;
                    const prRes = await fetch(pullsUrl, { headers });
                    if (!prRes.ok) throw new Error('Unable to fetch PRs');
                    prList = await prRes.json();
                }

                if (!Array.isArray(prList) || prList.length === 0) {
                    content.innerHTML = '<div style="padding:12px; color:var(--text-secondary);">No open PRs found for this repository.</div>';
                    return;
                }

                // For each PR, fetch the files endpoint to get patch (diff)
                const diffs = [];
                for (const pr of prList.slice(0, 10)) { // limit to first 10 to avoid overload
                    try {
                        const filesUrl = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/pulls/${pr.number}/files`;
                        const fRes = await fetch(filesUrl, { headers });
                        if (!fRes.ok) {
                            diffs.push({ pr, files: null, error: `HTTP ${fRes.status}` });
                            continue;
                        }
                        const files = await fRes.json();
                        diffs.push({ pr, files });
                    } catch (e) {
                        diffs.push({ pr, files: null, error: String(e) });
                    }
                }

                // Render diffs
                const parts = [];
                // If we have at least one PR, link to that PR's details page. Otherwise link to the repo pulls list.
                const firstPrUrl = (Array.isArray(prList) && prList.length > 0 && prList[0] && prList[0].html_url) ? prList[0].html_url : `https://github.com/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/pulls`;
                parts.push(`<div class="pr-diff-header"><div style="display:flex; justify-content:space-between; align-items:center; gap:8px;"><div style=\"display:flex; align-items:center; gap:12px;\"><div style=\"display:flex; flex-direction:column; gap:4px;\"><div style=\"display:flex; align-items:center; gap:8px;\"><h3 style=\"margin:0\">${owner}/${repo} — Pull Request Diffs</h3><a href=\"${firstPrUrl}\" target=\"_blank\" rel=\"noopener noreferrer\" style=\"font-size:13px; color:var(--text-primary); text-decoration:underline;\">View on GitHub</a></div></div></div><div style=\"display:flex; gap:8px; align-items:center;\"><button id=\"prDiffModalClose\" class=\"pr-diff-close\">✕</button></div></div></div>`);
                // start scrollable body (files/diffs will go inside this)
                parts.push('<div class="pr-diff-body" style="max-height:calc(80vh - 120px); overflow:auto; padding-right:8px;">');
                diffs.forEach(d => {
                    // Build title with PR author avatar + username (show only PR author)
                    const authorLogin = d.pr.user?.login || 'unknown';
                    const authorAvatar = d.pr.user?.avatar_url || '';
                    const authorUrl = d.pr.user?.html_url || (`https://github.com/${authorLogin}`);
                    const titleText = `#${d.pr.number} — ${d.pr.title}`;
                    const title = escapeHtml(titleText);
                    if (d.error) {
                        parts.push(`<div class="pr-diff-item"><div class="pr-diff-summary"><div>${title}</div><div style="color:var(--text-danger)">Error: ${escapeHtml(d.error)}</div></div></div>`);
                        return;
                    }
                    // Insert author block next to the title
                    const authorHtml = `<a class="pr-author" href="${escapeHtml(authorUrl)}" target="_blank" rel="noopener noreferrer" style="display:inline-flex; align-items:center; gap:8px; text-decoration:none; color:inherit;"><img src="${escapeHtml(authorAvatar)}" alt="${escapeHtml(authorLogin)}" style="width:22px; height:22px; border-radius:4px; object-fit:cover;"> <span style="font-size:13px; color:var(--text-primary);">@${escapeHtml(authorLogin)}</span></a>`;
                    parts.push(`<div class="pr-diff-item"><div class="pr-diff-summary"><div style="display:flex; align-items:center; justify-content:space-between; gap:8px;"><div>${title}</div><div>${authorHtml}</div></div><div style="color:var(--text-secondary); font-size:12px">Files: ${d.files.length}</div></div>`);
                    // Render each file. For files with status 'added' show a file-structure list instead of a diff.
                    const addedFiles = (d.files || []).filter(f => f && f.status === 'added');
                    if (addedFiles.length > 0) {
                        // Render a New files added block
                        const treeParts = ['<div class="pr-new-files"><strong>New files added</strong><div class="new-files-tree"><ul>'];
                        addedFiles.forEach(af => {
                            const pathEsc = escapeHtml(af.filename || '');
                            const link = af.blob_url ? af.blob_url : (af.raw_url ? af.raw_url : '');
                            if (link) {
                                treeParts.push(`<li><a href="${escapeHtml(link)}" target="_blank" rel="noopener noreferrer">${pathEsc}</a></li>`);
                            } else {
                                treeParts.push(`<li>${pathEsc}</li>`);
                            }
                        });
                        treeParts.push('</ul></div></div>');
                        parts.push(treeParts.join('\n'));
                    }

                    (d.files || []).forEach(f => {
                        if (f && f.status === 'added') {
                            // already rendered in the New files block
                            return;
                        }
                        const filename = escapeHtml(f.filename || '(unknown)');
                        const fileLink = f.blob_url ? f.blob_url : (f.raw_url ? f.raw_url : '');
                        // each will be array of { type: 'added'|'removed'|'context'|'empty', text: '...' }
                        let leftLines = [];
                        let rightLines = [];
                        if (f.patch) {
                            // Split patch into lines and separate added/removed/context
                            const lines = f.patch.split(/\r?\n/);
                            lines.forEach(ln => {
                                if (ln.startsWith('+++') || ln.startsWith('---') || ln.startsWith('@@')) {
                                    // ignore file headers and hunk headers in the pane content
                                    return;
                                }
                                if (ln.startsWith('+')) {
                                    rightLines.push({ type: 'added', text: escapeHtml(ln.substring(1)) });
                                    // keep alignment: empty placeholder on left
                                    leftLines.push({ type: 'empty', text: '' });
                                } else if (ln.startsWith('-')) {
                                    leftLines.push({ type: 'removed', text: escapeHtml(ln.substring(1)) });
                                    rightLines.push({ type: 'empty', text: '' });
                                } else {
                                    // context line
                                    const ctx = escapeHtml(ln.startsWith(' ') ? ln.substring(1) : ln);
                                    leftLines.push({ type: 'context', text: ctx });
                                    rightLines.push({ type: 'context', text: ctx });
                                }
                            });
                        } else {
                            leftLines = ['(no patch available)'];
                            rightLines = ['(no patch available)'];
                        }

                        // Build HTML for this file — render a GitHub-style side-by-side diff table with line numbers.
                        let fileHtml = '<div class="pr-diff-file"><div class="pr-diff-filename"><div>' + filename + '</div>' + (fileLink ? ('<div><a href="' + escapeHtml(fileLink) + '" target="_blank" rel="noopener noreferrer">Open on GitHub</a></div>') : '') + '</div>';

                        if (f.patch) {
                            const patchLines = f.patch.split(/\r?\n/);
                            const rows = [];
                            let leftNum = 0;
                            let rightNum = 0;
                            const hunkRe = /^@@ -([0-9]+)(?:,([0-9]+))? \+([0-9]+)(?:,([0-9]+))? @@/;
                            for (let i = 0; i < patchLines.length; i++) {
                                const ln = patchLines[i];
                                const m = ln.match(hunkRe);
                                if (m) {
                                    leftNum = parseInt(m[1], 10);
                                    rightNum = parseInt(m[3], 10);
                                    continue;
                                }
                                if (ln.startsWith('+')) {
                                    rows.push({ type: 'added', leftNum: '', leftText: '', rightNum: rightNum, rightText: escapeHtml(ln.substring(1)) });
                                    rightNum++;
                                } else if (ln.startsWith('-')) {
                                    rows.push({ type: 'removed', leftNum: leftNum, leftText: escapeHtml(ln.substring(1)), rightNum: '', rightText: '' });
                                    leftNum++;
                                } else {
                                    const text = escapeHtml(ln.startsWith(' ') ? ln.substring(1) : ln);
                                    rows.push({ type: 'context', leftNum: leftNum, leftText: text, rightNum: rightNum, rightText: text });
                                    leftNum++; rightNum++;
                                }
                            }

                            fileHtml += '<div class="sb-diff-wrap"><table class="sb-diff"><tbody>';
                            // Coalesce sequences of removed/added lines into 'replaced' rows when adjacent
                            const paired = [];
                            for (let i = 0; i < rows.length; i++) {
                                const cur = rows[i];
                                if (cur.type === 'removed') {
                                    // collect contiguous removed run
                                    const removedRun = [cur];
                                    let j = i + 1;
                                    while (j < rows.length && rows[j].type === 'removed') { removedRun.push(rows[j]); j++; }
                                    // collect following contiguous added run
                                    const addedRun = [];
                                    while (j < rows.length && rows[j].type === 'added') { addedRun.push(rows[j]); j++; }

                                    const pairCount = Math.min(removedRun.length, addedRun.length);
                                    // pair one-to-one for replacements
                                    for (let k = 0; k < pairCount; k++) {
                                        paired.push({ type: 'replaced', leftNum: removedRun[k].leftNum, leftText: removedRun[k].leftText, rightNum: addedRun[k].rightNum, rightText: addedRun[k].rightText });
                                    }
                                    // leftover removed lines
                                    for (let k = pairCount; k < removedRun.length; k++) {
                                        paired.push(removedRun[k]);
                                    }
                                    // leftover added lines
                                    for (let k = pairCount; k < addedRun.length; k++) {
                                        paired.push(addedRun[k]);
                                    }
                                    i = j - 1; // advance
                                } else {
                                    paired.push(cur);
                                }
                            }

                            paired.forEach(r => {
                                const rowClass = r.type === 'replaced' ? 'replaced' : r.type;
                                fileHtml += '<tr class="sb-row sb-' + rowClass + '">';
                                fileHtml += '<td class="sb-line-num">' + (r.leftNum || '') + '</td>';
                                fileHtml += '<td class="sb-code sb-left"><pre class="sb-pre">' + (r.leftText || '') + '</pre></td>';
                                fileHtml += '<td class="sb-line-num">' + (r.rightNum || '') + '</td>';
                                fileHtml += '<td class="sb-code sb-right"><pre class="sb-pre">' + (r.rightText || '') + '</pre></td>';
                                fileHtml += '</tr>';
                            });
                            fileHtml += '</tbody></table></div>';
                        } else {
                            fileHtml += '<div class="diff-container"><div class="diff-column diff-left"><pre class="pr-diff-pre">(no patch available)</pre></div><div class="diff-column diff-right"><pre class="pr-diff-pre">(no patch available)</pre></div></div>';
                        }

                        fileHtml += '</div>';
                        parts.push(fileHtml);
                    });
                    parts.push('</div>');
                });

                content.innerHTML = parts.join('');

                // modal contributors removed; showing only PR author per PR above

                // Attach close handler
                const closeBtn = document.getElementById('prDiffModalClose');
                if (closeBtn) closeBtn.addEventListener('click', () => { overlay.style.display = 'none'; content.innerHTML = ''; });

                // Side-by-side table handles alignment; no synchronized scroll required.

                // per-file preview handlers removed

                // Page-level preview removed per user request
            } catch (e) {
                content.innerHTML = `<div style="padding:12px; color:var(--text-danger);">Error loading diffs: ${escapeHtml(String(e))}</div>`;
            }
        }

        function renderPrFilters() {
            // default to 'all' if nothing selected
            const currentActive = document.querySelector('#prsFilters .btn.active');
            if (!currentActive) {
                applyPrFilter('all');
            }
        }

        // GitHub token helpers (sessionStorage only)
        function saveGithubToken() {
            const input = document.getElementById('githubTokenInput');
            const status = document.getElementById('githubTokenStatus');
            if (!input) return;
            const token = input.value.trim();
            try {
                if (!token) {
                    // clear session store
                    try { sessionStorage.removeItem('github_token'); } catch(e){}
                    if (status) status.textContent = 'No token saved.';
                    try { loadSubmodulePRs(); } catch (e) { /* ignore */ }
                    try { restoreGithubTokenStatus(); } catch (e) {}
                    return;
                }
                // Always store only in sessionStorage for privacy
                sessionStorage.setItem('github_token', token);
                if (status) status.textContent = 'Token saved for this session.';
                input.value = '';
                try { loadSubmodulePRs(); } catch (e) { /* ignore */ }
                try { restoreGithubTokenStatus(); } catch (e) {}
            } catch (e) {
                if (status) status.textContent = 'Unable to save token.';
            }
        }

        function clearGithubToken() {
            const status = document.getElementById('githubTokenStatus');
            try {
                try { sessionStorage.removeItem('github_token'); } catch(e){}
                if (status) status.textContent = 'Token cleared.';
                try { loadSubmodulePRs(); } catch (e) { /* ignore */ }
                try { restoreGithubTokenStatus(); } catch (e) {}
            } catch (e) {
                if (status) status.textContent = 'Unable to clear token.';
            }
        }

        // Restore status text on panel open and toggle token UI/prompt
        function restoreGithubTokenStatus(){
            try {
                const status = document.getElementById('githubTokenStatus');
                const tokenControls = document.getElementById('githubTokenControls');
                const tokenPrompt = document.getElementById('githubTokenPrompt');
                let token = null;
                // Check localStorage first (shared with Projects Hub), then sessionStorage
                try { token = localStorage.getItem('github_token') || sessionStorage.getItem('github_token'); } catch(e){}
                if (status) {
                    const tokenSource = localStorage.getItem('github_token') ? '(shared with Projects Hub)' : '(session only)';
                    status.textContent = token ? `Token present ${tokenSource}` : 'No token saved.';
                }
                if (tokenControls) {
                    tokenControls.style.display = token ? 'none' : '';
                }
                if (tokenPrompt) {
                    tokenPrompt.style.display = token ? 'none' : '';
                }
            } catch(e){}
        }
    // initialize token UI on script load
    try { restoreGithubTokenStatus(); } catch(e){}
        // Prefetch minimal repo summaries (commits count and updated time) to avoid
        // making per-repo API calls when the Contributions panel is opened.
        // This will try a site-local proxy first (/api/github/html/...), then
        // fall back to fetching the public GitHub repository page HTML.
        window._repoSummaries = window._repoSummaries || {};

        async function fetchRepoPageSummary(owner, repo) {
            const key = `${owner}/${repo}`;
            // If already fetched, return it
            if (window._repoSummaries && window._repoSummaries[key]) return window._repoSummaries[key];
            const proxyUrl = `/api/github/html/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}`;
            const publicUrl = `https://github.com/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}`;
            const tryFetch = async (url, useProxy) => {
                try {
                    const headers = {};
                    // Check localStorage first (shared with Projects Hub), then sessionStorage
                    const token = (function(){
                        try {
                            return localStorage.getItem('github_token') || sessionStorage.getItem('github_token') || null;
                        } catch(e){ return null }
                    })();
                    if (token && useProxy) headers.Authorization = `token ${token}`;
                    const resp = await fetch(url, { headers, cache: 'no-store' });
                    if (!resp || !resp.ok) return null;
                    const text = await resp.text();
                    return text;
                } catch (e) { return null; }
            };

            // Try proxy first
            let html = await tryFetch(htmlProxyUrl, true);
            if (!html) html = await tryFetch(publicUrl, false);

            const result = { commitsCount: null, updatedAt: null };
            if (!html) {
                window._repoSummaries[key] = result;
                return result;
            }

            try {
                // Parse simple patterns from GitHub repo page
                // Look for 'data-component="buttonContent"' sections which include commit counts
                const commitMatch = html.match(/data-component="buttonContent"[\s\S]*?([0-9,]+) commit/mi) || html.match(/([0-9,]+) commit[s]?/i);
                if (commitMatch && commitMatch[1]) {
                    const n = parseInt(commitMatch[1].replace(/,/g, ''), 10);
                    if (!isNaN(n)) result.commitsCount = n;
                }

                // Relative time: look for <relative-time datetime="..."> or <relative-time class="..." datetime="...">
                const timeMatch = html.match(/<relative-time[^>]*datetime="([^"]+)"/i) || html.match(/datetime="([0-9T:\-\.Z]+)"[^>]*>\s*<\/relative-time>/i);
                if (timeMatch && timeMatch[1]) {
                    result.updatedAt = timeMatch[1];
                } else {
                    // Alternative: look for data-pushed or data-updated attributes or 'pushed' text
                    const pushedMatch = html.match(/"pushed_at"\s*:\s*"([^"]+)"/i) || html.match(/pushed\s*at\s*<.*?datetime="([^"]+)"/i);
                    if (pushedMatch && pushedMatch[1]) result.updatedAt = pushedMatch[1];
                }
            } catch (e) {
                // ignore parse errors
            }

            window._repoSummaries[key] = result;
            return result;
        }

        async function prefetchRepoSummaries() {
            try {
                const gmResp = await fetch('https://raw.githubusercontent.com/ModelEarth/webroot/main/.gitmodules', { cache: 'no-store' });
                if (!gmResp.ok) return;
                const gitmodulesText = await gmResp.text();
                const urlRegex = /url = (.*)/g;
                let m;
                const repos = [];
                while ((m = urlRegex.exec(gitmodulesText)) !== null) {
                    const url = m[1].trim();
                    const gh = url.match(/github.com[:\\/](.+?)\/(.+?)(?:\.git)?$/);
                    if (gh) repos.push({ owner: gh[1], repo: gh[2] });
                }
                // Limit prefetch to avoid too many requests: max 20 repos
                const toFetch = repos.slice(0, 20);
                await Promise.all(toFetch.map(r => fetchRepoPageSummary(r.owner, r.repo)));
            } catch (e) {
                // non-fatal
            }
        }

        // Start prefetch asynchronously but don't await (non-blocking)
        try { prefetchRepoSummaries(); } catch(e){}
        function showAIInsightsButtons() {
            const cacheKey = getCurrentDataSource();
            const hasGeminiCache = aiInsightsCache[cacheKey];
            const hasClaudeCache = claudeInsightsCache[cacheKey];
            
            // Update button states
            const claudeBtn = document.getElementById('claudeInsightsBtn');
            const claudeText = document.getElementById('claudeInsightsText');
            const claudeRefresh = document.getElementById('claudeRefreshBtn');
            const geminiBtn = document.getElementById('geminiInsightsBtn');
            const geminiText = document.getElementById('geminiInsightsText');
            const geminiRefresh = document.getElementById('geminiRefreshBtn');
            
            if (claudeBtn && claudeText && claudeRefresh) {
                claudeBtn.disabled = false;
                claudeText.textContent = hasClaudeCache ? 'Claude Insights (Cached)' : 'Claude Insights';
                claudeRefresh.style.display = hasClaudeCache ? 'flex' : 'none';
                // Don't auto-highlight - highlighting only shows the currently displayed insights
            }
            
            if (geminiBtn && geminiText && geminiRefresh) {
                geminiBtn.disabled = false;
                geminiText.textContent = hasGeminiCache ? 'Gemini Insights (Cached)' : 'Gemini Insights';
                geminiRefresh.style.display = hasGeminiCache ? 'flex' : 'none';
                // Don't auto-highlight - highlighting only shows the currently displayed insights
            }
            
            // If aiInsights panel is visible and there are cached insights, show one that corresponds to highlighted button
            const aiInsights = document.getElementById('aiInsights');
            if (aiInsights && window.getComputedStyle(aiInsights).display === 'block') {
                // Check which button is currently highlighted (has cached-insights class)
                const claudeHighlighted = claudeBtn && claudeBtn.classList.contains('cached-insights');
                const geminiHighlighted = geminiBtn && geminiBtn.classList.contains('cached-insights');
                
                if (claudeHighlighted && hasClaudeCache) {
                    // Claude is highlighted and has cache - display it
                    displayCachedInsights(cacheKey, 'claude');
                } else if (geminiHighlighted && hasGeminiCache) {
                    // Gemini is highlighted and has cache - display it
                    displayCachedInsights(cacheKey, 'gemini');
                } else if (hasClaudeCache && !geminiHighlighted) {
                    // No specific highlight but Claude has cache - display Claude as default
                    displayCachedInsights(cacheKey, 'claude');
                } else if (hasGeminiCache && !claudeHighlighted) {
                    // No specific highlight but Gemini has cache - display Gemini as default
                    displayCachedInsights(cacheKey, 'gemini');
                }
            }
            // Intentionally do not auto-open contributions panel; user must click to view it
        }
        
        function getCurrentDataSource() {
            const selectedOption = fileSelect.options[fileSelect.selectedIndex];
            if (selectedOption && selectedOption.getAttribute('data-url')) {
                return selectedOption.getAttribute('data-url');
            }
            return selectedFile || 'unknown';
        }
        
        function handleClaudeInsightsClick() {
            if (!window.participantsData || window.participantsData.length === 0) {
                appendStatusMessage('No data available for analysis. Please load a list first.', 'error');
                return;
            }
            
            const cacheKey = getCurrentDataSource();
            if (claudeInsightsCache[cacheKey]) {
                displayCachedInsights(cacheKey, 'claude');
            } else {
                showRefreshPrompt('claude');
            }
        }
        
        function handleGeminiInsightsClick() {
            if (!window.participantsData || window.participantsData.length === 0) {
                appendStatusMessage('No data available for analysis. Please load a list first.', 'error');
                return;
            }
            
            const cacheKey = getCurrentDataSource();
            if (aiInsightsCache[cacheKey]) {
                displayCachedInsights(cacheKey, 'gemini');
            } else {
                showRefreshPrompt('gemini');
            }
        }
        
        async function displayCachedInsights(cacheKey, aiType) {
            const cache = aiType === 'claude' ? claudeInsightsCache : aiInsightsCache;
            const insights = cache[cacheKey];
            
            if (insights) {
                // Clear any existing highlighting first
                const claudeBtn = document.getElementById('claudeInsightsBtn');
                const geminiBtn = document.getElementById('geminiInsightsBtn');
                if (claudeBtn) claudeBtn.classList.remove('cached-insights');
                if (geminiBtn) geminiBtn.classList.remove('cached-insights');
                
                // Highlight only the button for the currently displayed insights
                const button = document.getElementById(aiType === 'claude' ? 'claudeInsightsBtn' : 'geminiInsightsBtn');
                if (button) {
                    button.classList.add('cached-insights');
                }
                
                // Use shared display functions
                if (aiType === 'claude') {
                    await displaySharedClaudeInsights(
                        insights.analysis, 
                        insights.totalRecords || 0, 
                        insights.sampleSize || 0, 
                        false, 
                        insights.customPrompt || insights.prompt || 'Standard data analysis prompt'
                    );
                } else {
                    await displaySharedGeminiInsights(
                        insights.analysis, 
                        insights.totalRecords || 0, 
                        insights.sampleSize || 0, 
                        false, 
                        insights.customPrompt || insights.prompt || 'Standard data analysis prompt'
                    );
                }
                
                // Update button states
                currentActiveAI = aiType;
                updateActiveAIButtons();
            }
        }
        
        function showRefreshPrompt(aiType) {
            currentPromptAI = aiType;
            const modal = document.getElementById('promptModal');
            const title = document.getElementById('promptModalTitle');
            
            title.textContent = `${aiType === 'claude' ? 'Claude' : 'Gemini'} Analysis`;
            modal.classList.remove('hidden');
        }
        
        function closePromptModal() {
            const modal = document.getElementById('promptModal');
            modal.classList.add('hidden');
            currentPromptAI = null;
        }
        
        // Function to get currently filtered and sorted data for AI analysis
        function getCurrentlyDisplayedData() {
            // Start with the sorted data (allRowsData has sort order applied)
            if (!allRowsData || allRowsData.length === 0) {
                console.warn('⚠️ getCurrentlyDisplayedData called but allRowsData is empty');
                return [];
            }
            
            let filteredData = [...allRowsData];
            
            // Apply status filter (same logic as in applyAllFilters)
            if (!selectedStatuses.has('All') && selectedStatuses.size > 0) {
                filteredData = filteredData.filter(participant => {
                    const status = participant.Status || 'Unknown';
                    return selectedStatuses.has(status);
                });
            }
            
            // Apply team filter if active
            if (currentTeamFilter) {
                filteredData = filteredData.filter(participant => {
                    const participantTeamClasses = getAllTeamClasses(participant.Team);
                    return participantTeamClasses.includes(currentTeamFilter);
                });
            }
            
            // Apply group participants filter if active
            if (showOnlyGroup) {
                filteredData = filteredData.filter(participant => {
                    const name = getParticipantName(participant);
                    return Array.from(groupParticipants).some(groupName => 
                        groupName.toLowerCase() === name.toLowerCase()
                    );
                });
            }
            
            return filteredData;
        }

        async function submitPrompt() {
            const prompt = document.getElementById('promptInput').value;
            const aiType = currentPromptAI;
            
            if (!prompt || !aiType || !window.participantsData) return;
            
            closePromptModal();
            
            // Show loading state
            const content = document.getElementById('insightsContent');
            content.innerHTML = '<div style="padding: 20px; text-align: center;">🔄 Generating insights...</div>';
            
            try {
                // Get currently filtered and sorted data instead of raw data
                const currentlyDisplayedData = getCurrentlyDisplayedData();
                const maxRows = parseInt(document.getElementById('maxRowsInput')?.value || 20);
                const analysisData = currentlyDisplayedData.slice(0, maxRows);
                
                // Get all available headers from the original data to include complete row information
                const allHeaders = window.participantsData.length > 0 ? Object.keys(window.participantsData[0]) : [];
                
                console.log(`📊 AI Analysis Data Summary:
- Original dataset: ${window.participantsData.length} records
- After filters: ${currentlyDisplayedData.length} records  
- Sent for analysis: ${analysisData.length} records
- All available columns: ${allHeaders.length} (${allHeaders.join(', ')})
- Current sort: ${currentSortColumn || 'none'} ${currentSortOrder || ''}`);
                
                // Ensure analysis data includes all columns, not just visible ones
                const completeAnalysisData = analysisData.map(row => {
                    const completeRow = {};
                    allHeaders.forEach(header => {
                        completeRow[header] = row[header] || null;
                    });
                    return completeRow;
                });
                
                const endpoint = aiType === 'claude' ? '/claude/analyze' : '/gemini/analyze';
                const response = await fetch(`${GEMINI_API_BASE}${endpoint}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(aiType === 'claude' ? {
                        prompt: prompt,
                        dataset_info: {
                            record_count: window.participantsData.length,
                            filtered_count: currentlyDisplayedData.length,
                            sample_data: completeAnalysisData,
                            headers: allHeaders,
                            sort_info: {
                                column: currentSortColumn || null,
                                order: currentSortOrder || null
                            },
                            filter_info: {
                                status_filter: selectedStatuses.size > 0 && !selectedStatuses.has('All') ? Array.from(selectedStatuses) : null,
                                team_filter: currentTeamFilter || null,
                                group_filter: showOnlyGroup || false
                            }
                        }
                    } : {
                        // For Gemini, include dataset directly in prompt with filter/sort context
                        prompt: `${prompt}

**Dataset Context:**
-- Original Total Records: ${window.participantsData.length}
-- After Filters Applied: ${currentlyDisplayedData.length}
-- Sample Size for Analysis: ${completeAnalysisData.length}
-- All Available Headers: ${allHeaders.join(', ')}
-- Current Sort Order: ${currentSortColumn ? `${currentSortColumn} (${currentSortOrder})` : 'Default order'}
-- Active Filters: ${(() => {
    const filters = [];
    if (selectedStatuses.size > 0 && !selectedStatuses.has('All')) {
        filters.push(`Status: ${Array.from(selectedStatuses).join(', ')}`);
    }
    if (currentTeamFilter) {
        filters.push(`Team: ${currentTeamFilter}`);
    }
    if (showOnlyGroup) {
        filters.push('Group participants only');
    }
    return filters.length > 0 ? filters.join('; ') : 'None';
})()}

**Sample Data (JSON format - filtered/sorted as displayed):**
${JSON.stringify(completeAnalysisData, null, 2)}`,
                        data_context: null
                    })
                });
                
                const result = await response.json();
                
                if (result.success && result.analysis) {
                    // Append token usage information if available
                    let analysisWithTokens = result.analysis;
                    if (result.token_usage) {
                        analysisWithTokens = appendTokenUsage(result.analysis, result.token_usage);
                    }
                    
                    // Store in pending analysis (don't save to cache yet - user needs to save)
                    const pendingData = {
                        success: true,
                        analysis: analysisWithTokens,
                        totalRecords: window.participantsData.length,
                        filteredRecords: currentlyDisplayedData.length,
                        sampleSize: completeAnalysisData.length,
                        timestamp: new Date().toISOString(),
                        customPrompt: prompt,
                        sortInfo: {
                            column: currentSortColumn || null,
                            order: currentSortOrder || null
                        },
                        filterInfo: {
                            status: selectedStatuses.size > 0 && !selectedStatuses.has('All') ? Array.from(selectedStatuses) : null,
                            team: currentTeamFilter || null,
                            groupOnly: showOnlyGroup || false
                        }
                    };
                    
                    if (aiType === 'claude') {
                        pendingClaudeAnalysis = pendingData;
                        // Display with Save/Cancel buttons - show filtered count in UI
                        await displaySharedClaudeInsights(analysisWithTokens, currentlyDisplayedData.length, completeAnalysisData.length, true, prompt);
                        showTopMessage('✅ Claude analysis complete! Choose Save to keep or Cancel to revert.', 'success', 0);
                    } else {
                        pendingGeminiAnalysis = pendingData;
                        // Display with Save/Cancel buttons - show filtered count in UI
                        await displaySharedGeminiInsights(analysisWithTokens, currentlyDisplayedData.length, completeAnalysisData.length, true, prompt);
                        showTopMessage('✅ Gemini analysis complete! Choose Save to keep or Cancel to revert.', 'success', 0);
                    }
                    
                    showAIInsightsButtons(); // Update button states
                    
                } else {
                    content.innerHTML = `<div style="padding: 16px; color: var(--error-color);">Analysis failed: ${result.error || 'Unknown error'}</div>`;
                }
                
            } catch (error) {
                console.error('AI analysis error:', error);
                // Check if this is likely a connection error (server not running)
                const isConnectionError = error.message.includes('fetch') || 
                                        error.message.includes('NetworkError') || 
                                        error.message.includes('Failed to fetch');
                
                if (isConnectionError) {
                    content.innerHTML = `<div style="padding: 16px; color: #92400E; background: #FEF3C7; border: 1px solid #F59E0B; border-radius: 4px;">
                        ⚠️ Analysis failed: Start the Rust API server first<br>
                        <small style="margin-top: 4px; display: block; opacity: 0.8;">The AI insights require the backend server to be running on port 8081</small>
                    </div>`;
                    showTopMessage('⚠️ AI Analysis failed: Rust API server not running on port 8081', 'error', 8000);
                } else {
                    content.innerHTML = `<div style="padding: 16px; color: var(--error-color);">Analysis failed: ${error.message}</div>`;
                }
            }
        }
        
        function updateActiveAIButtons() {
            // Update button states based on active AI
            const claudeBtn = document.getElementById('claudeInsightsBtn');
            const geminiBtn = document.getElementById('geminiInsightsBtn');
            
            if (claudeBtn && geminiBtn) {
                claudeBtn.classList.toggle('active', currentActiveAI === 'claude');
                geminiBtn.classList.toggle('active', currentActiveAI === 'gemini');
            }
        }
        
        // Save/Cancel functions for Claude analysis (required by shared functions)
        function saveClaudeAnalysis() {
            if (pendingClaudeAnalysis) {
                const cacheKey = getCurrentDataSource();
                console.log('Saving Claude analysis to cache with key:', cacheKey);
                
                
                // Save to cache
                claudeInsightsCache[cacheKey] = pendingClaudeAnalysis;
                localStorage.setItem('claudeInsightsCache', JSON.stringify(claudeInsightsCache));
                
                // Clear pending analysis
                pendingClaudeAnalysis = null;
                
                // Re-display without Save/Cancel buttons
                displaySharedClaudeInsights(
                    claudeInsightsCache[cacheKey].analysis, 
                    claudeInsightsCache[cacheKey].totalRecords, 
                    claudeInsightsCache[cacheKey].sampleSize, 
                    false,
                    claudeInsightsCache[cacheKey].customPrompt
                );
                
                showAIInsightsButtons(); // Update button states
            }
        }
        
        function cancelClaudeAnalysis() {
            if (pendingClaudeAnalysis) {
                pendingClaudeAnalysis = null;
                const cacheKey = getCurrentDataSource();
                
                // Check if there's a cached version to restore
                if (claudeInsightsCache[cacheKey]) {
                    displayCachedInsights(cacheKey, 'claude');
                } else {
                    const content = document.getElementById('insightsContent');
                    content.innerHTML = '<div style="color: var(--text-secondary); font-style: italic; text-align: center; padding: 20px;">Click "Claude Insights" or "Gemini Insights" for AI analysis. Use the ↻ refresh button for custom prompts.</div>';
                }
            }
        }
        
        // Save/Cancel functions for Gemini analysis (required by shared functions)
        function saveGeminiAnalysis() {
            if (pendingGeminiAnalysis) {
                const cacheKey = getCurrentDataSource();
                console.log('Saving Gemini analysis to cache with key:', cacheKey);
                
                
                // Save to cache
                aiInsightsCache[cacheKey] = pendingGeminiAnalysis;
                localStorage.setItem('aiInsightsCache', JSON.stringify(aiInsightsCache));
                
                // Clear pending analysis
                pendingGeminiAnalysis = null;
                
                // Re-display without Save/Cancel buttons
                displaySharedGeminiInsights(
                    aiInsightsCache[cacheKey].analysis, 
                    aiInsightsCache[cacheKey].totalRecords, 
                    aiInsightsCache[cacheKey].sampleSize, 
                    false,
                    aiInsightsCache[cacheKey].customPrompt
                );
                
                showAIInsightsButtons(); // Update button states
            }
        }
        
        function cancelGeminiAnalysis() {
            if (pendingGeminiAnalysis) {
                pendingGeminiAnalysis = null;
                const cacheKey = getCurrentDataSource();
                
                // Check if there's a cached version to restore
                if (aiInsightsCache[cacheKey]) {
                    displayCachedInsights(cacheKey, 'gemini');
                } else {
                    const content = document.getElementById('insightsContent');
                    content.innerHTML = '<div style="color: var(--text-secondary); font-style: italic; text-align: center; padding: 20px;">Click "Claude Insights" or "Gemini Insights" for AI analysis. Use the ↻ refresh button for custom prompts.</div>';
                }
            }
        }

        // Google Meetup Participants
        const getParticipantsButton = document.getElementById('get-participants');
        const participantsSpinner = document.getElementById('participants-spinner');
        const participantsResult = document.getElementById('participants-result');
        const fileSelect = document.getElementById('fileSelect');
        const customFileSection = document.getElementById('customFileSection');
        const fileInput = document.getElementById('excelFile');
        const fileDisplay = document.getElementById('fileDisplay');
        const statusMessages = document.getElementById('statusMessages');
        
        let selectedFile = null;
        let customFiles = {};

        // Helper function to append messages to statusMessages
        function appendStatusMessage(message, type = 'info') {
            const messageDiv = document.createElement('div');
            messageDiv.className = `status-message ${type}`;
            messageDiv.style.display = 'block'; // Ensure message is visible
            messageDiv.innerHTML = message;
            statusMessages.appendChild(messageDiv);
        }

        // Helper function to show messages in top message area
        function showTopMessage(message, type = 'warning', duration = 10000) {
            const messageArea = document.getElementById('top-message-area');
            const messageContent = document.getElementById('top-message-content');
            
            if (messageArea && messageContent) {
                messageContent.innerHTML = message;
                
                // Update styling based on message type
                const card = messageArea.querySelector('.card');
                if (type === 'error') {
                    card.style.borderLeftColor = '#ef4444';
                    card.style.background = '#fef2f2';
                    card.style.color = '#dc2626';
                } else if (type === 'success') {
                    card.style.borderLeftColor = '#10b981';
                    card.style.background = '#f0fdf4';
                    card.style.color = '#065f46';
                } else { // warning
                    card.style.borderLeftColor = '#f59e0b';
                    card.style.background = '#fef3c7';
                    card.style.color = '#92400e';
                }
                
                messageArea.style.display = 'block';
                
                // Auto-hide after specified duration
                if (duration > 0) {
                    setTimeout(() => {
                        messageArea.style.display = 'none';
                    }, duration);
                }
            }
        }

        // Helper function to hide top message
        function hideTopMessage() {
            const messageArea = document.getElementById('top-message-area');
            if (messageArea) {
                messageArea.style.display = 'none';
            }
        }

        // Helper function to get modelteam URL from dropdown options
        function getModelteamUrl() {
            const modelteamOption = Array.from(fileSelect.options).find(option => option.value === 'modelteam');
            return modelteamOption ? modelteamOption.getAttribute('data-url') : null;
        }

        // Show/hide the Repos button only when list=modelteam
        function updateContribsButtonVisibility() {
            try {
                const hash = getHash();
                const contribBtn = document.getElementById('contribs-btn');
                if (!contribBtn) return;
                const isModel = hash.list === 'modelteam';
                if (isModel) {
                    contribBtn.style.display = '';
                } else {
                    contribBtn.style.display = 'none';
                    // also hide contributions panel if open
                    const panel = document.getElementById('contributionsPanel');
                    if (panel) panel.style.display = 'none';
                }

                // Also control participants map visibility when viewing modelteam
                try {
                    const mapContainer = document.getElementById('participants-map-container');
                    if (mapContainer) {
                        // show map for modelteam, hide otherwise (but do not force-hide if
                        // user explicitly toggled the map via the Show/Hide map control)
                        // We check a lightweight flag stored on the container to respect
                        // user toggles: if container.dataset.userHidden === '1' we won't
                        // override the user's preference when hiding.
                        if (isModel) {
                            mapContainer.style.display = 'block';
                        } else {
                            if (!mapContainer.dataset.userHidden || mapContainer.dataset.userHidden !== '1') {
                                mapContainer.style.display = 'none';
                            }
                        }
                    }
                } catch (e) {
                    console.warn('updateContribsButtonVisibility - map visibility error', e);
                }
            } catch (e) {
                console.warn('updateContribsButtonVisibility error', e);
            }
        }
        
        async function getSubsetUsingSnapshot() {
            // Check for admin=1 and list=modelteam in hash
            const hash = getHash();
            const isAdmin = hash.admin === '1';
            const isModelTeam = hash.list === 'modelteam';
            // update Contributions button visibility whenever we check the hash here
            updateContribsButtonVisibility();
            
            let meetupLink;
            let isCors;
            let allFields;
            let config = null; // Declare config in broader scope
            
            if (isAdmin && isModelTeam) {
                // Use community/people.env for admin modelteam (treated as CSV)
                meetupLink = '../../community/people.csv';
                isCors = false;
                console.log('Admin mode: Loading from community/people.env (treated as CSV)');
            } else {
                // Normal processing
                const currentValue = fileSelect.value;
                const selectedOption = Array.from(fileSelect.options).find(opt => opt.value === currentValue);
                meetupLink = selectedOption?.getAttribute('data-url') || selectedFile;
                isCors = selectedOption?.getAttribute('data-cors') === 'true';
                allFields = selectedOption?.getAttribute('data-all-fields');
                
                // Get config for filtering (e.g., int_required)
                const intRequired = selectedOption?.getAttribute('data-int-required');
                config = intRequired ? { int_required: intRequired } : null;
                
                console.log('=== getSubsetUsingSnapshot DEBUG ===');
                console.log('Current fileSelect value:', currentValue);
                console.log('Found option:', selectedOption ? selectedOption.textContent : 'Not found');
                console.log('Option data-url:', selectedOption?.getAttribute('data-url'));
                console.log('Option data-cors attribute:', selectedOption?.getAttribute('data-cors'));
                console.log('Option data-all-fields attribute:', selectedOption?.getAttribute('data-all-fields'));
                console.log('isCors resolved to:', isCors);
                console.log('selectedFile variable:', selectedFile);
                console.log('Final meetupLink:', meetupLink);
                
                // If no valid URL found, try to get modelteam URL from dropdown
                if (!meetupLink) {
                    meetupLink = getModelteamUrl();
                    if (!meetupLink) {
                        appendStatusMessage('Please select a valid data source or wait for options to load.', 'error');
                        return;
                    }
                }
            }

            // Check file size and handle different binary file types
            async function checkFileSize(url) {
                try {
                    const headResponse = await fetch(url, { method: 'HEAD' });
                    const contentLength = headResponse.headers.get('content-length');
                    return contentLength ? parseInt(contentLength) : null;
                } catch (error) {
                    console.warn('Could not check file size:', error);
                    return null;
                }
            }

            // Separate handling for .h5 files vs other binary files
            const h5Extensions = ['.hdf5', '.h5'];
            const otherBinaryExtensions = ['.tiff', '.tif', '.pdf', '.png', '.jpg', '.jpeg', '.zip', '.tar', '.gz'];
            
            const isH5File = h5Extensions.some(ext => meetupLink.toLowerCase().includes(ext));
            const isOtherBinaryFile = otherBinaryExtensions.some(ext => meetupLink.toLowerCase().includes(ext));
            
            if (isOtherBinaryFile) {
                const currentList = getHash().list || fileSelect.value || 'Unknown';
                const currentOption = Array.from(fileSelect.options).find(opt => opt.value === currentList);
                const listTitle = currentOption?.textContent || currentList;
                
                showTopMessage(
                    `<strong>Binary File Detected</strong><br>` +
                    `The selected item "${listTitle}" points to a binary file (${meetupLink.split('/').pop()}) which cannot be processed as tabular data.<br>` +
                    `<small>Supported formats: CSV, JSON, API endpoints that return structured data.</small>`,
                    'error',
                    8000
                );
                
                getParticipantsButton.disabled = false;
                participantsSpinner.style.display = 'none';
                return;
            }
            
            if (isH5File) {
                // Check file size before processing HDF5 files
                const fileSize = await checkFileSize(meetupLink);
                const currentList = getHash().list || fileSelect.value || 'Unknown';
                const currentOption = Array.from(fileSelect.options).find(opt => opt.value === currentList);
                const listTitle = currentOption?.textContent || currentList;
                
                if (fileSize && fileSize > 50 * 1024 * 1024) { // 50MB limit
                    showTopMessage(
                        `<strong>HDF5 File Too Large</strong><br>` +
                        `The selected HDF5 file "${listTitle}" is ${(fileSize / 1024 / 1024).toFixed(1)}MB, which exceeds the 50MB processing limit.<br>` +
                        `<small>Large HDF5 files should be processed locally or through specialized analysis tools.</small>`,
                        'error',
                        8000
                    );
                    
                    getParticipantsButton.disabled = false;
                    participantsSpinner.style.display = 'none';
                    return;
                }
                
                // Process HDF5 file through Rust CORS proxy
                showTopMessage(
                    `<strong>Processing HDF5 File</strong><br>` +
                    `Loading HDF5 file "${listTitle}" (${fileSize ? (fileSize / 1024 / 1024).toFixed(1) + 'MB' : 'size unknown'}) for client-side processing...`,
                    'warning',
                    0 // Don't auto-hide while processing
                );
                
                try {
                    const proxyResponse = await fetch('http://localhost:8081/api/proxy/hdf5', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            url: meetupLink
                        })
                    });
                    
                    if (proxyResponse.ok) {
                        const h5Data = await proxyResponse.arrayBuffer();
                        
                        showTopMessage(
                            `<strong>HDF5 File Ready</strong><br>` +
                            `File loaded successfully. Processing with client-side HDF5 tools...`,
                            'success',
                            3000
                        );
                        
                        // TODO: Process HDF5 data with client-side tools
                        console.log('HDF5 data received:', h5Data.byteLength, 'bytes');
                        
                        // For now, show that we successfully got the data
                        currentData = [{
                            'Title': listTitle,
                            'Type': 'HDF5 File',
                            'Size': fileSize ? `${(fileSize / 1024 / 1024).toFixed(1)}MB` : 'Unknown',
                            'URL': meetupLink,
                            'Status': 'Loaded for client-side processing'
                        }];
                        displayTableLayout(currentData, listTitle);
                        
                    } else {
                        throw new Error(`Proxy failed: ${proxyResponse.status}`);
                    }
                } catch (error) {
                    showTopMessage(
                        `<strong>HDF5 Processing Failed</strong><br>` +
                        `Could not load HDF5 file through proxy: ${error.message}`,
                        'error',
                        8000
                    );
                }
                
                getParticipantsButton.disabled = false;
                participantsSpinner.style.display = 'none';
                return;
            }

            try {
                getParticipantsButton.disabled = true;
                participantsSpinner.style.display = 'inline-block';
                
                // Hide table and clear content immediately to prevent flash
                const participantsTableCard = document.getElementById('participants-table-card');
                const tableContainer = document.getElementById('participants-table-container');
                
                if (participantsTableCard) {
                    participantsTableCard.style.display = 'none';
                }
                if (tableContainer) {
                    tableContainer.innerHTML = '<div class="loading-state">Loading data...</div>';
                }

                // Add iframe for bsky list if detected
                const hash = getHash ? getHash() : {};
                console.log('Current hash:', hash, 'list value:', hash.list);
                if (hash.list === 'bsky') {
                    console.log('Creating bsky iframe container');
                    const bskyIframeContainer = document.createElement('div');
                    bskyIframeContainer.id = 'bsky-iframe-container';
                    bskyIframeContainer.style.marginBottom = '20px';
                    bskyIframeContainer.style.padding = '10px';
                    bskyIframeContainer.style.border = '1px solid #ddd';
                    bskyIframeContainer.style.borderRadius = '8px';
                    bskyIframeContainer.style.backgroundColor = '#f9f9f9';
                    
                    const label = document.createElement('div');
                    label.style.fontSize = '14px';
                    label.style.fontWeight = 'bold';
                    label.style.marginBottom = '8px';
                    label.style.color = '#333';
                    label.textContent = 'BlueSky RSS Feed (via CORS proxy)';
                    bskyIframeContainer.appendChild(label);
                    
                    const iframe = document.createElement('iframe');
                    iframe.src = `https://cors-anywhere.herokuapp.com`;
                    iframe.style.width = '100%';
                    iframe.style.height = '400px';
                    iframe.style.border = '4px solid blue';
                    iframe.style.borderRadius = '4px';
                    bskyIframeContainer.appendChild(iframe);
                    
                    const note = document.createElement('div');
                    note.style.fontSize = '12px';
                    note.style.color = '#666';
                    note.style.marginTop = '8px';
                    note.textContent = 'RSS feed displayed via cors-anywhere.herokuapp.com to bypass CORS restrictions';
                    bskyIframeContainer.appendChild(note);
                    
                    // Insert before the table container
                    if (tableContainer && tableContainer.parentNode) {
                        tableContainer.parentNode.insertBefore(bskyIframeContainer, tableContainer);
                    }
                }

                // Use unified data loading from js/list.js
                console.log(`Loading data from: ${meetupLink}, CORS: ${isCors}`);
                console.log('API_BASE:', GEMINI_API_BASE);
                console.log('Config for filtering:', config);
                const loadResult = await loadUnifiedData(meetupLink, {
                    forceCorsProxy: isCors,
                    API_BASE: GEMINI_API_BASE,
                    allFields: allFields,
                    config: config
                });
                console.log('Load result status:', loadResult.success, 'data length:', loadResult.data?.length);
                
                if (!loadResult.data || loadResult.data.length === 0) {
                    const errorMessage = `No data found in the source\n\nPath attempted: ${meetupLink}`;
                    
                    // Show error in status messages
                    appendStatusMessage(`<h4>No Data Found</h4><p>${errorMessage}</p>`, 'error');
                    
                    // Populate Raw Data Editor with the load result
                    const rawDataEditor = document.getElementById('raw-data-editor');
                    const rawDataSource = document.getElementById('raw-data-source');
                    
                    if (rawDataEditor) {
                        rawDataEditor.value = JSON.stringify(loadResult, null, 2);
                    }
                    
                    if (rawDataSource) {
                        rawDataSource.value = meetupLink;
                    }
                    
                    // Show Raw Data Editor panel
                    const rawDataControl = document.getElementById('raw-data-control');
                    if (rawDataControl) {
                        rawDataControl.style.display = 'block';
                        
                        // Update toggle text
                        const rawDataText = document.getElementById('raw-data-text');
                        if (rawDataText) {
                            rawDataText.textContent = 'Hide Raw Data';
                        }
                        
                        // Set rawDataVisible flag
                        if (typeof rawDataVisible !== 'undefined') {
                            rawDataVisible = true;
                        }
                    }
                    
                    // Show the table card so the 3-dot menu remains accessible
                    document.getElementById('participants-table-card').style.display = 'block';
                    
                    // Show upload fallback
                    const uploadFallback = document.getElementById('upload-fallback');
                    if (uploadFallback) {
                        uploadFallback.style.display = 'block';
                    }
                    
                    return; // Exit the function instead of throwing
                }
                
                // Filter out any null/undefined rows
                const validData = loadResult.data.filter(row => row && typeof row === 'object');
                
                if (validData.length === 0) {
                    const errorMessage = `No valid data found in the source\n\nPath attempted: ${meetupLink}`;
                    
                    // Show error in status messages
                    appendStatusMessage(`<h4>No Valid Data Found</h4><p>${errorMessage}</p>`, 'error');
                    
                    // Populate Raw Data Editor with the load result
                    const rawDataEditor = document.getElementById('raw-data-editor');
                    const rawDataSource = document.getElementById('raw-data-source');
                    
                    if (rawDataEditor) {
                        rawDataEditor.value = JSON.stringify(loadResult, null, 2);
                    }
                    
                    if (rawDataSource) {
                        rawDataSource.value = meetupLink;
                    }
                    
                    // Show Raw Data Editor panel
                    const rawDataControl = document.getElementById('raw-data-control');
                    if (rawDataControl) {
                        rawDataControl.style.display = 'block';
                        
                        // Update toggle text
                        const rawDataText = document.getElementById('raw-data-text');
                        if (rawDataText) {
                            rawDataText.textContent = 'Hide Raw Data';
                        }
                        
                        // Set rawDataVisible flag
                        if (typeof rawDataVisible !== 'undefined') {
                            rawDataVisible = true;
                        }
                    }
                    
                    // Show the table card so the 3-dot menu remains accessible
                    document.getElementById('participants-table-card').style.display = 'block';
                    
                    // Show upload fallback
                    const uploadFallback = document.getElementById('upload-fallback');
                    if (uploadFallback) {
                        uploadFallback.style.display = 'block';
                    }
                    
                    return; // Exit the function instead of throwing
                }
                
                // Reset team legend flag for new data
                initialTeamLegendGenerated = false;
                
                // Always populate Raw Data Editor when data is successfully fetched
                const rawDataEditor = document.getElementById('raw-data-editor');
                const rawDataSource = document.getElementById('raw-data-source');
                
                if (rawDataEditor) {
                    // Use the raw data before preprocessing
                    originalRawData = JSON.parse(JSON.stringify(loadResult.data));
                    rawDataEditor.value = JSON.stringify(loadResult.data, null, 2);
                }
                
                if (rawDataSource) {
                    rawDataSource.value = meetupLink;
                }
                
                displayTableLayout(validData);
                
                // Extract and display emails if Email column exists
                extractAndDisplayEmails(validData);
                
                // Store the original loaded count for pagination
                originalLoadedCount = validData.length;
                
                const sourceDescription = isCors ? 
                    `CORS-restricted ${loadResult.format.toUpperCase()} source using Rust proxy` : 
                    `${loadResult.format.toUpperCase()} source`;
                appendStatusMessage(`Successfully loaded ${validData.length} records from ${sourceDescription}`, 'success');
                
                // Show UI elements after successful data load
                showListDisplayElements();
                
                // Show AI Insights section after successful data load
                showAIInsightsSection();
                
                // Add iframe for bsky list after successful data load
                if (typeof hash === 'undefined') {
                    hash = getHash ? getHash() : {};
                }
                
                // Hide existing CORS iframe container if switching to non-bsky feed
                const existingContainer = document.getElementById('cors-iframe-container');
                if (existingContainer) {
                    if (hash.list === 'bsky') {
                        existingContainer.style.display = 'block';
                    } else {
                        existingContainer.style.display = 'none';
                    }
                }
                
                if (hash.list === 'bsky') {
                    console.log('Adding bsky iframe after successful data load');
                    
                    // Remove any existing iframe container only if it exists
                    if (existingContainer) {
                        existingContainer.remove();
                    }
                    
                    const corsIframeContainer = document.createElement('div');
                    corsIframeContainer.id = 'cors-iframe-container';
                    corsIframeContainer.style.marginBottom = '20px';
                    corsIframeContainer.style.padding = '10px';
                    corsIframeContainer.style.border = '1px solid #ddd';
                    corsIframeContainer.style.borderRadius = '8px';
                    corsIframeContainer.style.backgroundColor = '#f9f9f9';
                    
                    const label = document.createElement('div');
                    label.style.fontSize = '14px';
                    label.style.fontWeight = 'bold';
                    label.style.marginBottom = '8px';
                    label.style.color = '#333';
                    label.textContent = 'BlueSky RSS Feed (via CORS proxy)';
                    corsIframeContainer.appendChild(label);
                    
                    const iframe = document.createElement('iframe');
                    iframe.src = `https://cors-anywhere.herokuapp.com`;
                    iframe.style.width = '100%';
                    iframe.style.height = '350px';
                    iframe.style.minHeight = 'unset';
                    iframe.style.border = '4px solid blue';
                    iframe.style.borderRadius = '4px';
                    corsIframeContainer.appendChild(iframe);
                    
                    const note = document.createElement('div');
                    note.style.fontSize = '12px';
                    note.style.color = '#666';
                    note.style.marginTop = '8px';
                    note.innerHTML = `RSS feed displayed via <a href="https://cors-anywhere.herokuapp.com" target="_blank">cors-anywhere.herokuapp.com</a> to bypass CORS restrictions`;
                    corsIframeContainer.appendChild(note);
                    
                    // Insert at the bottom of the main content area
                    const mainContent = document.getElementById('participants-table-card') || document.getElementById('table-view');
                    if (mainContent && mainContent.parentNode) {
                        mainContent.parentNode.appendChild(corsIframeContainer);
                    }
                }
                
                // Load most recent snapshot for this list after data is loaded
                loadSnapshotOnPageLoad();

            } catch (error) {
                console.error('Full error details:', error);
                
                // Enhanced error reporting for call stack issues
                let errorMessage = error.message;
                let additionalInfo = '';
                
                // Add file path info when on localhost for debugging
                const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                if (isLocalhost && meetupLink) {
                    additionalInfo += `<br><strong>File path attempted:</strong> <code>${meetupLink}</code>`;
                }
                
                if (error.message && error.message.includes('Maximum call stack size exceeded')) {
                    // Get stack trace info and estimate call stack depth
                    const stackTrace = error.stack || '';
                    const stackLines = stackTrace.split('\n').filter(line => line.trim().length > 0);
                    const stackDepth = stackLines.length;
                    
                    // Try to get some memory usage info if available
                    let memoryInfo = '';
                    if (performance && performance.memory) {
                        const memory = performance.memory;
                        const usedMB = Math.round(memory.usedJSHeapSize / 1024 / 1024);
                        const totalMB = Math.round(memory.totalJSHeapSize / 1024 / 1024);
                        const limitMB = Math.round(memory.jsHeapSizeLimit / 1024 / 1024);
                        memoryInfo = ` Memory usage: ${usedMB}MB used, ${totalMB}MB total, ${limitMB}MB limit.`;
                    }
                    
                    additionalInfo = ` Stack depth: ~${stackDepth} frames.${memoryInfo}`;
                    console.error('Call stack overflow details:');
                    console.error('- Estimated stack depth:', stackDepth, 'frames');
                    console.error('- Stack trace preview:', stackLines.slice(0, 10));
                    if (performance && performance.memory) {
                        console.error('- Memory info:', performance.memory);
                    }
                }
                
                // Always populate Raw Data Editor with error response for debugging
                const rawDataEditor = document.getElementById('raw-data-editor');
                const rawDataSource = document.getElementById('raw-data-source');
                
                if (rawDataEditor && error.rawResponse) {
                    // Show the raw error response from the API
                    originalRawData = JSON.parse(JSON.stringify(error.rawResponse));
                    rawDataEditor.value = JSON.stringify(error.rawResponse, null, 2);
                    console.log('Populated Raw Data Editor with error response:', error.rawResponse);
                }
                
                if (rawDataSource && error.requestUrl) {
                    rawDataSource.value = error.requestUrl;
                }
                
                appendStatusMessage(`<h4>Error Loading Data</h4><p>${errorMessage}${additionalInfo}</p>`, 'error');
                
                // Show the table card so the 3-dot menu remains accessible
                document.getElementById('participants-table-card').style.display = 'block';
                
                // Log error for debugging
                console.log('Showing upload fallback due to error:', error.message);
            } finally {
                getParticipantsButton.disabled = false;
                participantsSpinner.style.display = 'none';
            }
        }


        // Extract and display emails from data when Email column exists
        function extractAndDisplayEmails(data) {
            const emailContainer = document.getElementById('emailListContainer');
            const emailTextarea = document.getElementById('emailList');
            const emailCountSpan = document.getElementById('emailCount');
            
            // Check if we should show emails (localsite + modelteam)
            const isLocalsite = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            const hash = getHash ? getHash() : {};
            const isModelteam = hash.list === 'modelteam';
            // ensure contributions button visibility follows the hash
            updateContribsButtonVisibility();
            // Ensure contribs button visibility reflects current hash
            updateContribsButtonVisibility();
            
            if (!isLocalsite || !isModelteam) {
                if (emailContainer) emailContainer.style.display = 'none';
                return;
            }
            
            if (!data || !Array.isArray(data) || data.length === 0) {
                if (emailContainer) emailContainer.style.display = 'none';
                return;
            }
            
            // Find the "Email" column specifically (case-insensitive)
            const headers = Object.keys(data[0] || {});
            const emailColumn = headers.find(header => header.toLowerCase() === 'email');
            
            if (!emailColumn) {
                // Show message about admin mode and community/people.csv file
                if (emailContainer) {
                    emailContainer.style.display = 'block';
                    
                    if (emailTextarea) {
                        emailTextarea.value = '';
                        emailTextarea.placeholder = 'No email columns found in current data. Use admin mode to load emails from local CSV.';
                    }
                    
                    if (emailCountSpan) {
                        emailCountSpan.innerHTML = `
                            <div style="color: var(--text-secondary); font-size: 12px; line-height: 1.4; margin-top: 4px;">
                                💡 To display emails: Add <code style="background: var(--bg-tertiary); padding: 2px 4px; border-radius: 3px;">&admin=1</code> to URL<br>
                                📁 Emails loaded from: <code style="background: var(--bg-tertiary); padding: 2px 4px; border-radius: 3px;">community/people.env</code> (treated as CSV, relative to team/projects/)
                            </div>
                        `;
                    }
                }
                return;
            }
            
            // Find the Status column for filtering out Alumni
            const statusColumn = headers.find(header => header.toLowerCase() === 'status');
            
            // Extract unique emails from the Email column only, excluding Alumni
            const emailSet = new Set();
            
            data.forEach(row => {
                // Skip rows with Status = "Alumni"
                if (statusColumn && row[statusColumn] === 'Alumni') {
                    return;
                }
                
                const emailValue = row[emailColumn];
                if (emailValue && typeof emailValue === 'string') {
                    // Split by common separators and clean up
                    const emails = emailValue.split(/[,;|\s]+/)
                        .map(email => email.trim().toLowerCase())
                        .filter(email => {
                            // Basic email validation
                            return email && 
                                   email.includes('@') && 
                                   email.includes('.') && 
                                   email.length > 5 &&
                                   /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
                        });
                    
                    emails.forEach(email => emailSet.add(email));
                }
            });
            
            // Convert to sorted array
            const uniqueEmails = Array.from(emailSet).sort();
            
            if (uniqueEmails.length === 0) {
                if (emailContainer) emailContainer.style.display = 'none';
                return;
            }
            
            // Display the emails
            const emailsText = uniqueEmails.join(', ');
            if (emailTextarea) {
                emailTextarea.value = emailsText;
                emailTextarea.addEventListener('click', function() {
                    this.select();
                });
            }
            
            if (emailCountSpan) {
                emailCountSpan.textContent = `${uniqueEmails.length} email${uniqueEmails.length !== 1 ? 's' : ''}`;
            }
            
            if (emailContainer) {
                emailContainer.style.display = 'block';
            }
            
            // Store emails for filtering
            window.extractedEmails = uniqueEmails;
            window.allExtractedEmails = uniqueEmails;
        }

        // Update email list based on filtered participant data
        function updateFilteredEmails(filteredData) {
            const emailTextarea = document.getElementById('emailList');
            const emailCountSpan = document.getElementById('emailCount');
            
            if (!filteredData || filteredData.length === 0) {
                if (emailTextarea) {
                    emailTextarea.value = '';
                }
                if (emailCountSpan) {
                    emailCountSpan.textContent = '0 emails';
                }
                return;
            }
            
            // Find email columns in the current data structure
            const headers = Object.keys(filteredData[0] || {});
            const emailColumns = headers.filter(header => 
                header.toLowerCase().includes('email') || 
                header.toLowerCase().includes('e-mail') ||
                header.toLowerCase() === 'mail'
            );
            
            if (emailColumns.length === 0) {
                return;
            }
            
            // Extract unique emails from filtered data
            const emailSet = new Set();
            
            filteredData.forEach(row => {
                emailColumns.forEach(column => {
                    const emailValue = row[column];
                    if (emailValue && typeof emailValue === 'string') {
                        // Split by common separators and clean up
                        const emails = emailValue.split(/[,;|\s]+/)
                            .map(email => email.trim().toLowerCase())
                            .filter(email => {
                                // Basic email validation
                                return email && 
                                       email.includes('@') && 
                                       email.includes('.') && 
                                       email.length > 5 &&
                                       /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
                            });
                        
                        emails.forEach(email => emailSet.add(email));
                    }
                });
            });
            
            // Convert to sorted array
            const filteredEmails = Array.from(emailSet).sort();
            
            // Update the display
            const emailsText = filteredEmails.join(', ');
            if (emailTextarea) {
                emailTextarea.value = emailsText;
            }
            
            if (emailCountSpan) {
                emailCountSpan.textContent = `${filteredEmails.length} email${filteredEmails.length !== 1 ? 's' : ''}`;
            }
            
            // Update the stored filtered emails
            window.extractedEmails = filteredEmails;
            
            console.log(`📧 Email filtering complete: ${window.allExtractedEmails.length} total → ${filteredEmails.length} filtered`);
        }

        // Note: parseCSV function is now available from js/list.js
        
        // Helper function to get list-specific localStorage key
        function getListStorageKey(baseKey) {
            const listId = getHash().list || 'default';
            return `${listId}_1_${baseKey}`;
        }
        
        // Current view mode and filtering
        let currentView = getHash().display || localStorage.getItem(getListStorageKey('participantsViewMode')) || 'column'; // Check URL hash first, then list-specific storage, then default to column
        let currentTeamFilter = getHash().team || localStorage.getItem(getListStorageKey('participantsTeamFilter')) || null;
        let currentLoadedList = null; // Track which list is currently loaded
        let initialTeamLegendGenerated = false;
        
        // Flag to prevent group parameter processing during status updates
        let isUpdatingStatus = false;
        
        // Track previous group parameter state to avoid false alerts
        let previousGroupParam = null;
        
        // File selection state
        const STORAGE_KEY = 'listObject';
        let allRowsData = [];
        let originalLoadedCount = 0; // Track total records loaded from source
        let groupParticipants = new Set();
        
        // Layout state
        let isFullscreen = JSON.parse(localStorage.getItem('isFullscreen') || 'false');
        let isCondensed = JSON.parse(localStorage.getItem('isCondensed') || 'false');
        
        // Sort functionality - only use localStorage (not in URL hash anymore)
        let currentSortColumn = localStorage.getItem(getListStorageKey('participantsSortColumn')) || 'Rows';
        let currentSortOrder = localStorage.getItem(getListStorageKey('participantsSortOrder')) || 'asc';
        
        // Pagination functionality
        let currentPage = 1;
        const recordsPerPage = 200;
        let totalRecords = 0;
        let originalDataOrder = [];
        
        // Status filtering - check URL hash first, then localStorage
        let selectedStatuses = new Set(getHash().status ? getHash().status.split(',') : JSON.parse(localStorage.getItem(getListStorageKey('participantsStatusFilter')) || '["All"]'));
        let availableStatuses = [];
        
        // Group participants toggle state - only load from cache if snapshots exist
        function getInitialGroupToggleState() {
            const snapshots = JSON.parse(localStorage.getItem(getSnapshotsStorageKey()) || '{}');
            const hasSnapshots = Object.keys(snapshots).length > 0;
            
            // If no snapshots exist, default to false regardless of cache
            if (!hasSnapshots) {
                return false;
            }
            
            return JSON.parse(localStorage.getItem(getListStorageKey('showOnlyGroup')) || 'false');
        }
        let showOnlyGroup = getInitialGroupToggleState();
        
        // Team color mapping
        const teamColors = {
            'js': { class: 'team-js', color: '#667eea', name: 'JS' },
            'ml': { class: 'team-ml', color: '#f093fb', name: 'ML' },
            'react': { class: 'team-react', color: '#4facfe', name: 'React' },
            'io': { class: 'team-io', color: '#43e97b', name: 'IO' },
            'ai': { class: 'team-ai', color: '#fa709a', name: 'AI' },
            'flask': { class: 'team-flask', color: '#ff9a9e', name: 'Flask' },
            'suite': { class: 'team-suite', color: '#a8edea', name: 'Suite' },
            'us': { class: 'team-us', color: '#ffecd2', name: 'US' },
            'auth': { class: 'team-auth', color: '#89f7fe', name: 'Auth' },
            'discord': { class: 'team-discord', color: '#c2e9fb', name: 'Discord' },
            'modelteam': { class: 'team-modelteam', color: '#10B981', name: 'Model Team' },
            'default': { class: 'team-default', color: '#d299c2', name: 'Other' }
        };
        
        // Display participants in all views
        function displayTableLayout(data) {
            console.log('displayTableLayout called with data:', data);
            if (!data || data.length === 0) {
                console.log('displayTableLayout: No data provided, returning early');
                return;
            }
            
            // For large datasets, only preprocess a sample for initial setup and the first page
            console.log('displayTableLayout: Processing large dataset with', data.length, 'records');
            
            let preprocessedData;
            if (data.length > 10000) {
                console.log('📊 Large dataset detected - using chunked preprocessing');
                // For large datasets, only preprocess first chunk + sample for column detection
                const sampleSize = Math.min(1000, data.length);
                const firstChunk = data.slice(0, recordsPerPage * 3); // First 3 pages worth
                const sampleData = data.slice(0, sampleSize);
                
                console.log(`🔄 Preprocessing sample of ${sampleSize} records for column detection`);
                preprocessParticipantData(sampleData.slice(0, 10)); // Just for column setup
                
                console.log(`🔄 Preprocessing first chunk of ${firstChunk.length} records`);
                preprocessedData = preprocessParticipantData(firstChunk);
                
                // Store original data for later pagination
                window.originalLargeDataset = data;
                window.isLargeDataset = true;
                
                console.log(`✅ Initial chunk processed. Total dataset: ${data.length}, Initial chunk: ${preprocessedData.length}`);
            } else {
                console.log('displayTableLayout: Preprocessing all data...');
                preprocessedData = preprocessParticipantData(data);
                window.isLargeDataset = false;
            }
            
            const tableCard = document.getElementById('participants-table-card');
            const resultsCount = document.getElementById('results-count');
            
            // Reset to first page when new data loads
            currentPage = 1;
            
            // Update results count with pagination
            if (window.isLargeDataset) {
                // For large datasets, use original data length for total count
                totalRecords = data.length;
                updateResultsCount(data); // Pass original data for count calculation
            } else {
                updateResultsCount(preprocessedData);
            }
            
            // Store preprocessed data globally
            window.participantsData = preprocessedData;
            allRowsData = preprocessedData;
            originalDataOrder = [...preprocessedData]; // Store original order
            // Initialize heatmap if lat/lng fields exist
            try { updateParticipantsHeatmapFromData(preprocessedData); } catch (e) { console.debug('heatmap init failed', e); }
            // Also update per-state counts overlay from the same preprocessed data
            try { updateStateCountsFromData(preprocessedData); } catch (e) { console.debug('state counts init failed', e); }
            
            // Update Raw Data Editor with preprocessed data if it's currently visible
            if (rawDataVisible) {
                const rawDataEditor = document.getElementById('raw-data-editor');
                const rawDataSource = document.getElementById('raw-data-source');
                
                if (rawDataEditor && rawDataEditor.value) {
                    // Only update if the Raw Data Editor doesn't already have raw data
                    // (the raw data was already populated in getMeetupParticipants)
                    console.log('Raw Data Editor already populated with raw data, skipping preprocessed update');
                } else if (rawDataEditor) {
                    // Fallback: populate with preprocessed data if raw data wasn't available
                    originalRawData = JSON.parse(JSON.stringify(preprocessedData));
                    rawDataEditor.value = JSON.stringify(preprocessedData, null, 2);
                    
                    if (rawDataSource) {
                        rawDataSource.value = getCurrentDataSource();
                    }
                }
            }
            
            // Generate team legend only once from the initial full dataset
            if (!initialTeamLegendGenerated) {
                generateTeamLegend(preprocessedData);
                initialTeamLegendGenerated = true;
            }
            
            // Load group participants from storage and apply highlighting
            loadGroupParticipants();
            updateGroupHighlighting();
            
            // Re-validate group names now that data is available
            if (groupParticipants.size > 0) {
                validateGroupNames(Array.from(groupParticipants));
            }
            
            // Update group participants panel visibility
            updateGroupParticipantsVisibility();
            
            // Render will be handled by applyAllFilters after setTimeout
            
            // Apply saved sort preferences (without re-rendering, setTimeout will handle rendering)
            if (currentSortColumn) {
                applySortToData(false);
            }
            
            // Update status button text
            updateStatusButtonText();
            
            // Restore group toggle UI state
            updateGroupToggleUI();
            
            // Apply all saved filters (team + status + group)
            console.log('displayTableLayout: Scheduling applyAllFilters with setTimeout...');
            setTimeout(() => {
                console.log('displayTableLayout: setTimeout callback executing, calling applyAllFilters...');
                applyAllFilters();
            }, 100);
            
            // Show the card and initialize view
            tableCard.style.display = 'block';
            switchView(currentView);
        }
        
        // Helper function to get TopFields for current list
        function getCurrentTopFields() {
            const currentValue = document.getElementById('fileSelect')?.value;
            if (!currentValue) return null;
            
            const selectedOption = Array.from(document.getElementById('fileSelect').options).find(opt => opt.value === currentValue);
            const topFields = selectedOption?.getAttribute('data-top-fields');
            
            if (topFields) {
                console.log('📋 TopFields found for', currentValue, ':', topFields);
                return topFields.split(',').map(field => field.trim());
            }
            
            console.log('📋 No TopFields found for', currentValue, '- using default display');
            return null;
        }
        
        // Helper function to format field names for display
        function formatFieldName(fieldName) {
            if (!fieldName) return '';
            
            // Replace underscores with spaces and capitalize first letter of each word
            return fieldName
                .replace(/_/g, ' ')
                .replace(/\b\w/g, char => char.toUpperCase());
        }
        
        // Helper function to format URLs in display values
        function formatValueForDisplay(value) {
            if (!value || typeof value !== 'string') return value;
            
            // Check if the value starts with http:// or https://
            const urlMatch = value.match(/^(https?:\/\/[^\s"'<>]+)/i);
            if (urlMatch) {
                const fullUrl = urlMatch[0];
                // Truncate URL display text to 50 characters with ellipsis
                const displayText = value.length > 50 ? value.substring(0, 50) + '...' : value;
                return `<a href="${fullUrl}" target="_blank" rel="noopener noreferrer">${displayText}</a>`;
            }
            
            return value;
        }
        
        // Check if Rust server is available
        let rustServerAvailable = null;
        async function checkRustServer() {
            if (rustServerAvailable !== null) return rustServerAvailable;
            
            try {
                const response = await fetch('http://localhost:8081/api/health', {
                    method: 'GET',
                    timeout: 1000
                });
                rustServerAvailable = response.ok;
            } catch (error) {
                rustServerAvailable = false;
            }
            return rustServerAvailable;
        }
        
        // Helper function to generate site previews for URLs
        async function getSitePreview(url, targetDivId) {
            if (!url || !targetDivId) return;
            
            const targetDiv = document.getElementById(targetDivId);
            if (!targetDiv) return;
            
            try {
                // Always use iframe for bsky list regardless of Rust server status
                const hash = getHash ? getHash() : {};
                if (hash.list === 'bsky') {
                    const iframe = document.createElement('iframe');
                    iframe.src = `https://cors-anywhere.herokuapp.com/${url}`;
                    iframe.style.width = '100%';
                    iframe.style.height = '100px';
                    iframe.style.border = '1px solid #ccc';
                    iframe.style.borderRadius = '4px';
                    iframe.style.marginTop = '4px';
                    targetDiv.appendChild(iframe);
                    
                    // Add small label
                    const label = document.createElement('div');
                    label.style.fontSize = '9px';
                    label.style.color = '#999';
                    label.style.marginTop = '2px';
                    label.textContent = 'via cors-anywhere.herokuapp.com';
                    targetDiv.appendChild(label);
                    return; // Exit early for bsky
                }
                
                const isRustAvailable = await checkRustServer();
                
                if (isRustAvailable) {
                    // Use Rust server for scraping
                    const response = await fetch(`http://localhost:8081/api/scrape?url=${encodeURIComponent(url)}`);
                    if (response.ok) {
                        const data = await response.json();
                        
                        if (data.image) {
                            const img = document.createElement('img');
                            img.src = data.image;
                            img.style.width = '100%';
                            img.style.height = 'auto';
                            img.style.maxHeight = '120px';
                            img.style.objectFit = 'cover';
                            img.style.borderRadius = '4px';
                            img.onerror = () => img.remove();
                            targetDiv.appendChild(img);
                        }
                        
                        if (data.title) {
                            const titleDiv = document.createElement('div');
                            titleDiv.style.fontSize = '11px';
                            titleDiv.style.color = '#666';
                            titleDiv.style.marginTop = '4px';
                            titleDiv.style.overflow = 'hidden';
                            titleDiv.style.textOverflow = 'ellipsis';
                            titleDiv.style.whiteSpace = 'nowrap';
                            titleDiv.textContent = data.title.length > 30 ? 
                                data.title.substring(0, 30) + '...' : data.title;
                            targetDiv.appendChild(titleDiv);
                        }
                    }
                } else {
                    // Rust server not available - no fallback for non-bsky lists
                }
                
            } catch (error) {
                // Silently fail if preview generation fails
                console.debug('Preview generation failed:', error);
            }
        }
        
        // Helper function to determine which field is being used as the title
        function getTitleFieldName(participant, topFieldsFirstField = null) {
            if (!participant || typeof participant !== 'object') {
                return null;
            }
            
            // Check TopFields first field if provided
            if (topFieldsFirstField && participant[topFieldsFirstField] !== undefined && 
                participant[topFieldsFirstField] !== null && participant[topFieldsFirstField] !== '') {
                return topFieldsFirstField;
            }
            
            // Use same logic as getParticipantName to find which field is actually used
            const nameFields = ['Name', 'name', 'participant_name', 'full_name', 'display_name', 'displayName'];
            
            for (const field of nameFields) {
                if (participant[field] !== undefined && participant[field] !== null && participant[field] !== '') {
                    return field;
                }
            }
            
            return null;
        }
        
        // Helper function to create field display HTML for a participant
        function createFieldDisplayHTML(participant, topFields, isGallery = false, titleFieldName = null) {
            let fieldsToUse = topFields;
            
            // If TopFields is null, find best fields from the dataset with filtering
            if (!topFields || topFields.length === 0) {
                const dataKeys = Object.keys(participant || {});
                
                // Filter out unwanted fields
                const filteredKeys = dataKeys.filter(field => {
                    const fieldLower = field.toLowerCase();
                    
                    // Skip these specific field names (case insensitive)
                    if (['edit', 'index', 'preview', 'order'].includes(fieldLower)) {
                        return false;
                    }
                    
                    // Skip fields ending with _id or ID
                    if (fieldLower.endsWith('_id') || field.endsWith('ID')) {
                        return false;
                    }
                    
                    return true;
                });
                
                fieldsToUse = filteredKeys;
                console.log('📋 Using filtered dataset columns as TopFields source:', fieldsToUse);
            }
            
            if (!fieldsToUse || fieldsToUse.length === 0) {
                return ''; // No fields to display
            }
            
            let html = '';
            let fieldsDisplayed = 0;
            const maxTotalFields = 5; // Total fields including the name/title field
            const maxAdditionalFields = maxTotalFields - 1; // Subtract 1 for the name/title field
            
            // For TopFields mode, check if more than 5 fields are specified
            const isTopFieldsMode = topFields && topFields.length > 0;
            const actualMaxFields = isTopFieldsMode && topFields.length > maxTotalFields ? 
                topFields.length - 1 : maxAdditionalFields;
            
            // Find up to maxAdditionalFields unique fields with non-empty values (4 by default, unless TopFields has more than 5)
            for (let i = 0; i < fieldsToUse.length && fieldsDisplayed < actualMaxFields; i++) {
                const field = fieldsToUse[i];
                const value = participant[field];
                
                // Skip the field that's being used as the title
                if (titleFieldName && field === titleFieldName) {
                    continue;
                }
                
                // For TopFields mode, also skip the first field if no titleFieldName provided
                if (!titleFieldName && i === 0) {
                    continue;
                }
                
                // Skip fields with empty/blank values
                if (!value || value.toString().trim() === '') {
                    continue;
                }
                
                const isProjectsField = field.toLowerCase() === 'projects';
                const isLastField = fieldsDisplayed === (actualMaxFields - 1);
                
                // Add line break before Projects field if it's the last field
                //const lineBreak = (isLastField && isProjectsField) ? '<br>' : '';
                
                const formattedFieldName = formatFieldName(field);
                
                // Format URLs in the value
                const formattedValue = formatValueForDisplay(value);
                
                if (isGallery) {
                    // All fields (except first) get bold field name with colon
                    html += `<div class="gallery-info"><strong>${formattedFieldName}:</strong> ${formattedValue}</div>`;
                } else {
                    // All fields (except first) get bold field name with colon
                    if (isProjectsField) {
                        html += `<div class="columns-projects"><strong>${formattedFieldName}:</strong> ${formattedValue}</div>`;
                    } else if (field.toLowerCase() === 'status') {
                        html += `<div class="columns-info"><strong>${formattedFieldName}:</strong> <span class="columns-status">${formattedValue}</span></div>`;
                    } else {
                        html += `<div class="columns-info"><strong>${formattedFieldName}:</strong> ${formattedValue}</div>`;
                    }
                }
                
                fieldsDisplayed++;
            }
            return html;
        }

        // Render column view (default) - Using table-list style
        function renderColumnView(data) {
            const container = document.getElementById('participants-column-grid');
            container.innerHTML = '';
            
            // Check if data is valid
            if (!data || data.length === 0) {
                console.error('No data provided to renderColumnView');
                return;
            }
            
            const isMetaList = getHash().list === 'all';
            
            let imageCount = 0;
            data.forEach(participant => {
                if (!participant) return; // Skip null/undefined participants
                
                // Extract image paths from participant data
                const imagePaths = extractImagePaths(participant);
                
                // Only display first 12 items with images, or all items if no images found in any
                if (imagePaths.length > 0 && imageCount >= 12) return;
                if (imagePaths.length > 0) imageCount++;
                
                const card = document.createElement('div');
                card.className = 'columns-card';
                
                // Get TopFields for dynamic display
                const topFields = getCurrentTopFields();
                const firstTopField = topFields && topFields.length > 0 ? topFields[0] : null;
                
                const name = getParticipantName(participant, firstTopField);
                card.dataset.participantName = name;
                
                // Get the actual field name being used as title
                const titleFieldName = getTitleFieldName(participant, firstTopField);
                
                // Add clickable functionality for meta list
                if (isMetaList && participant.List) {
                    card.style.cursor = 'pointer';
                    card.title = `Click to view data from: ${participant.Title || participant.List}`;
                    card.addEventListener('click', () => {
                        setURLHashParam('list', participant.List);
                        updateParticipantListTitle(participant.Title || participant.List);
                    });
                }
                
                // Create image container if images are found
                const imageContainer = imagePaths.length > 0 ? createImageContainer(imagePaths, false) : '';
                
                // Generate field display HTML using TopFields or fallback
                const fieldDisplayHTML = createFieldDisplayHTML(participant, topFields, false, titleFieldName);
                
                card.innerHTML = `
                    <div class="columns-menu">
                        ⋯
                        <div class="columns-menu-dropdown">
                            <div class="columns-menu-item">
                                <a href="https://model.earth/projects/hub/#search=${encodeURIComponent(name)}" target="_blank">View Projects</a>
                            </div>
                        </div>
                    </div>
                    ${imageContainer}
                    <div class="columns-name">
                        <input type="checkbox" class="columns-checkbox" data-name="${name}">
                        ${name}
                    </div>
                    ${fieldDisplayHTML}
                `;
                
                container.appendChild(card);
                
                // Add checkbox event listener
                const checkbox = card.querySelector('.columns-checkbox');
                if (checkbox) {
                    checkbox.addEventListener('change', function() {
                        handleCheckboxChange(this.dataset.name, this.checked);
                    });
                }
                
                // Add 3-dot menu event listener
                const menu = card.querySelector('.columns-menu');
                if (menu) {
                    menu.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const dropdown = this.querySelector('.columns-menu-dropdown');
                        // Close other dropdowns
                        document.querySelectorAll('.columns-menu-dropdown').forEach(d => {
                            if (d !== dropdown) d.style.display = 'none';
                        });
                        // Toggle this dropdown
                        dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
                    });
                    
                    // Add event listener to menu items to close dropdown when clicked
                    const menuItems = menu.querySelectorAll('.columns-menu-item');
                    menuItems.forEach(item => {
                        item.addEventListener('click', function() {
                            const dropdown = menu.querySelector('.columns-menu-dropdown');
                            if (dropdown) {
                                dropdown.style.display = 'none';
                            }
                        });
                    });
                }
            });
            
            // Sync checkboxes after rendering cards
            setTimeout(syncCheckboxesWithGroup, 10);
        }
        
        // Handle checkbox changes
        function handleCheckboxChange(participantName, isChecked) {
            const groupField = document.getElementById('group');
            if (!groupField) return;
            
            let groupList = groupField.value.split(',').map(name => name.trim()).filter(name => name);
            
            if (isChecked) {
                // Add name if not already in the list
                if (!groupList.includes(participantName)) {
                    groupList.push(participantName);
                    groupParticipants.add(participantName);
                }
            } else {
                // Remove name from the list
                groupList = groupList.filter(name => name !== participantName);
                groupParticipants.delete(participantName);
            }
            
            groupField.value = groupList.join(', ');
            
            // Update the group count in the toggle button (same as processGroupInput)
            updateGroupCount();
            updateGroupHighlighting();
            
            // Save to storage (same as processGroupInput)
            saveGroupParticipants();
            // Note: URL hash parameters for groups have been discontinued
            
            // Auto-save to browser cache with date-based snapshot
            if (groupList.length > 0) {
                saveGroupToDateSnapshot(groupList);
            }
            
            // Apply filters if group filter is active (same as processGroupInput)
            if (showOnlyGroup) {
                applyAllFilters();
            }
            
            // Auto-save to current active snapshot if one is selected (same as processGroupInput)
            // Do this AFTER all other state updates to ensure getCurrentFilterState() gets the latest values
            if (currentActiveSnapshot) {
                saveSnapshot(currentActiveSnapshot);
                // Update the UI to reflect the snapshot is still active
                updateGroupSnapshotInfo();
            }
            
            // Trigger change event to update any other listeners
            groupField.dispatchEvent(new Event('change'));
        }
        
        // Save group to date-based snapshot for caching
        function saveGroupToDateSnapshot(groupList) {
            if (groupList.length === 0) return;
            
            // Create snapshot name with today's date
            const today = new Date();
            const months = ['January', 'February', 'March', 'April', 'May', 'June',
                          'July', 'August', 'September', 'October', 'November', 'December'];
            let snapshotName = `${months[today.getMonth()]} ${String(today.getDate()).padStart(2, '0')}, ${today.getFullYear()}`;
            
            const snapshots = loadSnapshots();
            
            // Check if a snapshot with this name already exists and update it, or create new one
            let snapshotId = Object.keys(snapshots).find(id => snapshots[id].name === snapshotName);
            
            if (!snapshotId) {
                // Create new snapshot with next available ID
                snapshotId = getNextSnapshotId(snapshots);
            }
            
            // Save as a snapshot
            const filterState = getCurrentFilterState(snapshotName);
            filterState.groupParticipants = groupList;
            snapshots[snapshotId] = filterState;
            saveSnapshots(snapshots);
            
            // Set this snapshot as active
            currentActiveSnapshot = snapshotId;
            updateListTitle();
            
            console.log(`💾 Auto-saved group selection to snapshot: ${snapshotName} (ID: ${snapshotId})`);
        }
        
        // Sync checkboxes based on group field (case insensitive)
        function syncCheckboxesWithGroup() {
            const groupField = document.getElementById('group');
            if (!groupField) return;
            
            const groupList = groupField.value.split(',').map(name => name.trim()).filter(name => name);
            const groupListLower = groupList.map(name => name.toLowerCase());
            const checkboxes = document.querySelectorAll('.columns-checkbox');
            
            checkboxes.forEach(checkbox => {
                const participantName = checkbox.dataset.name;
                const participantNameLower = participantName.toLowerCase();
                checkbox.checked = groupListLower.includes(participantNameLower);
            });
        }
        
        // Format group field names: capitalize first letter, lowercase rest, alphabetical order
        function formatGroupFieldNames() {
            const groupField = document.getElementById('group');
            if (!groupField) return;
            
            const names = groupField.value.split(',')
                .map(name => name.trim())
                .filter(name => name.length > 0)
                .map(name => {
                    // Capitalize first letter, lowercase the rest
                    return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
                })
                .sort(); // Alphabetical order
            
            groupField.value = names.join(', ');
            
            // Update group participants set and trigger related updates
            updateGroupCount();
            updateGroupHighlighting();
            saveGroupParticipants();
        }
        
        // Render table view
        function renderTableView(data) {
            const tableHeader = document.getElementById('table-header');
            const tableBody = document.getElementById('table-body');
            
            // Check if data is valid
            if (!data || data.length === 0) {
                console.error('No data provided to renderTableView');
                return;
            }
            
            // Get headers from first row
            const headers = Object.keys(data[0] || {});

            // Filter out columns that are empty for every row (omit empty columns) and unwanted columns
            const visibleHeaders = headers.filter(header => {
                // Skip Preview column
                if (header.toLowerCase() === 'preview') {
                    return false;
                }
                
                // If any row has a non-empty value for this header, keep it
                return data.some(row => {
                    if (!row) return false;
                    const v = row[header];
                    if (v === null || v === undefined) return false;
                    if (typeof v === 'string') return v.trim().length > 0;
                    // non-string values (numbers, booleans) count as present
                    return true;
                });
            });

            // Fallback to original headers if filtering removed everything
            const headersToRender = (visibleHeaders && visibleHeaders.length > 0) ? visibleHeaders : headers;
            
            // Create table header
            tableHeader.innerHTML = '';
            const headerRow = document.createElement('tr');
            
            headersToRender.forEach(header => {
                const th = document.createElement('th');
                th.style.cursor = 'pointer';
                th.style.userSelect = 'none';
                th.style.position = 'relative';
                
                // Add click handler for sorting
                th.addEventListener('click', () => sortBy(header));
                
                // Add header text and sort arrow
                const headerText = document.createElement('span');
                headerText.textContent = formatFieldName(header);
                th.appendChild(headerText);
                
                // Add sort arrow if this is the current sort column
                if (currentSortColumn === header) {
                    const arrow = document.createElement('span');
                    arrow.innerHTML = currentSortOrder === 'asc' ? ' ↑' : ' ↓';
                    arrow.style.marginLeft = '4px';
                    arrow.style.fontSize = '12px';
                    th.appendChild(arrow);
                }
                
                headerRow.appendChild(th);
            });
            
            // Add checkbox column header at the beginning
            const checkboxTh = document.createElement('th');
            checkboxTh.style.width = '40px';
            checkboxTh.style.textAlign = 'center';
            headerRow.insertBefore(checkboxTh, headerRow.firstChild);

            // Preview column removed
            
            // Add menu column header at the end
            const menuTh = document.createElement('th');
            menuTh.style.width = '50px';
            menuTh.style.textAlign = 'center';
            headerRow.appendChild(menuTh);
            
            tableHeader.appendChild(headerRow);
            
            // Create table body
            tableBody.innerHTML = '';
            const isMetaList = getHash().list === 'all';
            
            data.forEach(row => {
                if (!row) return; // Skip null/undefined rows
                const tr = document.createElement('tr');
                tr.dataset.participantName = getParticipantName(row);

                // No row-level href navigation: links will be created only for @mentions and https:// URLs inside cells
                
                // Add row-level click handling variables
                let mouseDownTime = 0;
                let mouseDownPos = { x: 0, y: 0 };
                let savedSelectionOnMouseDown = null;
                
                // Track mouse down on the row to detect selection attempts and capture selection
                tr.addEventListener('mousedown', (e) => {
                    mouseDownTime = Date.now();
                    mouseDownPos = { x: e.clientX, y: e.clientY };
                    
                    // Capture any existing selection immediately on mousedown
                    const selection = window.getSelection();
                    if (selection.rangeCount > 0 && selection.toString().length > 0) {
                        savedSelectionOnMouseDown = selection.getRangeAt(0).cloneRange();
                    } else {
                        savedSelectionOnMouseDown = null;
                    }
                });
                
                // Add row-level click event to toggle expanded state
                tr.addEventListener('click', (e) => {
                    // Handle meta list navigation first
                    if (isMetaList && row.List) {
                        const clickTime = Date.now();
                        const timeDiff = clickTime - mouseDownTime;
                        const distance = Math.sqrt(
                            Math.pow(e.clientX - mouseDownPos.x, 2) + 
                            Math.pow(e.clientY - mouseDownPos.y, 2)
                        );
                        
                        // Only navigate if it's a quick click (not text selection)
                        if (timeDiff <= 200 && distance <= 5) {
                            setURLHashParam('list', row.List);
                            updateParticipantListTitle(row.Title || row.List);
                            return;
                        }
                    }
                    
                    const clickTime = Date.now();
                    const timeDiff = clickTime - mouseDownTime;
                    const distance = Math.sqrt(
                        Math.pow(e.clientX - mouseDownPos.x, 2) + 
                        Math.pow(e.clientY - mouseDownPos.y, 2)
                    );
                    
                    // Don't toggle if this appears to be the end of a text selection
                    // (long press or mouse movement suggests selection intent)
                    if (timeDiff > 200 || distance > 5) {
                        return;
                    }

                    // No row-level navigation here; anchors inside cells handle navigation.
                    
                    // Toggle expanded class for all cells in this row
                    const allCellsInRow = tr.querySelectorAll('td');
                    allCellsInRow.forEach(cell => {
                        cell.classList.toggle('expanded');
                    });
                    
                    // Restore selection that was captured on mousedown
                    if (savedSelectionOnMouseDown) {
                        const selection = window.getSelection();
                        setTimeout(() => {
                            selection.removeAllRanges();
                            selection.addRange(savedSelectionOnMouseDown);
                        }, 0);
                    }
                });
                
                // Add clickable functionality for meta list
                if (isMetaList && row.List) {
                    tr.style.cursor = 'pointer';
                    tr.title = `Click to view data from: ${row.Title || row.List}`;
                }
                
                // Add checkbox column first
                const checkboxTd = document.createElement('td');
                checkboxTd.style.textAlign = 'center';
                checkboxTd.style.verticalAlign = 'middle';
                checkboxTd.style.padding = '8px';
                checkboxTd.style.position = 'relative';
                
                const name = getParticipantName(row);
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'columns-checkbox';
                checkbox.dataset.name = name;
                checkbox.style.width = '18px';
                checkbox.style.height = '18px';
                checkbox.style.cursor = 'pointer';
                checkbox.style.margin = '0';
                checkbox.style.display = 'inline-block';
                checkbox.style.position = 'relative';
                checkbox.style.zIndex = '10';
                
                // Add event listener with capture phase to occur before row click
                checkbox.addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevent row click
                    e.stopImmediatePropagation(); // Stop all other event handlers
                }, true);
                
                checkbox.addEventListener('change', function(e) {
                    e.stopPropagation(); // Prevent row click
                    handleCheckboxChange(this.dataset.name, this.checked);
                });
                
                // Prevent row click when clicking anywhere in the checkbox cell
                checkboxTd.addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevent row click
                    e.stopImmediatePropagation(); // Stop all other event handlers
                });
                
                checkboxTd.appendChild(checkbox);
                tr.appendChild(checkboxTd);

                // Preview column removed
                
                // Add data columns
                headersToRender.forEach(header => {
                    const td = document.createElement('td');
                    const rawVal = row[header] || '';

                    // If the value already contains an anchor tag, render it as HTML
                    if (typeof rawVal === 'string' && /<a\s+href=/i.test(rawVal)) {
                        td.innerHTML = rawVal;
                        // If there are anchors inside, prevent their clicks from bubbling to the row
                        td.querySelectorAll('a').forEach(a => {
                            a.addEventListener('click', (e) => {
                                e.stopPropagation();
                            });
                        });
                    } else if (typeof rawVal === 'string') {
                        // Tokenize the string and only convert @mentions and https:// URLs into anchors
                        const tokens = rawVal.split(/(\s+)/); // keep whitespace tokens
                        tokens.forEach(token => {
                            if (!token) return;
                            // URL starting with https:// or http://
                            const urlMatch = token.match(/^(https?:\/\/[^\s"'<>]+)/i);
                            const atMatch = token.match(/^@([a-zA-Z0-9_\-\.]+)/);
                            // Check for plain GitHub username pattern (alphanumeric, hyphens, underscores, dots)
                            const plainUsernameMatch = token.match(/^([a-zA-Z0-9_\-\.]+)$/);

                            if (urlMatch) {
                                const url = urlMatch[0];
                                const a = document.createElement('a');
                                a.href = url;
                                a.target = '_blank';
                                a.rel = 'noopener noreferrer';
                                a.addEventListener('click', (e) => e.stopPropagation());
                                
                                // Check if this is a GitHub URL and extract username
                                const githubMatch = url.match(/https?:\/\/github\.com\/([^\/\?\#]+)/i);
                                if (githubMatch) {
                                    const username = githubMatch[1];
                                    // Display as @username format and link to GitHub profile
                                    a.textContent = `@${username}`;
                                    a.href = `https://github.com/${encodeURIComponent(username)}`;
                                    a.style.color = '#0969da'; // GitHub blue color
                                    a.style.fontWeight = '500';
                                } else {
                                    // Regular URL - truncate display text to 50 characters with ellipsis
                                    const displayText = token.length > 50 ? token.substring(0, 50) + '...' : token;
                                    a.textContent = displayText;
                                }
                                
                                td.appendChild(a);
                                
                                // Add preview for URLs in Name/Title column
                                if (header.toLowerCase() === 'name' || header.toLowerCase() === 'title') {
                                    const previewId = 'preview_' + Math.random().toString(36).substr(2, 9);
                                    const previewDiv = document.createElement('div');
                                    previewDiv.id = previewId;
                                    previewDiv.style.marginTop = '6px';
                                    previewDiv.style.maxWidth = '160px';
                                    td.appendChild(previewDiv);
                                    
                                    // Generate preview if getSitePreview function exists
                                    if (typeof getSitePreview === 'function') {
                                        try {
                                            getSitePreview(urlMatch[0], previewId);
                                        } catch (err) {
                                            // ignore preview errors
                                        }
                                    }
                                }
                            } else if (atMatch) {
                                const handle = atMatch[1];
                                const a = document.createElement('a');
                                // Link @handles to GitHub profile (assuming GitHub usernames)
                                a.href = `https://github.com/${encodeURIComponent(handle)}`;
                                a.textContent = token;
                                a.target = '_blank';
                                a.rel = 'noopener noreferrer';
                                a.style.color = '#0969da'; // GitHub blue color
                                a.style.fontWeight = '500';
                                a.addEventListener('click', (e) => e.stopPropagation());
                                td.appendChild(a);
                            } else if (token.includes('github.com/') && /github/i.test(header)) {
                                // Handle values containing github.com/ - extract username and add @ prefix
                                const githubPathMatch = token.match(/github\.com\/([a-zA-Z0-9_\-\.]+)/i);
                                if (githubPathMatch) {
                                    const username = githubPathMatch[1];
                                    const a = document.createElement('a');
                                    a.href = `https://github.com/${encodeURIComponent(username)}`;
                                    a.textContent = `@${username}`; // Add @ prefix to extracted username
                                    a.target = '_blank';
                                    a.rel = 'noopener noreferrer';
                                    a.style.color = '#0969da'; // GitHub blue color
                                    a.style.fontWeight = '500';
                                    a.addEventListener('click', (e) => e.stopPropagation());
                                    td.appendChild(a);
                                } else {
                                    // Fallback to regular text if username extraction fails
                                    td.appendChild(document.createTextNode(token));
                                }
                            } else if (plainUsernameMatch && 
                                      plainUsernameMatch[1].length >= 3 && 
                                      plainUsernameMatch[1].length <= 39 && 
                                      /^[a-zA-Z0-9]/.test(plainUsernameMatch[1]) && 
                                      /[a-zA-Z0-9]$/.test(plainUsernameMatch[1]) &&
                                      /github/i.test(header)) {
                                // Handle plain GitHub usernames only in GitHub-related columns
                                const username = plainUsernameMatch[1];
                                const a = document.createElement('a');
                                a.href = `https://github.com/${encodeURIComponent(username)}`;
                                a.textContent = `@${username}`; // Add @ prefix
                                a.target = '_blank';
                                a.rel = 'noopener noreferrer';
                                a.style.color = '#0969da'; // GitHub blue color
                                a.style.fontWeight = '500';
                                a.addEventListener('click', (e) => e.stopPropagation());
                                td.appendChild(a);
                            } else {
                                // Regular text (including whitespace)
                                td.appendChild(document.createTextNode(token));
                            }
                        });
                    } else {
                        // Non-string values (numbers, null, etc.)
                        td.textContent = rawVal;
                    }

                    tr.appendChild(td);
                });
                
                // Preview population code removed

                // Add menu column last (using same approach as column/gallery views)
                const menuTd = document.createElement('td');
                menuTd.style.textAlign = 'center';
                menuTd.style.verticalAlign = 'middle';
                menuTd.style.padding = '8px 12px';
                menuTd.style.position = 'relative';
                menuTd.style.width = '50px';
                menuTd.style.minWidth = '50px';
                menuTd.style.zIndex = '100';
                
                menuTd.innerHTML = `
                    <div class="columns-menu">
                        ⋯
                        <div class="columns-menu-dropdown">
                            <div class="columns-menu-item">
                                <a href="https://model.earth/projects/hub/#search=${encodeURIComponent(name)}" target="_blank">View Projects</a>
                            </div>
                        </div>
                    </div>
                `;
                
                // Add the same 3-dot menu event listener as column/gallery views
                const menu = menuTd.querySelector('.columns-menu');
                if (menu) {
                    menu.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const dropdown = this.querySelector('.columns-menu-dropdown');
                        // Close other dropdowns
                        document.querySelectorAll('.columns-menu-dropdown').forEach(d => {
                            if (d !== dropdown) d.style.display = 'none';
                        });
                        // Toggle this dropdown
                        dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
                    });
                    
                    // Add event listener to menu items to close dropdown when clicked
                    const menuItems = menu.querySelectorAll('.columns-menu-item');
                    menuItems.forEach(item => {
                        item.addEventListener('click', function() {
                            const dropdown = menu.querySelector('.columns-menu-dropdown');
                            if (dropdown) {
                                dropdown.style.display = 'none';
                            }
                        });
                    });
                }
                
                tr.appendChild(menuTd);
                
                tableBody.appendChild(tr);
            });
            
            // Sync checkboxes after rendering table
            setTimeout(syncCheckboxesWithGroup, 10);
            
        }
        
        // Get team class based on team value (checks all teams in comma-separated list)
        function getTeamClass(teamString) {
            if (!teamString) return 'team-default';
            
            // Split by comma and check each team
            const teams = teamString.split(',').map(team => team.trim().toLowerCase());
            
            // Check for team keywords in order of priority
            for (const team of teams) {
                if (team.includes('js')) return 'team-js';
                if (team.includes('ml')) return 'team-ml';
                if (team.includes('react')) return 'team-react';
                if (team.includes('io')) return 'team-io';
                if (team.includes('ai')) return 'team-ai';
                if (team.includes('flask')) return 'team-flask';
                if (team.includes('suite')) return 'team-suite';
                if (team.includes('us')) return 'team-us';
                if (team.includes('auth')) return 'team-auth';
                if (team.includes('discord')) return 'team-discord';
            }
            
            return 'team-default';
        }
        
        // Get all matching team classes for a participant (for filtering)
        function getAllTeamClasses(teamString) {
            console.log('getAllTeamClasses called with:', teamString);
            if (!teamString) {
                console.log('No team string provided, using default');
                return ['team-default'];
            }
            
            const matchingTeams = [];
            const teams = teamString.split(',').map(team => team.trim().toLowerCase());
            console.log('Teams after processing:', teams);
            
            // Check each team and collect all matches
            for (const team of teams) {
                if (team.includes('js')) matchingTeams.push('team-js');
                else if (team.includes('ml')) matchingTeams.push('team-ml');
                else if (team.includes('react')) matchingTeams.push('team-react');
                else if (team.includes('io')) matchingTeams.push('team-io');
                else if (team.includes('ai')) matchingTeams.push('team-ai');
                else if (team.includes('flask')) matchingTeams.push('team-flask');
                else if (team.includes('suite')) matchingTeams.push('team-suite');
                else if (team.includes('us')) matchingTeams.push('team-us');
                else if (team.includes('auth')) matchingTeams.push('team-auth');
                else if (team.includes('discord')) matchingTeams.push('team-discord');
            }
            
            const result = matchingTeams.length > 0 ? matchingTeams : ['team-default'];
            console.log('Team detection result:', result);
            return result;
        }
        
        // Generate team legend
        function generateTeamLegend(data) {
            console.log('generateTeamLegend called with data:', data.length, 'items');
            const teamLegend = document.getElementById('team-legend');
            const legendItems = document.getElementById('legend-items');
            
            // Check if data is valid
            if (!data || data.length === 0) {
                console.log('No data provided, hiding team legend');
                teamLegend.style.display = 'none';
                return;
            }
            
            // Check if Team column exists in the data
            const hasTeamColumn = data.length > 0 && data[0].hasOwnProperty('Team');
            if (!hasTeamColumn) {
                console.log('No Team column found in data, hiding team legend');
                teamLegend.style.display = 'none';
                return;
            }
            
            // Get unique teams from data (collect all team classes for each participant)
            const teams = new Set();
            data.forEach((participant, index) => {
                if (!participant) return; // Skip null/undefined participants
                console.log(`Participant ${index} - Team field:`, participant.Team);
                const teamClasses = getAllTeamClasses(participant.Team);
                teamClasses.forEach(teamClass => teams.add(teamClass));
            });
            
            console.log('Unique teams found:', Array.from(teams));
            
            // Create legend items
            legendItems.innerHTML = '';
            
            // Add "Show All" button as first item (active by default)
            const showAllItem = document.createElement('div');
            showAllItem.className = 'legend-item active';
            showAllItem.id = 'clear-team-filter';
            showAllItem.innerHTML = `
                <div class="legend-color" style="background: #ddd;"></div>
                <span>Show All</span>
            `;
            showAllItem.addEventListener('click', clearTeamFilter);
            legendItems.appendChild(showAllItem);
            
            // Add team filter buttons
            console.log('Creating team filter buttons for teams:', Array.from(teams));
            teams.forEach(teamClass => {
                const teamInfo = Object.values(teamColors).find(t => t.class === teamClass) || teamColors.default;
                console.log(`Creating filter for team: ${teamClass}, info:`, teamInfo);
                
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                legendItem.dataset.team = teamClass;
                legendItem.innerHTML = `
                    <div class="legend-color" style="background: ${teamInfo.color};"></div>
                    <span>${teamInfo.name}</span>
                `;
                
                legendItem.addEventListener('click', () => filterByTeam(teamClass));
                legendItems.appendChild(legendItem);
                console.log('Added team filter button:', teamInfo.name);
            });
            
            // Always show team legend if teams are detected (even if only one team)
            teamLegend.style.display = teams.size > 0 ? 'block' : 'none';
            
            // Restore team filter highlighting from storage
            restoreTeamFilterHighlighting();
        }
        
        // Restore team filter highlighting when recalled from browser storage
        function restoreTeamFilterHighlighting() {
            if (currentTeamFilter) {
                console.log('Restoring team filter highlighting for:', currentTeamFilter);
                
                // Clear all active states first
                document.querySelectorAll('.legend-item').forEach(item => {
                    item.classList.remove('active');
                });
                
                // Find and highlight the matching team legend item
                const matchingItem = document.querySelector(`.legend-item[data-team="${currentTeamFilter}"]`);
                if (matchingItem) {
                    matchingItem.classList.add('active');
                    console.log('Team filter highlighting restored for:', currentTeamFilter);
                } else {
                    console.log('No matching legend item found for team filter:', currentTeamFilter);
                }
            } else {
                // No team filter active, highlight "Show All"
                document.querySelectorAll('.legend-item').forEach(item => {
                    item.classList.remove('active');
                });
                const showAllItem = document.getElementById('clear-team-filter');
                if (showAllItem) {
                    showAllItem.classList.add('active');
                }
            }
        }
        
        // Filter by team
        function filterByTeam(teamClass) {
            // If clicking on the already selected team, clear the filter
            if (currentTeamFilter === teamClass) {
                clearTeamFilter();
                return;
            }
            
            currentTeamFilter = teamClass;
            
            // Clear active snapshot since filters changed manually
            clearActiveSnapshot();
            
            // Save team filter preference to localStorage
            localStorage.setItem(getListStorageKey('participantsTeamFilter'), teamClass);
            
            // Update legend active state
            document.querySelectorAll('.legend-item').forEach(item => {
                item.classList.toggle('active', item.dataset.team === teamClass);
            });
            
            // Remove active state from "Show All" button
            const showAllButton = document.getElementById('clear-team-filter');
            if (showAllButton) {
                showAllButton.classList.remove('active');
            }
            
            // Apply all filters (team + status)
            applyAllFilters();
        }
        
        // Clear team filter
        function clearTeamFilter() {
            currentTeamFilter = null;
            
            // Clear active snapshot since filters changed manually
            clearActiveSnapshot();
            
            // Remove team filter preference from localStorage
            localStorage.removeItem(getListStorageKey('participantsTeamFilter'));
            
            // Update legend active state
            document.querySelectorAll('.legend-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Make "Show All" button active
            const showAllButton = document.getElementById('clear-team-filter');
            if (showAllButton) {
                showAllButton.classList.add('active');
            }
            
            // Apply all filters (status only now)
            applyAllFilters();
        }
        
        // Render gallery view
        function renderGalleryView(data) {
            renderGalleryCards(data);
        }
        
        // Render gallery cards
        function renderGalleryCards(data) {
            const container = document.getElementById('participants-gallery-grid');
            container.innerHTML = '';
            
            // Check if data is valid
            if (!data || data.length === 0) {
                console.error('No data provided to renderGalleryCards');
                return;
            }
            
            const isMetaList = getHash().list === 'all';
            
            let imageCount = 0;
            data.forEach(participant => {
                if (!participant) return; // Skip null/undefined participants
                
                // Extract image paths from participant data
                const imagePaths = extractImagePaths(participant);
                
                // Only display first 12 items with images, or all items if no images found in any
                if (imagePaths.length > 0 && imageCount >= 12) return;
                if (imagePaths.length > 0) imageCount++;
                
                const card = document.createElement('div');
                const teamClass = getTeamClass(participant.Team);
                card.className = `gallery-card ${teamClass}`;
                
                // Get TopFields for dynamic display
                const topFields = getCurrentTopFields();
                const firstTopField = topFields && topFields.length > 0 ? topFields[0] : null;
                
                const name = getParticipantName(participant, firstTopField);
                card.dataset.participantName = name;
                
                // Get the actual field name being used as title
                const titleFieldName = getTitleFieldName(participant, firstTopField);
                
                // Add clickable functionality for meta list
                if (isMetaList && participant.List) {
                    card.style.cursor = 'pointer';
                    card.title = `Click to view data from: ${participant.Title || participant.List}`;
                    card.addEventListener('click', () => {
                        setURLHashParam('list', participant.List);
                        updateParticipantListTitle(participant.Title || participant.List);
                    });
                }
                
                // Set background image if available
                if (imagePaths.length > 0) {
                    card.style.backgroundImage = `url(${imagePaths[0]})`;
                    card.style.backgroundSize = 'cover';
                    card.style.backgroundPosition = 'center';
                    card.style.backgroundRepeat = 'no-repeat';
                    card.classList.add('has-background-image');
                }
                
                // Generate field display HTML using TopFields or fallback
                const fieldDisplayHTML = createFieldDisplayHTML(participant, topFields, true, titleFieldName);
                
                card.innerHTML = `
                    <div class="columns-menu">
                        ⋯
                        <div class="columns-menu-dropdown">
                            <div class="columns-menu-item">
                                <a href="https://model.earth/projects/hub/#search=${encodeURIComponent(name)}" target="_blank">View Projects</a>
                            </div>
                        </div>
                    </div>
                    <div class="gallery-content">
                        <div class="gallery-name">
                            <input type="checkbox" class="columns-checkbox" data-name="${name}">
                            ${name}
                        </div>
                        ${fieldDisplayHTML}
                    </div>
                    <button class="gallery-toggle-btn" onclick="toggleGalleryTextMode(this.parentElement)" title="Show info">
                        <i data-feather="info" style="width: 20px; height: 20px; stroke-width: 2.5px;"></i>
                    </button>
                `;
                
                container.appendChild(card);
                
                // Add checkbox event listener
                const checkbox = card.querySelector('.columns-checkbox');
                if (checkbox) {
                    checkbox.addEventListener('change', function(e) {
                        e.stopPropagation(); // Prevent card click
                        handleCheckboxChange(this.dataset.name, this.checked);
                    });
                }
                
                // Add 3-dot menu event listener
                const menu = card.querySelector('.columns-menu');
                if (menu) {
                    menu.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const dropdown = this.querySelector('.columns-menu-dropdown');
                        // Close other dropdowns
                        document.querySelectorAll('.columns-menu-dropdown').forEach(d => {
                            if (d !== dropdown) d.style.display = 'none';
                        });
                        // Toggle this dropdown
                        dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
                    });
                    
                    // Add event listener to menu items to close dropdown when clicked
                    const menuItems = menu.querySelectorAll('.columns-menu-item');
                    menuItems.forEach(item => {
                        item.addEventListener('click', function() {
                            const dropdown = menu.querySelector('.columns-menu-dropdown');
                            if (dropdown) {
                                dropdown.style.display = 'none';
                            }
                        });
                    });
                }
            });
            
            // Sync checkboxes after rendering gallery
            setTimeout(syncCheckboxesWithGroup, 10);
            
            // Feather icons will be initialized by nav.js
        }
        
        // Sort functionality
        function generateSortDropdown() {
            const sortItems = document.getElementById('sort-items');
            if (!allRowsData || !allRowsData.length) {
                // Show helpful message when no data is available
                sortItems.innerHTML = '<div class="no-data-message" style="padding: 10px; text-align: center; color: #666; font-style: italic;">Data is loading, please wait...</div>';
                return;
            }
            
            // Get available columns from data
            const columns = Object.keys(allRowsData[0]);
            
            // Add "Rows" as first option (original order)
            const sortOptions = ['Rows', ...columns];
            
            sortItems.innerHTML = '';
            sortOptions.forEach(column => {
                const sortItem = document.createElement('div');
                sortItem.className = 'sort-item';
                sortItem.dataset.column = column;
                
                const isActive = currentSortColumn === column;
                if (isActive) {
                    sortItem.classList.add('active');
                }
                
                const arrow = currentSortOrder === 'asc' ? '↑' : '↓';
                sortItem.innerHTML = `
                    <span>${column}</span>
                    <span class="sort-arrow">${isActive ? arrow : ''}</span>
                `;
                
                sortItem.addEventListener('click', () => sortBy(column));
                sortItems.appendChild(sortItem);
            });
        }
        
        function sortBy(column) {
            // If clicking the same column, toggle order
            if (currentSortColumn === column) {
                currentSortOrder = currentSortOrder === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortColumn = column;
                currentSortOrder = 'asc';
            }
            
            // Clear active snapshot since sort changed manually
            clearActiveSnapshot();
            
            // Save sort preferences
            localStorage.setItem(getListStorageKey('participantsSortColumn'), currentSortColumn);
            localStorage.setItem(getListStorageKey('participantsSortOrder'), currentSortOrder);
            
            // Note: sortby and sortorder are no longer automatically added to URL hash
            // They are only included in the "Full URL" feature
            
            // Apply sort to data
            applySortToData();
            
            // Update dropdown display
            generateSortDropdown();
            
            // Hide dropdown
            document.getElementById('sort-dropdown').style.display = 'none';
        }
        
        function applySortToData(shouldRerender = true) {
            let sortedData = [...allRowsData];
            
            if (currentSortColumn === 'Rows') {
                // Sort by original row order
                if (currentSortOrder === 'desc') {
                    sortedData.reverse();
                } else {
                    sortedData = [...originalDataOrder];
                }
            } else {
                // Sort by column data
                sortedData.sort((a, b) => {
                    let valueA = a[currentSortColumn] || '';
                    let valueB = b[currentSortColumn] || '';
                    
                    // Convert to string for comparison
                    valueA = valueA.toString().toLowerCase();
                    valueB = valueB.toString().toLowerCase();
                    
                    if (currentSortOrder === 'asc') {
                        return valueA.localeCompare(valueB);
                    } else {
                        return valueB.localeCompare(valueA);
                    }
                });
            }
            
            // Update global data
            allRowsData = sortedData;
            
            // Re-render all views with current filters applied (only if requested)
            if (shouldRerender) {
                applyAllFilters();
            }
        }
        
        function toggleSortDropdown() {
            const dropdown = document.getElementById('sort-dropdown');
            const statusDropdown = document.getElementById('status-dropdown');
            const isVisible = dropdown.style.display === 'block';
            
            // Close status dropdown first
            statusDropdown.style.display = 'none';
            
            if (isVisible) {
                dropdown.style.display = 'none';
            } else {
                generateSortDropdown();
                dropdown.style.display = 'block';
            }
        }
        
        // Status filtering functionality
        function generateStatusDropdown() {
            const statusItems = document.getElementById('status-items');
            if (!allRowsData || !allRowsData.length) {
                // Show helpful message when no data is available
                statusItems.innerHTML = '<div class="no-data-message" style="padding: 10px; text-align: center; color: #666; font-style: italic;">Data is loading, please wait...</div>';
                return;
            }
            
            // Get unique status values from data
            const statuses = new Set();
            allRowsData.forEach(participant => {
                const status = participant.Status || 'Unknown';
                statuses.add(status);
            });
            
            availableStatuses = ['All', ...Array.from(statuses).sort()];
            
            statusItems.innerHTML = '';
            availableStatuses.forEach(status => {
                const statusItem = document.createElement('div');
                statusItem.className = 'status-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'status-checkbox';
                checkbox.checked = selectedStatuses.has(status);
                checkbox.id = `status-${status}`;
                
                const label = document.createElement('label');
                label.className = 'status-label';
                label.htmlFor = `status-${status}`;
                label.textContent = status;
                
                statusItem.appendChild(checkbox);
                statusItem.appendChild(label);
                
                // Add checkbox change handler
                checkbox.addEventListener('change', (e) => {
                    handleStatusChange(status, e.target.checked);
                });
                
                // Add click handler for the label only
                label.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    checkbox.checked = !checkbox.checked;
                    handleStatusChange(status, checkbox.checked);
                });
                
                statusItems.appendChild(statusItem);
            });
        }
        
        function handleStatusChange(status, isChecked) {
            // Clear active snapshot since filters changed manually
            clearActiveSnapshot();
            
            // Set flag to prevent group parameter processing during status update
            isUpdatingStatus = true;
            
            if (status === 'All') {
                if (isChecked) {
                    // Check all statuses
                    selectedStatuses.clear();
                    selectedStatuses.add('All');
                    // Update all checkboxes
                    document.querySelectorAll('.status-checkbox').forEach(cb => {
                        cb.checked = cb.id === 'status-All';
                    });
                }
            } else {
                if (isChecked) {
                    // Uncheck "All" and add specific status
                    selectedStatuses.delete('All');
                    selectedStatuses.add(status);
                    document.getElementById('status-All').checked = false;
                } else {
                    // Remove specific status
                    selectedStatuses.delete(status);
                    
                    // If no specific statuses selected, check "All"
                    if (selectedStatuses.size === 0) {
                        selectedStatuses.add('All');
                        document.getElementById('status-All').checked = true;
                    }
                }
            }
            
            // Save to localStorage
            localStorage.setItem(getListStorageKey('participantsStatusFilter'), JSON.stringify(Array.from(selectedStatuses)));
            
            // Update URL hash parameter
            const statusArray = Array.from(selectedStatuses);
            if (statusArray.includes('All') || statusArray.length === 0) {
                // Remove hash parameter for default "All" status
                setURLHashParam('status', null);
            } else {
                setURLHashParam('status', statusArray.join(','));
            }
            
            // Update button text
            updateStatusButtonText();
            
            // Apply filters
            applyAllFilters();
            
            // Clear the flag after a short delay to allow hash changes to settle
            setTimeout(() => {
                isUpdatingStatus = false;
            }, 100);
        }
        
        function updateStatusButtonText() {
            const button = document.getElementById('status-toggle');
            const statusArray = Array.from(selectedStatuses);
            
            if (statusArray.includes('All') || statusArray.length === 0) {
                button.textContent = 'Status';
            } else if (statusArray.length === 1) {
                button.textContent = statusArray[0] + ' Only';
            } else {
                button.textContent = statusArray[0] + '...';
            }
        }
        
        function toggleStatusDropdown() {
            const dropdown = document.getElementById('status-dropdown');
            const sortDropdown = document.getElementById('sort-dropdown');
            const isVisible = dropdown.style.display === 'block';
            
            // Close sort dropdown first
            sortDropdown.style.display = 'none';
            
            if (isVisible) {
                dropdown.style.display = 'none';
            } else {
                generateStatusDropdown();
                dropdown.style.display = 'block';
            }
        }
        
        function applyAllFilters() {
            
            if (!allRowsData || allRowsData.length === 0) {
                console.warn('⚠️ applyAllFilters called but allRowsData is empty or undefined');
                return;
            }

            let filteredData = [...allRowsData];
            
            // Apply group participants filter first if active
            // This ensures team filtering can work on the group subset
            if (showOnlyGroup) {
                const beforeGroupFilter = filteredData.length;
                filteredData = filteredData.filter(participant => {
                    const name = getParticipantName(participant);
                    return Array.from(groupParticipants).some(groupName => 
                        groupName.toLowerCase() === name.toLowerCase()
                    );
                });
            }
            
            // Apply team filter if active (works on group-filtered results if group filter is active)
            if (currentTeamFilter) {
                console.log('🔍 Applying team filter:', currentTeamFilter);
                console.log(`🔍 Team filtering ${showOnlyGroup ? 'within group participants' : 'all participants'}`);
                const beforeTeamFilter = filteredData.length;
                filteredData = filteredData.filter(participant => {
                    const participantTeamClasses = getAllTeamClasses(participant.Team);
                    const passes = participantTeamClasses.includes(currentTeamFilter);
                    if (!passes) {
                        console.log('❌ Participant filtered out by team:', participant.Name || participant.name, 'Team:', participant.Team, 'Classes:', participantTeamClasses);
                    }
                    return passes;
                });
                console.log('📊 Team filter result:', beforeTeamFilter, '→', filteredData.length);
            } else {
                console.log('⏭️ Skipping team filter (no team selected)');
            }
            
            // Apply status filter last
            if (!selectedStatuses.has('All') && selectedStatuses.size > 0) {
                console.log('🔍 Applying status filter. Selected statuses:', Array.from(selectedStatuses));
                const beforeStatusFilter = filteredData.length;
                filteredData = filteredData.filter(participant => {
                    const status = participant.Status || 'Unknown';
                    const passes = selectedStatuses.has(status);
                    if (!passes) {
                        console.log('❌ Participant filtered out by status:', participant.Name || participant.name, 'Status:', status);
                    }
                    return passes;
                });
                console.log('📊 Status filter result:', beforeStatusFilter, '→', filteredData.length);
            } else {
                console.log('⏭️ Skipping status filter (All selected or no selection)');
            }
            
            // Update email list based on filtered data
            if (window.allExtractedEmails && window.allExtractedEmails.length > 0) {
                console.log('📧 Updating email list based on filtered data...');
                updateFilteredEmails(filteredData);
            }
            
            // Update results count with pagination
            console.log('📊 Updating results count with pagination...');
            updateResultsCount(filteredData);
            
            // Apply pagination to filtered data
            const paginatedData = paginateData(filteredData);
            console.log(`📄 Displaying page ${currentPage} with ${paginatedData.length} records`);
            
            // Render paginated data in all views
            console.log('🎨 Starting render process with', paginatedData.length, 'paginated participants');
            console.log('🔍 Sample of paginated data:', paginatedData.slice(0, 3));
            
            try {
                console.log('🏛️ Rendering column view...');
                renderColumnView(paginatedData);
                console.log('✅ Column view rendered successfully');
            } catch (error) {
                console.error('❌ Error rendering column view:', error);
                console.error('Stack trace:', error.stack);
                
                // Enhanced error reporting for call stack issues
                if (error.message && error.message.includes('Maximum call stack size exceeded')) {
                    const stackTrace = error.stack || '';
                    const stackLines = stackTrace.split('\n').filter(line => line.trim().length > 0);
                    const stackDepth = stackLines.length;
                    
                    let memoryInfo = '';
                    if (performance && performance.memory) {
                        const memory = performance.memory;
                        const usedMB = Math.round(memory.usedJSHeapSize / 1024 / 1024);
                        const totalMB = Math.round(memory.totalJSHeapSize / 1024 / 1024);
                        const limitMB = Math.round(memory.jsHeapSizeLimit / 1024 / 1024);
                        memoryInfo = ` Memory: ${usedMB}MB used, ${totalMB}MB total, ${limitMB}MB limit.`;
                    }
                    
                    console.error('❌ Column view call stack overflow - Stack depth:', stackDepth, 'frames.', memoryInfo);
                    appendStatusMessage(`<h4>Column View Error</h4><p>Maximum call stack size exceeded. Stack depth: ~${stackDepth} frames.${memoryInfo}</p>`, 'error');
                }
            }
            
            try {
                console.log('📊 Rendering table view...');
                renderTableView(paginatedData);
                console.log('✅ Table view rendered successfully');
            } catch (error) {
                console.error('❌ Error rendering table view:', error);
                console.error('Stack trace:', error.stack);
                
                // Enhanced error reporting for call stack issues
                if (error.message && error.message.includes('Maximum call stack size exceeded')) {
                    const stackTrace = error.stack || '';
                    const stackLines = stackTrace.split('\n').filter(line => line.trim().length > 0);
                    const stackDepth = stackLines.length;
                    
                    let memoryInfo = '';
                    if (performance && performance.memory) {
                        const memory = performance.memory;
                        const usedMB = Math.round(memory.usedJSHeapSize / 1024 / 1024);
                        const totalMB = Math.round(memory.totalJSHeapSize / 1024 / 1024);
                        const limitMB = Math.round(memory.jsHeapSizeLimit / 1024 / 1024);
                        memoryInfo = ` Memory: ${usedMB}MB used, ${totalMB}MB total, ${limitMB}MB limit.`;
                    }
                    
                    console.error('❌ Table view call stack overflow - Stack depth:', stackDepth, 'frames.', memoryInfo);
                    appendStatusMessage(`<h4>Table View Error</h4><p>Maximum call stack size exceeded. Stack depth: ~${stackDepth} frames.${memoryInfo}</p>`, 'error');
                }
            }
            
            try {
                console.log('🖼️ Rendering gallery view...');
                renderGalleryView(paginatedData);
                console.log('✅ Gallery view rendered successfully');
            } catch (error) {
                console.error('❌ Error rendering gallery view:', error);
                console.error('Stack trace:', error.stack);
                
                // Enhanced error reporting for call stack issues
                if (error.message && error.message.includes('Maximum call stack size exceeded')) {
                    const stackTrace = error.stack || '';
                    const stackLines = stackTrace.split('\n').filter(line => line.trim().length > 0);
                    const stackDepth = stackLines.length;
                    
                    let memoryInfo = '';
                    if (performance && performance.memory) {
                        const memory = performance.memory;
                        const usedMB = Math.round(memory.usedJSHeapSize / 1024 / 1024);
                        const totalMB = Math.round(memory.totalJSHeapSize / 1024 / 1024);
                        const limitMB = Math.round(memory.jsHeapSizeLimit / 1024 / 1024);
                        memoryInfo = ` Memory: ${usedMB}MB used, ${totalMB}MB total, ${limitMB}MB limit.`;
                    }
                    
                    console.error('❌ Gallery view call stack overflow - Stack depth:', stackDepth, 'frames.', memoryInfo);
                    appendStatusMessage(`<h4>Gallery View Error</h4><p>Maximum call stack size exceeded. Stack depth: ~${stackDepth} frames.${memoryInfo}</p>`, 'error');
                }
            }
            
            // Reapply group highlighting
            console.log('⏰ Scheduling group highlighting update in 100ms...');
            setTimeout(() => {
                console.log('🎨 Executing group highlighting update...');
                try {
                    updateGroupHighlighting();
                    console.log('✅ Group highlighting updated successfully');
                } catch (error) {
                    console.error('❌ Error updating group highlighting:', error);
                }
                // Update heatmap from filtered data (full filtered set, not just paginated)
                    try { updateParticipantsHeatmapFromData(filteredData); } catch (e) { console.debug('heatmap update failed', e); }
                    // Update per-state counts overlay as well
                    try { updateStateCountsFromData(filteredData); } catch (e) { console.debug('state counts update failed', e); }
            }, 100);
            
            console.log('🏁 applyAllFilters completed successfully');
        }
        
        // Switch between views
        function switchView(viewType) {
            currentView = viewType;
            
            // Save view preference to list-specific localStorage (view mode is list-based, not snapshot-based)
            localStorage.setItem(getListStorageKey('participantsViewMode'), viewType);
            
            // Update URL hash parameter (don't send 'column' since it's the default)
            if (viewType === 'column') {
                setURLHashParam('display', null); // Remove display parameter for column view
            } else {
                setURLHashParam('display', viewType);
            }
            
            // Hide all views
            document.getElementById('column-view').style.display = 'none';
            document.getElementById('table-view').style.display = 'none';
            document.getElementById('gallery-view').style.display = 'none';
            
            // Show selected view
            document.getElementById(viewType + '-view').style.display = 'block';
            
            // Update button states for expanded view
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(viewType + '-view-btn').classList.add('active');
            
            // Update button states for condensed view
            updateCondensedViewButtons();
            
            // Apply group highlighting after view switch
            setTimeout(() => updateGroupHighlighting(), 100);
            
            // If switching to gallery view and there's a saved team filter, restore it
            if (viewType === 'gallery' && currentTeamFilter && allRowsData.length > 0) {
                setTimeout(() => {
                    filterByTeam(currentTeamFilter);
                }, 150);
            }
        }
        
        // Group participants functionality
        function loadGroupParticipants() {
            // Check URL hash parameter first, then fallback to localStorage
            const stored = localStorage.getItem(getListStorageKey('groupParticipants'));
            const groupInput = document.getElementById('group');
            
            let groupString = '';
            if (stored && stored.trim()) {
                // Load from localStorage only (no hash loading)
                groupString = stored;
                console.log('💾 Loading group participants from localStorage:', stored);
            } else {
                console.log('ℹ️ No group participants found in localStorage');
            }
            
            if (groupString && groupInput) {
                // Format the group string with proper spacing (replace commas with ", ")
                const formattedGroupString = groupString.replace(/,/g, ', ');
                
                // Populate the field with the group string from localStorage or snapshot
                groupInput.value = formattedGroupString;
                console.log('✅ Populated group input field with:', formattedGroupString, '(from localStorage/snapshot)');
                // Scroll to the right to show the end of the text
                setTimeout(() => scrollGroupInputToRight(), 100);
                const parsedNames = groupString.split(',').map(name => name.trim()).filter(name => name);
                groupParticipants = new Set(parsedNames);
                
                // Validate names from localStorage or snapshot
                validateGroupNames(parsedNames);
                
                // When loading from localStorage/snapshot, check if the group filter was previously active
                // and restore that state (showOnlyGroup is already loaded from localStorage at startup)
                updateGroupToggleUI();
                console.log('🔄 Restored group participants from localStorage/snapshot');
            } else if (groupString && !groupInput) {
                console.log('⚠️ Group string found but input element not available:', groupString);
            } else if (!groupString && groupInput) {
                // No group data found, ensure field is cleared
                console.log('🧹 No group data found, clearing field and participants');
                groupInput.value = '';
                groupParticipants = new Set();
                hideGroupValidationMessage();
            }
            updateGroupCount();
            
            // Initialize previousGroupParam state
            previousGroupParam = getHash().group;
        }
        
        function scrollGroupInputToRight() {
            const groupInput = document.getElementById('group');
            groupInput.scrollLeft = groupInput.scrollWidth - groupInput.clientWidth;
        }
        
        function saveGroupParticipants() {
            const groupList = Array.from(groupParticipants).join(', ');
            localStorage.setItem(getListStorageKey('groupParticipants'), groupList);
            // Don't overwrite the input field value to preserve user's typing
            
            // Update visibility since we now have stored group participants
            updateGroupParticipantsVisibility();
        }
        
        // Removed updateGroupHashParam - no longer updating URL with group data
        
        function updateGroupCount() {
            const count = groupParticipants.size;
            document.getElementById('group-count').textContent = `(${count})`;
        }
        
        function updateGroupHighlighting() {
            // Remove existing highlighting
            document.querySelectorAll('.columns-group').forEach(el => {
                el.classList.remove('columns-group');
            });
            
            // Apply highlighting to group participants
            groupParticipants.forEach(name => {
                const elements = document.querySelectorAll(`[data-columns-name]`);
                elements.forEach(el => {
                    if (el.dataset.participantName.toLowerCase() === name.toLowerCase()) {
                        el.classList.add('columns-group');
                    }
                });
            });
        }
        
        function cleanHTMLFromNames(htmlString) {
            // Create a temporary DOM element to parse HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlString;
            
            // Extract all text content and collect names
            const extractedNames = [];
            
            // First, check if there are HTML elements with names
            const possibleNameElements = tempDiv.querySelectorAll('li, span, div, p, td, th');
            
            if (possibleNameElements.length > 0) {
                // Extract text from structured HTML elements in order
                possibleNameElements.forEach((element, index) => {
                    const text = element.textContent.trim();
                    if (text && text.length > 0) {
                        // Check if this element contains separators
                        if (text.includes(',') || text.includes(';') || text.includes('\n') || text.includes('\t')) {
                            // Split by separators if they exist within the element
                            const names = text.split(/[,;\n\t]/).map(name => name.trim()).filter(name => name.length > 0);
                            extractedNames.push(...names);
                        } else {
                            // Single name in this element
                            extractedNames.push(text);
                        }
                    }
                });
            }
            
            // Also check for any plain text content outside of HTML elements
            // Walk through all nodes to catch plain text between elements
            const walker = document.createTreeWalker(
                tempDiv,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let textNode;
            while (textNode = walker.nextNode()) {
                const text = textNode.textContent.trim();
                if (text && text.length > 0) {
                    // Split by separators and add to extracted names
                    const names = text.split(/[,;\n\t]/).map(name => name.trim()).filter(name => name.length > 0);
                    extractedNames.push(...names);
                }
            }
            
            // Remove duplicates (case-insensitive) and join with commas
            const uniqueNames = removeDuplicatesIgnoreCase(extractedNames);
            const result = uniqueNames.join(', ');
            
            console.log('🧹 Cleaned HTML from names:', htmlString.substring(0, 100) + '...', '→', result);
            return result;
        }
        
        // Helper function to remove duplicates ignoring case
        function removeDuplicatesIgnoreCase(names) {
            const seen = new Map();
            const result = [];
            
            names.forEach(name => {
                const lowerName = name.toLowerCase();
                if (!seen.has(lowerName)) {
                    seen.set(lowerName, name);
                    result.push(name);
                }
            });
            
            return result;
        }
        
        function processGroupInput() {
            const input = document.getElementById('group');
            let value = input.value;
            
            // Check if value contains HTML and clean it if necessary
            if (value.includes('<') && value.includes('>')) {
                value = cleanHTMLFromNames(value);
                // Update the input field with cleaned value
                input.value = value;
            }
            
            // Parse names from input and expand full names
            groupParticipants = new Set();
            const inputNames = [];
            const expandedNames = [];
            
            value.split(',').forEach(name => {
                const trimmed = name.trim();
                if (trimmed) {
                    inputNames.push(trimmed);
                    
                    // Check if name contains a space (full name)
                    if (trimmed.includes(' ')) {
                        const nameParts = trimmed.split(' ').filter(part => part.trim().length > 0);
                        if (nameParts.length >= 2) {
                            const firstName = nameParts[0];
                            const lastName = nameParts[nameParts.length - 1]; // Use last part in case of middle names
                            const lastInitial = lastName.charAt(0).toUpperCase();
                            
                            // Add both first name only and first name + last initial
                            expandedNames.push(firstName);
                            expandedNames.push(firstName + lastInitial);
                            groupParticipants.add(firstName);
                            groupParticipants.add(firstName + lastInitial);
                        } else {
                            // Single word with space somehow, treat as regular name
                            expandedNames.push(trimmed);
                            groupParticipants.add(trimmed);
                        }
                    } else {
                        // No space, regular name
                        expandedNames.push(trimmed);
                        groupParticipants.add(trimmed);
                    }
                }
            });
            
            // Remove duplicates (case-insensitive) from expanded names
            const uniqueExpandedNames = removeDuplicatesIgnoreCase(expandedNames);
            
            // Update groupParticipants with deduplicated names
            groupParticipants = new Set(uniqueExpandedNames);
            
            // Update the input field to show the deduplicated expanded names
            if (uniqueExpandedNames.length > 0) {
                input.value = uniqueExpandedNames.join(', ');
            }
            
            // Validate names against dataset (using all expanded names)
            validateGroupNames(Array.from(groupParticipants));
            
            // Save to storage and update URL hash
            saveGroupParticipants();
            updateGroupCount();
            updateGroupHighlighting();
            
            // Note: URL hash parameters for groups have been discontinued
            
            // Update active snapshot with current changes instead of clearing it
            if (currentActiveSnapshot) {
                saveSnapshot(currentActiveSnapshot);
                // Update the UI to reflect the snapshot is still active
                updateGroupSnapshotInfo();
            } else {
                // Auto-save to browser cache with date-based snapshot if no active snapshot
                if (uniqueExpandedNames.length > 0) {
                    saveGroupToDateSnapshot(uniqueExpandedNames);
                }
            }
            
            // If group filter is active, refresh the list to show/hide participants
            if (showOnlyGroup) {
                applyAllFilters();
            }
        }
        
        // Store not found names globally so button can access them
        let currentNotFoundNames = [];
        
        function validateGroupNames(inputNames) {
            if (!allRowsData || allRowsData.length === 0) {
                console.log('⏭️ Skipping group name validation - data not yet available');
                return;
            }
            
            if (inputNames.length === 0) {
                // Hide message if no names to validate
                hideGroupValidationMessage();
                currentNotFoundNames = [];
                return;
            }
            
            // Get all participant names from the dataset
            const datasetNames = allRowsData.map(participant => getParticipantName(participant));
            const datasetNamesLower = datasetNames.map(name => name.toLowerCase());
            
            // Find names that don't exist in the dataset
            const notFoundNames = inputNames.filter(inputName => {
                const inputNameLower = inputName.toLowerCase();
                return !datasetNamesLower.includes(inputNameLower);
            });
            
            // Store not found names for button access
            currentNotFoundNames = notFoundNames;
            
            // Show message if there are names not found
            if (notFoundNames.length > 0) {
                const message = `Not found in dataset: ${notFoundNames.join(', ')}`;
                console.warn('⚠️ ' + message);
                
                // Show a message to the user with remove button
                showGroupValidationMessage(message, true);
            } else {
                // Hide message if all names are valid
                hideGroupValidationMessage();
            }
        }
        
        function showGroupValidationMessage(message, showButton = false) {
            // Create or update validation message element
            let messageEl = document.getElementById('group-validation-message');
            if (!messageEl) {
                messageEl = document.createElement('div');
                messageEl.id = 'group-validation-message';
                messageEl.style.cssText = `
                    color: #d97706;
                    font-size: 12px;
                    margin-top: 4px;
                    padding: 4px 8px;
                    background: #fef3c7;
                    border: 1px solid #f59e0b;
                    border-radius: 4px;
                    display: none;
                `;
                
                // Insert after the group control
                const groupControl = document.getElementById('group-control');
                if (groupControl && groupControl.parentNode) {
                    groupControl.parentNode.insertBefore(messageEl, groupControl.nextSibling);
                }
            }
            
            // Clear existing content and add message
            messageEl.innerHTML = '';
            
            // Add message text
            const messageSpan = document.createElement('span');
            messageSpan.textContent = message;
            messageEl.appendChild(messageSpan);
            
            // Add remove button if requested
            if (showButton && currentNotFoundNames.length > 0) {
                const buttonSpan = document.createElement('span');
                buttonSpan.style.cssText = `
                    margin-left: 8px;
                `;
                
                const removeButton = document.createElement('button');
                removeButton.textContent = 'Remove Unfound';
                removeButton.style.cssText = `
                    background: #dc2626;
                    color: white;
                    border: none;
                    padding: 2px 6px;
                    border-radius: 3px;
                    font-size: 11px;
                    cursor: pointer;
                `;
                removeButton.onclick = removeUnfoundNames;
                
                buttonSpan.appendChild(removeButton);
                messageEl.appendChild(buttonSpan);
            }
            
            messageEl.style.display = 'block';
        }
        
        function hideGroupValidationMessage() {
            const messageEl = document.getElementById('group-validation-message');
            if (messageEl) {
                messageEl.style.display = 'none';
            }
        }
        
        function removeUnfoundNames() {
            if (currentNotFoundNames.length === 0) {
                return;
            }
            
            const input = document.getElementById('group');
            
            // Get current names from the groupParticipants set
            const validNames = Array.from(groupParticipants).filter(name => 
                !currentNotFoundNames.some(notFound => 
                    notFound.toLowerCase() === name.toLowerCase()
                )
            );
            
            // Update the input field and groupParticipants set
            input.value = validNames.join(', ');
            groupParticipants = new Set(validNames);
            
            // Clear the not found names array
            currentNotFoundNames = [];
            
            // Save to storage
            saveGroupParticipants();
            updateGroupCount();
            updateGroupHighlighting();
            
            // Update active snapshot with the changes
            if (currentActiveSnapshot) {
                console.log('🔄 Updating active snapshot after removing unfound names:', currentActiveSnapshot);
                saveSnapshot(currentActiveSnapshot);
                // Update the UI to reflect the snapshot is still active
                updateGroupSnapshotInfo();
            } else {
                // Auto-save to browser cache with date-based snapshot if no active snapshot
                if (validNames.length > 0) {
                    saveGroupToDateSnapshot(validNames);
                }
            }
            
            // Hide the validation message since we've removed the unfound names
            hideGroupValidationMessage();
            
            // Apply filters if group filter is active
            if (showOnlyGroup) {
                applyAllFilters();
            }
            
            console.log('✅ Removed unfound names and updated cache snapshot');
        }
        
        function toggleGroupFilter() {
            showOnlyGroup = !showOnlyGroup;
            
            // Clear active snapshot since filter changed manually
            clearActiveSnapshot();
            
            // Save state to localStorage
            localStorage.setItem(getListStorageKey('showOnlyGroup'), JSON.stringify(showOnlyGroup));
            
            // Note: Group toggle button does not alter URL hash
            // Hash is only updated when group participants are manually edited
            
            updateGroupToggleUI();
            
            // Apply all filters (includes group participant filtering)
            applyAllFilters();
        }
        
        function updateGroupToggleUI() {
            const toggle = document.getElementById('group-toggle');
            const toggleText = document.getElementById('group-toggle-text');
            
            // Get cached text choices or use defaults
            const cachedActiveText = localStorage.getItem(getListStorageKey('groupToggleActiveText')) || 'Focus';
            const cachedInactiveText = localStorage.getItem(getListStorageKey('groupToggleInactiveText')) || 'Highlight';
            
            if (showOnlyGroup) {
                toggle.classList.add('active');
                toggleText.textContent = cachedActiveText;
            } else {
                toggle.classList.remove('active');
                toggleText.textContent = cachedInactiveText;
            }
        }
        
        function shouldShowGroupParticipants() {
            // Check current list from hash
            const currentList = getHash().list;
            
            // Check if the current list supports groups (modelteam) AND it exists in fileSelect
            const isGroupList = Array.from(fileSelect.options).find(option => option.value === 'modelteam');
            const isCurrentlyOnGroupList = currentList === 'modelteam';
            
            // Only show if currently on a group-supporting list AND that list is available in fileSelect
            return isCurrentlyOnGroupList && isGroupList;
        }
        
        function updateGroupParticipantsVisibility() {
            const groupControl = document.getElementById('group-control');
            if (groupControl) {
                if (shouldShowGroupParticipants()) {
                    groupControl.style.display = 'block';
                } else {
                    groupControl.style.display = 'none';
                }
            }
        }
        
        // Data preprocessing functions for column name normalization
        function detectCommonPrefix(columns) {
            if (columns.length === 0) return '';
            
            // Find the shortest column name to limit prefix length
            const minLength = Math.min(...columns.map(col => col.length));
            if (minLength === 0) return '';
            
            let commonPrefix = '';
            
            // Check each character position
            for (let i = 0; i < minLength; i++) {
                const char = columns[0][i];
                
                // Check if all columns have the same character at this position
                const allMatch = columns.every(col => col[i] === char);
                
                if (allMatch) {
                    commonPrefix += char;
                } else {
                    break;
                }
            }
            
            // Only return prefix if it ends with an underscore or is substantial
            // and all columns would still have meaningful names after removal
            if (commonPrefix.length > 2 && 
                (commonPrefix.endsWith('_') || commonPrefix.length >= 4)) {
                
                // Verify all columns would have meaningful names after prefix removal
                const wouldBeValid = columns.every(col => {
                    const remaining = col.substring(commonPrefix.length);
                    return remaining.length > 0 && remaining !== '_';
                });
                
                if (wouldBeValid) {
                    return commonPrefix;
                }
            }
            
            return '';
        }
        
        // Add safety check to prevent infinite reprocessing
        let preprocessCallCount = 0;
        let lastPreprocessTime = 0;
        
        function preprocessParticipantData(participants) {
            if (!Array.isArray(participants) || participants.length === 0) {
                return participants;
            }
            
            // Safety check to prevent infinite loops
            const now = Date.now();
            if (now - lastPreprocessTime < 1000) { // If called within 1 second
                preprocessCallCount++;
                if (preprocessCallCount > 5) {
                    console.error('⚠️ preprocessParticipantData called too many times rapidly. Preventing infinite loop.');
                    return participants; // Return original data to break the loop
                }
            } else {
                preprocessCallCount = 0;
            }
            lastPreprocessTime = now;
            
            // preprocessParticipantData called (debug logs removed for production)
            return participants.map((participant, index) => {
                
                // Create a new object to maintain original data
                const processed = {};
                
                // Step 1: Get all column names
                const allColumns = Object.keys(participant);
                const commonPrefix = detectCommonPrefix(allColumns);
                
                // Step 2: Create a mapping of original to cleaned column names
                const columnMapping = {};
                allColumns.forEach(col => {
                    let cleanedName = col;
                    if (commonPrefix && col.startsWith(commonPrefix)) {
                        cleanedName = col.substring(commonPrefix.length);
                        // Ensure the cleaned name doesn't start with underscore
                        if (cleanedName.startsWith('_')) {
                            cleanedName = cleanedName.substring(1);
                        }
                    }
                    columnMapping[col] = cleanedName;
                });
                
                // Step 3: Identify ID columns and add them first (using cleaned names)
                const idColumns = [];
                const otherColumns = [];
                
                Object.entries(columnMapping).forEach(([originalKey, cleanedKey]) => {
                    if (cleanedKey === 'id' || cleanedKey.endsWith('_id') || cleanedKey.endsWith('ID') || cleanedKey === 'ID') {
                        idColumns.push({ original: originalKey, cleaned: cleanedKey });
                    } else {
                        otherColumns.push({ original: originalKey, cleaned: cleanedKey });
                    }
                });
                
                // Sort ID columns (id first, then others alphabetically)
                idColumns.sort((a, b) => {
                    if (a.cleaned === 'id') return -1;
                    if (b.cleaned === 'id') return 1;
                    return a.cleaned.localeCompare(b.cleaned);
                });
                
                // Step 4: Add ID columns first
                idColumns.forEach(({ original, cleaned }) => {
                    processed[cleaned] = participant[original];
                });
                
                // Step 5: Handle description -> title conversion
                const descriptionColumn = otherColumns.find(({ cleaned, original }) => 
                    cleaned === 'description' || 
                    original === 'project_description' ||
                    cleaned === 'project_description'
                );
                
                if (descriptionColumn && participant[descriptionColumn.original] !== undefined && 
                    participant[descriptionColumn.original] !== null && participant[descriptionColumn.original] !== '') {
                    processed.title = participant[descriptionColumn.original];
                    // Remove from otherColumns to avoid duplication
                    const index = otherColumns.indexOf(descriptionColumn);
                    if (index > -1) {
                        otherColumns.splice(index, 1);
                    }
                } else {
                    // Check for existing title
                    const titleColumn = otherColumns.find(({ cleaned }) => cleaned === 'title');
                    if (titleColumn && participant[titleColumn.original] !== undefined && 
                        participant[titleColumn.original] !== null && participant[titleColumn.original] !== '') {
                        processed.title = participant[titleColumn.original];
                        // Remove from otherColumns to avoid duplication
                        const index = otherColumns.indexOf(titleColumn);
                        if (index > -1) {
                            otherColumns.splice(index, 1);
                        }
                    }
                }
                
                // Step 6: Add Name column only if no existing name field is found
                // Check if there's already a name column in the data
                const existingNameColumn = otherColumns.find(({ cleaned }) => 
                    cleaned === 'name' || 
                    cleaned === 'participant_name' ||
                    cleaned === 'full_name' ||
                    cleaned === 'display_name'
                );
                
                // Only add a Name column if no existing name column is found
                if (!existingNameColumn) {
                    let nameField = null;
                    
                    if (processed.title && processed.title !== '') {
                        // Use title field as name
                        nameField = processed.title;
                    } else if (otherColumns.length > 0) {
                        // Use first non-ID column as name
                        const firstColumn = otherColumns[0];
                        nameField = participant[firstColumn.original] || '';
                        console.log('Name field logic - using column:', firstColumn.cleaned, 'value:', nameField);
                    } else {
                        // Final fallback
                        nameField = 'Unknown';
                    }
                    
                    // Add as "Name" column (not "displayName")
                    processed.Name = nameField;
                }
                
                // Step 7: Add remaining columns with cleaned names
                otherColumns.forEach(({ original, cleaned }) => {
                    processed[cleaned] = participant[original];
                });
                
                return processed;
            });
        }
        
        function getParticipantName(participant, topFieldsFirstField = null) {
            // Helper function to get the appropriate name field from a participant object
            // Prioritizes TopFields first field if provided, then checks for various name field variations
            if (!participant || typeof participant !== 'object') {
                return 'Unknown';
            }
            
            // Check TopFields first field if provided
            if (topFieldsFirstField && participant[topFieldsFirstField] !== undefined && 
                participant[topFieldsFirstField] !== null && participant[topFieldsFirstField] !== '') {
                return participant[topFieldsFirstField];
            }
            
            const nameFields = ['Name', 'name', 'participant_name', 'full_name', 'display_name', 'displayName'];
            
            for (const field of nameFields) {
                if (participant[field] !== undefined && participant[field] !== null && participant[field] !== '') {
                    return participant[field];
                }
            }
            
            return 'Unknown';
        }
        
        // Raw data functionality
        let originalRawData = null;
        let rawDataVisible = false;
        
        function toggleRawData() {
            rawDataVisible = !rawDataVisible;
            const rawDataControl = document.getElementById('raw-data-control');
            const rawDataEditor = document.getElementById('raw-data-editor');
            const rawDataText = document.getElementById('raw-data-text');
            const rawDataSource = document.getElementById('raw-data-source');
            
            if (rawDataVisible) {
                // Show raw data editor
                rawDataControl.style.display = 'block';
                rawDataText.textContent = 'Hide Raw Data';
                
                // Store original data and populate editor
                originalRawData = JSON.parse(JSON.stringify(participantsData));
                rawDataEditor.value = JSON.stringify(participantsData, null, 2);
                
                // Populate data source field
                const currentSource = getCurrentDataSource();
                rawDataSource.value = currentSource;
            } else {
                // Hide raw data editor
                rawDataControl.style.display = 'none';
                rawDataText.textContent = 'View Raw Data';
            }
            
            // Close menu
            document.getElementById('menu-toggle').classList.remove('active');
            document.getElementById('menu-dropdown').classList.remove('active');
        }
        
        function getCurrentDataSource() {
            // Get current data source based on selection and hash parameters
            const listParam = getHash().list;
            
            if (listParam === 'all') {
                return 'Meta-list: All Available Lists';
            } else if (selectedFile === 'all') {
                return 'Meta-list: All Available Lists';
            } else if (selectedFile && selectedFile.startsWith('http')) {
                return selectedFile;
            } else if (selectedFile && selectedFile.startsWith('custom_')) {
                return `Custom file: ${selectedFile.replace('custom_', '')}`;
            } else {
                // Try to get URL from selected dropdown option
                const selectedOption = fileSelect.options[fileSelect.selectedIndex];
                const dataUrl = selectedOption?.getAttribute('data-url');
                
                if (dataUrl && dataUrl !== 'all') {
                    return dataUrl;
                } else {
                    return selectedOption?.textContent || 'Unknown data source';
                }
            }
        }
        
        function applyRawDataChanges() {
            const rawDataEditor = document.getElementById('raw-data-editor');
            
            try {
                // Parse the edited JSON
                const editedData = JSON.parse(rawDataEditor.value);
                
                // Validate that it's an array
                if (!Array.isArray(editedData)) {
                    throw new Error('Data must be an array of participants');
                }
                
                // Update the global participants data
                participantsData = editedData;
                
                // Apply all filters and refresh the display
                applyAllFilters();
                
                // Show success message
                showStatusMessage('Raw data changes applied successfully', 'success');
                
            } catch (error) {
                // Show error message
                showStatusMessage('Error parsing JSON: ' + error.message, 'error');
                console.error('Raw data parsing error:', error);
            }
        }
        
        function revertRawData() {
            const rawDataEditor = document.getElementById('raw-data-editor');
            
            if (originalRawData) {
                // Restore original data
                participantsData = JSON.parse(JSON.stringify(originalRawData));
                rawDataEditor.value = JSON.stringify(originalRawData, null, 2);
                
                // Apply all filters and refresh the display
                applyAllFilters();
                
                // Show success message
                showStatusMessage('Raw data reverted to original', 'info');
            }
        }
        
        function closeRawData() {
            // Close the raw data editor if it's open
            if (rawDataVisible) {
                toggleRawData();
            }
        }
        
        function showStatusMessage(message, type = 'info') {
            // Create or update status message element
            let statusEl = document.getElementById('raw-data-status');
            if (!statusEl) {
                statusEl = document.createElement('div');
                statusEl.id = 'raw-data-status';
                statusEl.className = 'status-message';
                document.getElementById('raw-data-control').appendChild(statusEl);
            }
            
            // Set message and type
            statusEl.textContent = message;
            statusEl.className = `status-message ${type}`;
            statusEl.style.display = 'block';
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 3000);
        }
        
        function exportCSVFromMenu() {
            // Close menu first
            document.getElementById('menu-toggle').classList.remove('active');
            document.getElementById('menu-dropdown').classList.remove('active');
            
            // Call the existing export CSV functionality
            exportParticipantsCSV();
        }
        
        // Snapshot functionality
        let currentActiveSnapshot = null;
        
        function getSnapshotsStorageKey() {
            const listId = getHash().list || 'default';
            return `${listId}_1_snapshots`;
        }
        
        function loadSnapshots() {
            const snapshots = JSON.parse(localStorage.getItem(getSnapshotsStorageKey()) || '{}');
            
            // TEMPORARY: Clean up legacy snapshots with non-numeric keys
            const cleanedSnapshots = {};
            let deletedCount = 0;
            
            Object.keys(snapshots).forEach(key => {
                if (!isNaN(parseInt(key)) && parseInt(key).toString() === key) {
                    // Keep snapshots with numeric keys
                    cleanedSnapshots[key] = snapshots[key];
                } else {
                    // Delete snapshots with non-numeric keys
                    console.log(`🗑️ Deleting legacy snapshot with non-numeric key: "${key}"`);
                    deletedCount++;
                }
            });
            
            // Save cleaned snapshots back to localStorage if any were deleted
            if (deletedCount > 0) {
                console.log(`🧹 Cleaned up ${deletedCount} legacy snapshots with non-numeric keys`);
                localStorage.setItem(getSnapshotsStorageKey(), JSON.stringify(cleanedSnapshots));
            }
            
            return cleanedSnapshots;
        }
        
        function saveSnapshots(snapshots) {
            localStorage.setItem(getSnapshotsStorageKey(), JSON.stringify(snapshots));
        }
        
        // Get the next available numeric ID for a new snapshot
        function getNextSnapshotId(snapshots) {
            const existingIds = Object.keys(snapshots)
                .map(id => parseInt(id))
                .filter(id => !isNaN(id));
            
            if (existingIds.length === 0) {
                return 1;
            }
            
            return Math.max(...existingIds) + 1;
        }
        
        function getCurrentFilterState(name = null) {
            return {
                name: name,
                sortColumn: currentSortColumn,
                sortOrder: currentSortOrder,
                teamFilter: currentTeamFilter,
                displayMode: currentView,
                statusFilter: Array.from(selectedStatuses),
                groupParticipants: Array.from(groupParticipants),
                showOnlyGroup: showOnlyGroup
            };
        }
        
        function applyFilterState(filterState) {
            // Apply sort
            currentSortColumn = filterState.sortColumn || 'Rows';
            currentSortOrder = filterState.sortOrder || 'asc';
            localStorage.setItem(getListStorageKey('participantsSortColumn'), currentSortColumn);
            localStorage.setItem(getListStorageKey('participantsSortOrder'), currentSortOrder);
            applySortToData();
            generateSortDropdown();
            
            // Apply team filter - respect hash values over filter state
            const hashTeam = getHash().team;
            if (hashTeam) {
                // Hash value takes priority over filter state
                currentTeamFilter = hashTeam;
            } else {
                currentTeamFilter = filterState.teamFilter || null;
            }
            if (currentTeamFilter) {
                localStorage.setItem(getListStorageKey('participantsTeamFilter'), currentTeamFilter);
            } else {
                localStorage.removeItem(getListStorageKey('participantsTeamFilter'));
            }
            
            // Apply display mode - respect hash values over filter state
            const hashDisplay = getHash().display;
            const targetDisplayMode = hashDisplay || filterState.displayMode;
            if (targetDisplayMode && targetDisplayMode !== currentView) {
                switchView(targetDisplayMode);
            }
            
            // Apply status filter - respect hash values over filter state
            const hashStatus = getHash().status;
            if (hashStatus) {
                // Hash value takes priority over filter state
                selectedStatuses = new Set(hashStatus.split(','));
            } else {
                selectedStatuses = new Set(filterState.statusFilter || ['All']);
            }
            localStorage.setItem(getListStorageKey('participantsStatusFilter'), JSON.stringify(Array.from(selectedStatuses)));
            updateStatusButtonText();
            generateStatusDropdown();
            
            // Apply group participants
            groupParticipants = new Set(filterState.groupParticipants || []);
            showOnlyGroup = filterState.showOnlyGroup || false;
            localStorage.setItem(getListStorageKey('showOnlyGroup'), JSON.stringify(showOnlyGroup));
            
            const groupInput = document.getElementById('group');
            if (groupInput) {
                const groupValue = Array.from(groupParticipants).join(', ');
                groupInput.value = groupValue;
                // Also update localStorage to match the snapshot
                localStorage.setItem(getListStorageKey('groupParticipants'), groupValue);
            }
            updateGroupCount();
            updateGroupToggleUI();
            
            // Apply all filters
            applyAllFilters();
            
            // Sync checkboxes after all filters are applied
            setTimeout(syncCheckboxesWithGroup, 50);
        }
        
        function saveSnapshot(idOrName, displayName = null) {
            const snapshots = loadSnapshots();
            
            // If it's a numeric ID (existing snapshot), use it
            if (!isNaN(parseInt(idOrName))) {
                const id = parseInt(idOrName);
                const filterState = getCurrentFilterState(displayName || snapshots[id]?.name);
                snapshots[id] = filterState;
            } else {
                // It's a name (legacy support or new snapshot)
                // Check if this is an existing snapshot by name
                const existingId = Object.keys(snapshots).find(id => snapshots[id]?.name === idOrName);
                if (existingId) {
                    const filterState = getCurrentFilterState(idOrName);
                    snapshots[existingId] = filterState;
                } else {
                    // Create new snapshot with next ID
                    const newId = getNextSnapshotId(snapshots);
                    const filterState = getCurrentFilterState(idOrName);
                    snapshots[newId] = filterState;
                }
            }
            
            saveSnapshots(snapshots);
            renderSnapshotsList();
        }
        
        function loadSnapshot(id) {
            const snapshots = loadSnapshots();
            console.log(`🔄 Loading snapshot "${id}" for list:`, getHash().list);
            console.log('📸 Available snapshots:', Object.keys(snapshots));
            
            const snapshotId = parseInt(id);
            const snapshotData = snapshots[snapshotId];
            
            if (snapshotData) {
                isLoadingSnapshot = true;
                currentActiveSnapshot = snapshotId;
                console.log('✅ Set currentActiveSnapshot to:', currentActiveSnapshot);
                
                // Update the dropdown to reflect the loaded snapshot
                const snapshotSelect = document.getElementById('snapshot');
                if (snapshotSelect) {
                    snapshotSelect.value = snapshotId;
                    showEditDeleteButtons();
                }
                
                applyFilterState(snapshotData);
                updateListTitle();
                isLoadingSnapshot = false;
            } else {
                console.log('❌ Snapshot not found:', id);
            }
        }
        
        function deleteSnapshot(name) {
            const snapshots = loadSnapshots();
            delete snapshots[name];
            saveSnapshots(snapshots);
            if (currentActiveSnapshot === name) {
                currentActiveSnapshot = null;
                updateListTitle();
            }
            renderSnapshotsList();
        }
        
        function renderSnapshotsList() {
            const snapshots = loadSnapshots();
            const snapshotsList = document.getElementById('snapshots-list');
            
            if (!snapshotsList) {
                console.warn('snapshots-list element not found, skipping render');
                return;
            }
            
            snapshotsList.innerHTML = '';
            
            Object.keys(snapshots).forEach(name => {
                const snapshotItem = document.createElement('div');
                snapshotItem.className = 'snapshot-item';
                
                snapshotItem.innerHTML = `
                    <input type="text" class="snapshot-name" value="${name}" readonly>
                    <button class="snapshot-save-btn" title="Save current filters">Save</button>
                    <button class="snapshot-view-btn" title="Load this snapshot">View</button>
                    <div class="snapshot-menu">
                        <button class="snapshot-menu-btn" title="More options">⋯</button>
                        <div class="snapshot-menu-dropdown">
                            <div class="snapshot-menu-item" onclick="deleteSnapshot('${name}')">Delete</div>
                        </div>
                    </div>
                `;
                
                const nameInput = snapshotItem.querySelector('.snapshot-name');
                const saveBtn = snapshotItem.querySelector('.snapshot-save-btn');
                const viewBtn = snapshotItem.querySelector('.snapshot-view-btn');
                
                // Click snapshot name to edit it
                nameInput.addEventListener('click', () => {
                    if (!nameInput.classList.contains('editing')) {
                        nameInput.classList.add('editing');
                        nameInput.readOnly = false;
                        nameInput.select();
                    }
                });
                
                // Double-click to edit name (keep for backward compatibility)
                nameInput.addEventListener('dblclick', () => {
                    nameInput.classList.add('editing');
                    nameInput.readOnly = false;
                    nameInput.select();
                });
                
                // Save name on blur or enter
                nameInput.addEventListener('blur', () => saveSnapshotName(nameInput, name));
                nameInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        saveSnapshotName(nameInput, name);
                    }
                });
                
                // Save button - save current filter state to this snapshot
                saveBtn.addEventListener('click', () => {
                    saveSnapshot(name);
                    // Set as current active snapshot and update title
                    currentActiveSnapshot = name;
                    updateListTitle();
                    alert(`Snapshot "${name}" updated with current filters and activated!`);
                });
                
                // View button - load this snapshot
                viewBtn.addEventListener('click', () => {
                    loadSnapshot(name);
                    toggleSnapshots();
                });
                
                // Menu dropdown functionality
                const menuBtn = snapshotItem.querySelector('.snapshot-menu-btn');
                const menuDropdown = snapshotItem.querySelector('.snapshot-menu-dropdown');
                
                menuBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Close all other dropdowns first
                    document.querySelectorAll('.snapshot-menu-dropdown').forEach(dropdown => {
                        if (dropdown !== menuDropdown) {
                            dropdown.style.display = 'none';
                        }
                    });
                    // Toggle current dropdown
                    menuDropdown.style.display = menuDropdown.style.display === 'block' ? 'none' : 'block';
                });
                
                // Close dropdown when clicking outside
                document.addEventListener('click', () => {
                    menuDropdown.style.display = 'none';
                });
                
                snapshotsList.appendChild(snapshotItem);
            });
        }
        
        function saveSnapshotName(input, oldName) {
            const newName = input.value.trim();
            if (newName && newName !== oldName) {
                const snapshots = loadSnapshots();
                snapshots[newName] = snapshots[oldName];
                delete snapshots[oldName];
                saveSnapshots(snapshots);
                
                if (currentActiveSnapshot === oldName) {
                    currentActiveSnapshot = newName;
                    updateListTitle();
                }
                
                renderSnapshotsList();
            } else {
                input.value = oldName;
            }
            input.classList.remove('editing');
            input.readOnly = true;
        }
        
        function toggleSnapshots() {
            const snapshotsControl = document.getElementById('snapshots-control');
            const isVisible = snapshotsControl.style.display === 'block';
            
            if (isVisible) {
                snapshotsControl.style.display = 'none';
            } else {
                snapshotsControl.style.display = 'block';
                renderSnapshotsList();
                
                // Auto-populate new snapshot name with today's date
                const nameInput = document.getElementById('new-snapshot-name');
                if (nameInput) {
                    const today = new Date();
                    const months = ['January', 'February', 'March', 'April', 'May', 'June',
                                  'July', 'August', 'September', 'October', 'November', 'December'];
                    const defaultName = `${months[today.getMonth()]} ${today.getDate()}, ${today.getFullYear()}`;
                    nameInput.value = defaultName;
                }
            }
            
            // Close menu
            document.getElementById('menu-toggle').classList.remove('active');
            document.getElementById('menu-dropdown').classList.remove('active');
        }
        
        function addNewSnapshot() {
            const nameInput = document.getElementById('new-snapshot-name');
            const name = nameInput.value.trim();
            
            if (!name) {
                alert('Please enter a snapshot name');
                return;
            }
            
            const snapshots = loadSnapshots();
            if (snapshots[name]) {
                if (!confirm(`Snapshot "${name}" already exists. Overwrite?`)) {
                    return;
                }
            }
            
            saveSnapshot(name);
            // Set as current active snapshot and update title
            currentActiveSnapshot = name;
            updateListTitle();
            nameInput.value = '';
            alert(`Snapshot "${name}" saved and activated!`);
        }
        
        function updateListTitle() {
            const listTitle = document.getElementById('list-title');
            const baseTitle = listTitle.textContent.split(' - ')[0]; // Remove existing snapshot name
            
            // Keep list title clean - no snapshot name in main title
            listTitle.textContent = baseTitle;
            
            // Update group snapshot info
            updateGroupSnapshotInfo();
        }
        
        function updateGroupSnapshotInfo() {
            const snapshotInfo = document.getElementById('group-snapshot-info');
            const participantsLabel = document.getElementById('group-participants-label');
            console.log('🔄 updateGroupSnapshotInfo called, element found:', !!snapshotInfo);
            console.log('📸 currentActiveSnapshot:', currentActiveSnapshot);
            
            if (!snapshotInfo) {
                console.error('❌ group-snapshot-info element not found');
                return;
            }
            
            if (currentActiveSnapshot) {
                // Hide the snapshot info when active snapshot is selected
                snapshotInfo.innerHTML = '';
                console.log('✅ Hidden active snapshot info');
            } else {
                // Show save snapshot link
                snapshotInfo.innerHTML = `<a href="#" onclick="promptSaveSnapshot(); return false;">Save Snapshot</a>`;
                console.log('✅ Displayed save snapshot link');
            }
        }
        
        function promptSaveSnapshot() {
            // Generate today's date in format "Month D, YYYY"
            const today = new Date();
            const months = ['January', 'February', 'March', 'April', 'May', 'June',
                          'July', 'August', 'September', 'October', 'November', 'December'];
            const defaultName = `${months[today.getMonth()]} ${today.getDate()}, ${today.getFullYear()}`;
            
            const name = prompt('Enter snapshot name:', defaultName);
            if (name && name.trim()) {
                const snapshots = loadSnapshots();
                if (snapshots[name.trim()]) {
                    if (!confirm(`Snapshot "${name.trim()}" already exists. Overwrite?`)) {
                        return;
                    }
                }
                
                saveSnapshot(name.trim());
                currentActiveSnapshot = name.trim();
                updateListTitle();
                alert(`Snapshot "${name.trim()}" saved and activated!`);
            }
        }
        
        let isLoadingSnapshot = false;
        
        function clearActiveSnapshot() {
            if (currentActiveSnapshot && !isLoadingSnapshot) {
                currentActiveSnapshot = null;
                updateListTitle();
                console.log('🔄 Cleared active snapshot due to manual filter change');
            } else if (isLoadingSnapshot) {
                console.log('⏭️ Skipped clearing active snapshot - snapshot loading in progress');
            }
        }
        
        function loadSnapshotOnPageLoad() {
            const snapshots = loadSnapshots();
            
            // Check if there's a snapshot parameter in the hash
            const hash = typeof getHash === 'function' ? getHash() : {};
            const hashSnapshotId = hash.snapshot;
            
            if (hashSnapshotId && snapshots[hashSnapshotId]) {
                console.log(`🔄 Loading snapshot from hash: ${hashSnapshotId}`);
                loadSnapshot(hashSnapshotId);
                return;
            }
            
            // Find the most recent date-based snapshot (by name pattern)
            const dateSnapshots = Object.keys(snapshots).filter(id => {
                const snapshot = snapshots[id];
                // Check if snapshot name matches date format (Month DD, YYYY)
                return snapshot.name && /^[A-Za-z]+ \d{2}, \d{4}/.test(snapshot.name);
            });
            
            if (dateSnapshots.length > 0) {
                // Sort by date (most recent first) based on the name
                dateSnapshots.sort((a, b) => {
                    const dateA = new Date(snapshots[a].name);
                    const dateB = new Date(snapshots[b].name);
                    return dateB - dateA; // Descending order (newest first)
                });
                
                const mostRecentSnapshotId = dateSnapshots[0];
                const mostRecentSnapshotName = snapshots[mostRecentSnapshotId].name;
                console.log(`🔄 Loading most recent snapshot on page load: ${mostRecentSnapshotName} (ID: ${mostRecentSnapshotId})`);
                loadSnapshot(mostRecentSnapshotId);
            } else if (snapshots['1']) {
                // Fallback to snapshot '1' if no date-based snapshots exist
                console.log('🔄 Loading fallback snapshot "1" on page load');
                loadSnapshot(1);
            }
        }
        
        function generateFullURL() {
            // Close menu first
            document.getElementById('menu-toggle').classList.remove('active');
            document.getElementById('menu-dropdown').classList.remove('active');
            
            // Start with current URL without hash
            const baseUrl = window.location.origin + window.location.pathname + window.location.search;
            const params = new URLSearchParams();
            
            // Add current hash parameters
            const currentHash = window.location.hash.substring(1);
            if (currentHash) {
                const hashParams = new URLSearchParams(currentHash);
                hashParams.forEach((value, key) => {
                    params.set(key, value);
                });
            }
            
            // Add sort parameters from localStorage
            if (currentSortColumn && currentSortColumn !== 'Rows') {
                params.set('sortby', currentSortColumn);
            }
            if (currentSortOrder && currentSortOrder !== 'asc') {
                params.set('sortorder', currentSortOrder);
            }
            
            // Add team filter if active
            if (currentTeamFilter) {
                params.set('team', currentTeamFilter);
            }
            
            // Add display mode if not default
            if (currentView && currentView !== 'column') {
                params.set('display', currentView);
            }
            
            // Add status filter if not "All"
            const statusArray = Array.from(selectedStatuses);
            if (!statusArray.includes('All') && statusArray.length > 0) {
                params.set('status', statusArray.join(','));
            }
            
            // Add group participants if any
            if (groupParticipants.size > 0) {
                params.set('group', Array.from(groupParticipants).join(','));
            }
            
            // Generate full URL
            const fullUrl = params.toString() ? `${baseUrl}#${params.toString()}` : baseUrl;
            
            // Copy to clipboard
            navigator.clipboard.writeText(fullUrl).then(() => {
                // Show success message
                alert('Full URL copied to clipboard!\n\nThe URL includes all current filters:\n- Sort settings\n- Team filter\n- Status filter\n- Group participants\n- Display mode');
                console.log('📋 Full URL copied to clipboard:', fullUrl);
            }).catch(err => {
                // Fallback for older browsers
                console.error('Failed to copy to clipboard:', err);
                alert('Full URL:\n\n' + fullUrl + '\n\n(Please copy manually)');
            });
        }
        
        function exportParticipantsCSV() {
            console.log('exportParticipantsCSV called');
            console.log('allRowsData:', allRowsData);
            
            if (!window.participantsData || window.participantsData.length === 0) {
                // Try using allRowsData as fallback
                if (allRowsData && allRowsData.length > 0) {
                    console.log('Using allRowsData as fallback');
                    window.participantsData = allRowsData;
                } else {
                    alert('No participant data to export');
                    return;
                }
            }
            
            // Determine which data to export based on current filter state
            let dataToExport = window.participantsData;
            
            // Generate date string for filename (YYYY-MM-DD format)
            const today = new Date();
            const dateString = today.getFullYear() + '-' + 
                String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                String(today.getDate()).padStart(2, '0');
            
            let filename = `meetup-participants-${dateString}.csv`;
            
            // Apply team filter if active
            if (currentTeamFilter && currentTeamFilter !== 'all') {
                dataToExport = dataToExport.filter(participant => {
                    const teamClasses = getAllTeamClasses(participant.Team);
                    return teamClasses.includes(currentTeamFilter);
                });
                const teamName = teamColors[currentTeamFilter.replace('team-', '')] ? 
                    teamColors[currentTeamFilter.replace('team-', '')].name : 'filtered';
                filename = `meetup-participants-${teamName}-${dateString}.csv`;
            }
            
            // Apply status filter if active (using selectedStatuses)
            if (!selectedStatuses.has('All') && selectedStatuses.size > 0) {
                const statusList = Array.from(selectedStatuses);
                dataToExport = dataToExport.filter(participant => {
                    const status = participant.Status || '';
                    return statusList.includes(status);
                });
                filename = `meetup-participants-${statusList.join('-')}-${dateString}.csv`;
            }
            
            // If showing only group participants, export only those
            if (showOnlyGroup) {
                dataToExport = dataToExport.filter(participant => {
                    const name = getParticipantName(participant);
                    return Array.from(groupParticipants).some(groupName => 
                        groupName.toLowerCase() === name.toLowerCase()
                    );
                });
                filename = `meetup-participants-group-${dateString}.csv`;
            }
            
            if (dataToExport.length === 0) {
                alert('No participants match the current filters');
                return;
            }
            
            console.log('About to export', dataToExport.length, 'rows');
            const headers = Object.keys(dataToExport[0]);
            console.log('Headers:', headers);
            
            // Create CSV content
            let csvContent = headers.join(',') + '\n';
            dataToExport.forEach(row => {
                const values = headers.map(header => {
                    const value = row[header] || '';
                    // Escape quotes and wrap in quotes if contains comma
                    return value.includes(',') ? `"${value.replace(/"/g, '""')}"` : value;
                });
                csvContent += values.join(',') + '\n';
            });
            
            // Download CSV
            console.log('Creating CSV download with filename:', filename);
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            console.log('Triggering download...');
            link.click();
            document.body.removeChild(link);
            console.log('CSV export completed');
        }

        //getParticipantsButton.addEventListener('click', getMeetupParticipants);
        

        // View switching event listeners - Use localsite.js hash functions
        document.getElementById('column-view-btn').addEventListener('click', () => {
            goHash({}, ['display']); // Remove display parameter
        });
        document.getElementById('table-view-btn').addEventListener('click', () => {
            goHash({ display: 'table' }, []); // Set display=table
        });
        document.getElementById('gallery-view-btn').addEventListener('click', () => {
            goHash({ display: 'gallery' }, []); // Set display=gallery
        });
        
        // Team filter event listener (now handled in generateTeamLegend function)
        
        // Sort event listeners
        document.getElementById('sort-toggle').addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            toggleSortDropdown();
        });
        document.getElementById('close-sort').addEventListener('click', () => {
            document.getElementById('sort-dropdown').style.display = 'none';
        });
        
        // Status event listeners
        document.getElementById('status-toggle').addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            toggleStatusDropdown();
        });
        document.getElementById('close-status').addEventListener('click', () => {
            document.getElementById('status-dropdown').style.display = 'none';
        });
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', function(e) {
            const sortDropdown = document.getElementById('sort-dropdown');
            const sortToggle = document.getElementById('sort-toggle');
            const statusDropdown = document.getElementById('status-dropdown');
            const statusToggle = document.getElementById('status-toggle');
            
            if (!sortDropdown.contains(e.target) && !sortToggle.contains(e.target)) {
                sortDropdown.style.display = 'none';
            }
            
            if (!statusDropdown.contains(e.target) && !statusToggle.contains(e.target)) {
                statusDropdown.style.display = 'none';
            }
            
            // Close participant menu dropdowns when clicking outside
            if (!e.target.closest('.columns-menu')) {
                document.querySelectorAll('.columns-menu-dropdown').forEach(dropdown => {
                    dropdown.style.display = 'none';
                });
            }
        });
        
        // Group participants event listeners
        const groupInput = document.getElementById('group');
        groupInput.addEventListener('input', function(e) {
            const value = e.target.value;
            // Process input when comma is typed, but preserve the comma
            if (value.endsWith(',')) {
                // Extract the part before the comma for processing
                const beforeComma = value.substring(0, value.length - 1);
                if (beforeComma.trim()) {
                    // Process the names before the comma
                    const names = beforeComma.split(',').map(name => name.trim()).filter(name => name);
                    names.forEach(name => {
                        if (name) groupParticipants.add(name);
                    });
                    
                    // Validate names against dataset
                    validateGroupNames(names);
                    
                    // Save to storage and update highlighting
                    saveGroupParticipants();
                    updateGroupCount();
                    updateGroupHighlighting();
                    
                    // Note: URL hash parameters for groups have been discontinued
                }
            }
        });
        
        groupInput.addEventListener('keydown', function(e) {
            // Process input when Enter is pressed
            if (e.key === 'Enter') {
                e.preventDefault();
                processGroupInput();
            }
        });
        
        groupInput.addEventListener('blur', function() {
            // Process input when field loses focus
            processGroupInput();
            // Only scroll to the right if already near the right edge
            if (groupInput.scrollLeft >= groupInput.scrollWidth - groupInput.clientWidth - 10) {
                setTimeout(() => scrollGroupInputToRight(), 10); // Very fast, 10th of 10th
            }
        });
        
        document.getElementById('group-toggle').addEventListener('click', toggleGroupFilter);
        
        // Group toggle text editing functionality
        const groupToggleText = document.getElementById('group-toggle-text');
        
        // Make toggle text editable on double-click
        groupToggleText.addEventListener('dblclick', function() {
            const currentText = this.textContent;
            this.contentEditable = true;
            this.focus();
            
            // Select all text for easy editing
            const range = document.createRange();
            range.selectNodeContents(this);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
        });
        
        // Save changes when editing is complete
        groupToggleText.addEventListener('blur', function() {
            this.contentEditable = false;
            const newText = this.textContent.trim();
            
            if (newText) {
                // Save the new text based on current toggle state
                if (showOnlyGroup) {
                    localStorage.setItem(getListStorageKey('groupToggleActiveText'), newText);
                } else {
                    localStorage.setItem(getListStorageKey('groupToggleInactiveText'), newText);
                }
                console.log(`💾 Saved group toggle text: "${newText}" for ${showOnlyGroup ? 'active' : 'inactive'} state`);
            } else {
                // Restore previous text if empty
                updateGroupToggleUI();
            }
        });
        
        // Save changes when Enter is pressed
        groupToggleText.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.blur(); // Trigger blur event to save
            }
            if (e.key === 'Escape') {
                e.preventDefault();
                // Restore original text and exit editing
                updateGroupToggleUI();
                this.contentEditable = false;
            }
        });
        
        // Raw data event listeners
        document.getElementById('apply-raw-data').addEventListener('click', applyRawDataChanges);
        document.getElementById('revert-raw-data').addEventListener('click', revertRawData);
        document.getElementById('raw-data-close').addEventListener('click', closeRawData);
        
        // Hide UI elements when changing to a new list
        function hideListDisplayElements() {
            // Hide team legend panel
            const teamLegend = document.getElementById('team-legend');
            if (teamLegend) {
                teamLegend.style.display = 'none';
            }
            
            // Hide view controls
            const viewControls = document.querySelector('.view-controls');
            if (viewControls) {
                viewControls.style.display = 'none';
            }
            
            // Hide table view and other views
            const tableView = document.getElementById('table-view');
            const columnView = document.getElementById('column-view');
            const galleryView = document.getElementById('gallery-view');
            
            if (tableView) tableView.style.display = 'none';
            if (columnView) columnView.style.display = 'none';
            if (galleryView) galleryView.style.display = 'none';
            
            // Clear all view containers immediately when list changes
            const columnGrid = document.getElementById('participants-column-grid');
            const tableBody = document.querySelector('#participants-table tbody');
            const galleryGrid = document.getElementById('participants-gallery-grid');
            const tableContainer = document.getElementById('participants-table-container');
            const loadStatus = document.getElementById('loadStatus');
            
            if (columnGrid) columnGrid.innerHTML = '';
            if (tableBody) tableBody.innerHTML = '';
            if (galleryGrid) galleryGrid.innerHTML = '';
            if (tableContainer) tableContainer.innerHTML = '';
            if (loadStatus) {
                loadStatus.innerHTML = '';
                loadStatus.style.display = 'none';
            }
            
            // Clear data arrays
            allRowsData = [];
            filteredData = [];
            
            console.log('List display elements hidden and data cleared');
        }
        
        // Show UI elements when new list loads successfully
        function showListDisplayElements() {
            // Show view controls
            const viewControls = document.querySelector('.view-controls');
            if (viewControls) {
                viewControls.style.display = 'flex';
            }
            
            // Show the current view based on currentView setting
            const tableView = document.getElementById('table-view');
            const columnView = document.getElementById('column-view');
            const galleryView = document.getElementById('gallery-view');
            
            // Hide all views first
            if (tableView) tableView.style.display = 'none';
            if (columnView) columnView.style.display = 'none';
            if (galleryView) galleryView.style.display = 'none';
            
            // Show the current view
            if (currentView === 'table' && tableView) {
                tableView.style.display = 'block';
            } else if (currentView === 'gallery' && galleryView) {
                galleryView.style.display = 'block';
            } else if (columnView) {
                // Default to column view
                columnView.style.display = 'block';
            }
            
            // Team legend will be shown by generateTeamLegend if there's a Team column
            
            // Show group control only for modelteam list (if available in fileSelect)
            const groupControl = document.getElementById('group-control');
            const currentList = getHash().list;
            if (groupControl) {
                // Check if modelteam option exists in fileSelect before showing group control
                const isGroupList = Array.from(fileSelect.options).find(option => option.value === 'modelteam');
                if (currentList === 'modelteam' && isGroupList) {
                    groupControl.style.display = 'block';
                } else {
                    groupControl.style.display = 'none';
                }
            }
            
            // Update group snapshot info after elements are shown (only for modelteam if available)
            const isGroupList = Array.from(fileSelect.options).find(option => option.value === 'modelteam');
            if (currentList === 'modelteam' && isGroupList) {
                waitForElm('#group-snapshot-info').then(() => {
                    updateGroupSnapshotInfo();
                });
            }
            
            console.log('List display elements shown');
        }
        
        // Update menu visibility based on current list
        function updateMenuVisibility() {
            const listParam = getHash().list;
            const allFeedsToggle = document.getElementById('list-feeds-toggle');
            
            if (allFeedsToggle) {
                // Hide "All Lists" option when already viewing all lists
                if (listParam === 'all' || fileSelect.value === 'all') {
                    allFeedsToggle.style.display = 'none';
                } else {
                    allFeedsToggle.style.display = 'block';
                }
            }
        }
        
        // Clear all filters when changing lists
        function clearAllFilters() {
            // Clear team filter
            currentTeamFilter = null;
            localStorage.removeItem(getListStorageKey('participantsTeamFilter'));
            
            // Clear status filter - reset to "All"
            selectedStatuses.clear();
            selectedStatuses.add('All');
            localStorage.setItem(getListStorageKey('participantsStatusFilter'), JSON.stringify(['All']));
            
            // Clear group participants filter
            showOnlyGroup = false;
            localStorage.setItem(getListStorageKey('showOnlyGroup'), 'false');
            const groupInput = document.getElementById('group');
            if (groupInput) {
                groupInput.value = '';
            }
            groupParticipants = new Set();
            updateGroupCount();
            
            // Hide validation message
            hideGroupValidationMessage();
            
            // Clear URL hash parameters (sortby/sortorder/group are not in hash anymore)
            setURLHashParam('status', null);
            
            // Reset team legend flag to allow regeneration
            initialTeamLegendGenerated = false;
            
            console.log('All filters cleared for new list selection');
        }
        
        
        // File selection handling functions
        function handleFileDropdownChange() {
            const value = fileSelect.value;
            
            console.log('DROPDOWN CHANGE: Selected value:', value, '- updating hash');
            
            // Only update hash - let hashchange event handle all processing
            if (value === 'custom') {
                // Show custom file selection without hash update
                customFileSection.style.display = 'block';
                selectedFile = null;
            } else {
                // Hide custom file selection and update hash
                customFileSection.style.display = 'none';
                
                // Update hash parameter - hashchange event will handle everything else
                updateListHashParam(value);
                
                // Save selection to storage
                saveFileSelectionToStorage(value, STORAGE_KEY);
            }
            
            // Update contributions button visibility when selection changes
            updateContribsButtonVisibility();
        }
        
        function updateParticipantListTitle(customTitle = null) {
            const participantListTitle = document.getElementById('list-title');
            let titleText;
            
            if (customTitle) {
                // Use custom title provided
                titleText = customTitle;
                participantListTitle.textContent = `📊 ${customTitle}`;
            } else {
                // Check if there's a list parameter in the hash
                const listParam = getHash().list;
                if (listParam) {
                    // Special case for geo - use "Location Visits" title
 
                    // Look for matching option in dropdown to get proper title
                    const matchingOption = Array.from(fileSelect.options).find(option => option.value === listParam);
                    if (matchingOption && matchingOption.textContent) {
                        titleText = matchingOption.textContent;
                        participantListTitle.textContent = `📊 ${matchingOption.textContent}`;
                        // Update dropdown selection to match
                        fileSelect.value = listParam;
                    } else {
                        // List parameter not available in this site's fileSelect options
                        // Just use the parameter as title without changing dropdown
                        titleText = listParam;
                        participantListTitle.textContent = `📊 ${listParam}`;
                        console.log('List param not found in fileSelect options:', listParam, 'keeping original selection');
                        
                        // Display user-visible message about unavailable list
                        appendStatusMessage(`📋 List "${listParam}" is not available in the current dropdown options. Showing default selection instead.`, 'info');
                    }

                } else {
                    const selectedOption = fileSelect.options[fileSelect.selectedIndex];
                    if (selectedOption && selectedOption.textContent && selectedOption.value !== 'custom') {
                        // Use the title from the selected option
                        titleText = selectedOption.textContent;
                        participantListTitle.textContent = `📊 ${selectedOption.textContent}`;
                    } else {
                        // Default title
                        titleText = 'Participants List';
                        participantListTitle.textContent = '📊 Participants List';
                    }
                }
            }
            
            // Update browser title
            document.title = titleText;
        }
        
        // Show/hide header based on list parameter
        function updateHeaderVisibility() {
            const listParam = getHash().list;
            const header = document.getElementById('teamHeader');
            
            if (header) {
                // Only show header when list=modelteam AND modelteam option exists in fileSelect
                const fileSelectElement = document.getElementById('fileSelect');
                let isGroupList = false;
                
                if (fileSelectElement && fileSelectElement.options) {
                    isGroupList = Array.from(fileSelectElement.options).find(option => option.value === 'modelteam');
                }
                
                const shouldShowHeader = (listParam === 'modelteam') && isGroupList;
                header.style.display = shouldShowHeader ? 'block' : 'none';
                console.log('🏠 Header visibility updated:', shouldShowHeader ? 'visible' : 'hidden', 
                           'for list:', listParam, 'modelteam available:', !!isGroupList, 
                           'fileSelect options count:', fileSelectElement?.options?.length || 0);
            } else {
                console.error('❌ teamHeader element not found!');
            }
        }
        
        // Update both header visibility and title when hash changes
        function updateUIForHashChange() {
            updateHeaderVisibility();
            updateParticipantListTitle();
            
            // Update contributions button visibility based on current hash
            updateContribsButtonVisibility();
            
            // Clear status messages when list changes
            statusMessages.innerHTML = '';
        }
        
        function handleCustomFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Store the file object
            customFiles[file.name] = file;
            selectedFile = file;
            
            // Add the new file to the dropdown
            const fileName = file.name;
            const fileValue = `custom_${fileName}`;
            
            // Check if this file is already in the dropdown
            let existingOption = Array.from(fileSelect.options).find(option => option.value === fileValue);
            if (!existingOption) {
                // Add new option before "Choose File..."
                const newOption = document.createElement('option');
                newOption.value = fileValue;
                newOption.textContent = fileName;
                newOption.selected = true;
                
                // Insert before the "Choose File..." option (last option)
                fileSelect.insertBefore(newOption, fileSelect.lastElementChild);
            } else {
                // Select the existing option
                existingOption.selected = true;
            }
            
            // Update display
            const fileSize = (file.size / 1024 / 1024).toFixed(2);
            const fileType = file.name.toLowerCase().endsWith('.csv') ? 'CSV' : 'Excel';
            fileDisplay.innerHTML = `
                <div class="file-info">
                    <div class="file-name">${fileName}</div>
                    <div class="file-details">${fileType} file, ${fileSize} MB</div>
                </div>
            `;
            
            // Hide custom file section
            customFileSection.style.display = 'none';
        }
        
        // Hash parameter utility functions are now available from list.js
        // getURLHashParam, setURLHashParam, updateListHashParam
        
        
        async function initializeFileSelection() {
            // Use shared function for Google Sheet loading and initialization
            const selectedOption = await initializeFileSelectionWithGoogleSheet(fileSelect, 'list', STORAGE_KEY);
            
            // Add "All Lists" option after dynamic options are loaded
            addAllListsOption();
            
            // Add geo option for location visits
            // Saving for a sample dataset
            // addGeoOption();
            
            // Check for geo-related domains or hash parameter
            const listParam = getHash().list;
            const shouldDefaultToGeo = !listParam && isGeoSite();
            
            if (listParam === 'all') {
                fileSelect.value = 'all';
                selectedFile = 'all';
            } else {
                selectedFile = selectedOption.getAttribute('data-url') || selectedOption.value;
            }
            
            // Update the participant list title with the selected option
            updateParticipantListTitle();
            
            // Update list select visibility based on geo parameter
            updateListSelectVisibility();
            
            // Add event listeners
            fileSelect.addEventListener('change', handleFileDropdownChange);
            fileInput.addEventListener('change', handleCustomFileSelect);
            
            // Make file display clickable
            fileDisplay.addEventListener('click', () => {
                fileInput.click();
            });
        }
        
        function addAllListsOption() {
            // Check if "All Lists" option already exists
            const existingAllOption = Array.from(fileSelect.options).find(option => option.value === 'all');
            if (existingAllOption) return;
            
            // Add "All Lists" option at the top (first position)
            const allListsOption = document.createElement('option');
            allListsOption.value = 'all';
            allListsOption.textContent = 'All Lists';
            allListsOption.setAttribute('data-url', 'all');
            
            // Insert as the first option
            fileSelect.insertBefore(allListsOption, fileSelect.firstChild);
        }
        
        function addGeoOption() {
            // Check if "Location Visits" option already exists
            const existingGeoOption = Array.from(fileSelect.options).find(option => option.value === 'geo');
            if (existingGeoOption) return;
            
            // Add "Location Visits" option
            const geoOption = document.createElement('option');
            geoOption.value = 'geo';
            geoOption.textContent = 'Location Visits';
            geoOption.setAttribute('data-url', 'map/cities.csv');
            
            // Insert after "All Lists" option if it exists, otherwise at the beginning
            const allListsOption = Array.from(fileSelect.options).find(option => option.value === 'all');
            if (allListsOption) {
                fileSelect.insertBefore(geoOption, allListsOption.nextSibling);
            } else {
                fileSelect.insertBefore(geoOption, fileSelect.firstChild);
            }
        }
        
        function addModelteamOption() {
            // Check if "modelteam" option already exists
            const existingModelteamOption = Array.from(fileSelect.options).find(option => option.value === 'modelteam');
            if (existingModelteamOption) return;
            
            // Don't add Model Earth Team option for geo sites
            if (isGeoSite()) {
                return;
            }
            
            // Add "Model Earth Team" option (from lists.csv line 4)
            const modelteamOption = document.createElement('option');
            modelteamOption.value = 'modelteam';
            modelteamOption.textContent = 'Model Earth Team';
            modelteamOption.setAttribute('data-url', 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRh5-bIR4hC1f9H3NtDCNT19hZXnqz8WRrBwTuLGnZiA5PWhFILUv2nS2FKE2TZ4dZ-RnJkZwHx1t2Y/pub?gid=1054734503&single=true&output=csv');
            
            // Insert after other options but before "Choose File..."
            const chooseFileOption = Array.from(fileSelect.options).find(option => option.value === 'custom');
            if (chooseFileOption) {
                fileSelect.insertBefore(modelteamOption, chooseFileOption);
            } else {
                fileSelect.appendChild(modelteamOption);
            }
        }
        
        function updateListSelectVisibility() {
            const listParam = getHash().list;
            const pageControls = document.getElementById('pageControls');
            const breadcrumb = document.querySelector('.breadcrumb');
            const addVisitBtn = document.getElementById('add-visit-btn');
            const mapBtn = document.getElementById('map-btn');
            const insightsBtn = document.getElementById('insights-btn');
            const signInBtn = document.getElementById('sign-in-btn');
            
            if (listParam === 'geo') {
                pageControls.style.display = 'flex';
                if (breadcrumb) {
                    breadcrumb.style.display = 'none';
                }
                if (addVisitBtn) {
                    addVisitBtn.style.display = 'inline-block';
                }
                if (mapBtn) {
                    mapBtn.style.display = 'inline-block';
                }
                if (signInBtn) {
                    signInBtn.style.display = 'inline-block';
                }
            } else {
                pageControls.style.display = 'flex';
                if (breadcrumb) {
                    breadcrumb.style.display = 'block';
                }
                if (addVisitBtn) {
                    addVisitBtn.style.display = 'none';
                }
                if (mapBtn) {
                    mapBtn.style.display = 'none';
                }
                if (signInBtn) {
                    signInBtn.style.display = 'none';
                }
            }
            
            // Always show insights button for all lists
            if (insightsBtn) {
                insightsBtn.style.display = 'inline-block';
            }
            // Also show Contributions button if present
            const contribsBtn = document.getElementById('contribs-btn');
            if (contribsBtn) {
                contribsBtn.style.display = 'inline-block';
            }
        }
        
        // Insights toggle functionality
        function toggleInsights() {
            const aiInsights = document.getElementById('aiInsights');
            const insightsBtn = document.getElementById('insights-btn');
            // Use getComputedStyle to check actual visibility since we use CSS !important
            const computedStyle = window.getComputedStyle(aiInsights);
            const isCurrentlyVisible = computedStyle.display === 'block';
            
            if (isCurrentlyVisible) {
                // Hide insights
                aiInsights.style.setProperty('display', 'none', 'important');
                insightsBtn.textContent = 'Insights';
                removeURLHashParam('insights');
            } else {
                // Show insights
                aiInsights.style.setProperty('display', 'block', 'important');
                insightsBtn.textContent = 'Hide Insights';
                setURLHashParam('insights', 'all');
            }
        }
        
        // Remove URL hash parameter (uses existing setURLHashParam)
        function removeURLHashParam(key) {
            setURLHashParam(key, null);
        }
        
        // Check for insights parameter in URL and show/hide accordingly
        function checkInsightsFromURL() {
            const insightsParam = getHash().insights;
            const aiInsights = document.getElementById('aiInsights');
            const insightsBtn = document.getElementById('insights-btn');
            
            // Ensure elements exist before trying to manipulate them
            if (!aiInsights) {
                console.warn('aiInsights element not found');
                return;
            }
            
            if (insightsParam === 'all') {
                aiInsights.style.setProperty('display', 'block', 'important');
                if (insightsBtn) {
                    insightsBtn.textContent = 'Hide Insights';
                }
                console.log('Insights panel shown from URL parameter');
            } else {
                aiInsights.style.setProperty('display', 'none', 'important');
                if (insightsBtn) {
                    insightsBtn.textContent = 'Insights';
                }
                console.log('Insights panel hidden (no URL parameter)');
            }
        }
        
        // Restore saved view state
        function restoreViewState() {
            // Restore the saved view mode (currentView is already loaded from localStorage)
            switchView(currentView);
        }
        
        // 3-dot menu functionality
        function toggleMenu() {
            const dropdown = document.getElementById('menu-dropdown');
            const button = document.getElementById('menu-toggle');
            const isVisible = dropdown.style.display === 'block';
            
            if (isVisible) {
                dropdown.style.display = 'none';
                button.classList.remove('active');
            } else {
                dropdown.style.display = 'block';
                button.classList.add('active');
            }
        }
        
        function toggleFullscreen() {
            isFullscreen = !isFullscreen;
            localStorage.setItem('isFullscreen', JSON.stringify(isFullscreen));
            
            const fullscreenText = document.getElementById('fullscreen-text');
            
            if (isFullscreen) {
                // Apply fullscreen to the body/container to include file selection
                document.body.classList.add('fullscreen-mode');
                fullscreenText.textContent = 'Exit Fullscreen';
                // Allow scrolling in fullscreen mode
                document.body.style.overflow = 'auto';
            } else {
                document.body.classList.remove('fullscreen-mode');
                fullscreenText.textContent = 'View Fullscreen';
                document.body.style.overflow = 'auto';
            }
            
            // Close menu
            document.getElementById('menu-dropdown').style.display = 'none';
            document.getElementById('menu-toggle').classList.remove('active');
        }
        
        function toggleCondensed() {
            isCondensed = !isCondensed;
            localStorage.setItem('isCondensed', JSON.stringify(isCondensed));
            
            const card = document.getElementById('participants-table-card');
            const condensedText = document.getElementById('condensed-text');
            
            if (isCondensed) {
                card.classList.add('condensed-mode');
                condensedText.textContent = 'Expand Layout';
            } else {
                card.classList.remove('condensed-mode');
                condensedText.textContent = 'Condense Layout';
            }
            
            // Close menu
            document.getElementById('menu-dropdown').style.display = 'none';
            document.getElementById('menu-toggle').classList.remove('active');
        }
        
        function parseCSVRobust(csvText) {
            // Robust CSV parser that handles quoted fields with newlines, escaped quotes, and proper field separation
            // This prevents line returns within quoted field values from being treated as new rows
            const rows = [];
            let current = '';
            let inQuotes = false;
            let currentRow = [];
            let currentField = '';
            
            for (let i = 0; i < csvText.length; i++) {
                const char = csvText[i];
                const nextChar = csvText[i + 1];
                
                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        // Handle escaped quotes ("" inside quoted field)
                        currentField += '"';
                        i++; // Skip next quote
                    } else {
                        // Toggle quote state
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    // End of field
                    currentRow.push(currentField.trim());
                    currentField = '';
                } else if ((char === '\n' || char === '\r\n') && !inQuotes) {
                    // End of row (only if not inside quotes)
                    currentRow.push(currentField.trim());
                    if (currentRow.length > 0 && currentRow.some(field => field !== '')) {
                        rows.push(currentRow);
                    }
                    currentRow = [];
                    currentField = '';
                    
                    // Skip \r if we're at \r\n
                    if (char === '\r' && nextChar === '\n') {
                        i++;
                    }
                } else if (char === '\r' && !inQuotes) {
                    // Handle standalone \r as row separator
                    currentRow.push(currentField.trim());
                    if (currentRow.length > 0 && currentRow.some(field => field !== '')) {
                        rows.push(currentRow);
                    }
                    currentRow = [];
                    currentField = '';
                } else {
                    // Regular character or newline inside quotes
                    currentField += char;
                }
            }
            
            // Handle last field and row
            if (currentField !== '' || currentRow.length > 0) {
                currentRow.push(currentField.trim());
                if (currentRow.length > 0 && currentRow.some(field => field !== '')) {
                    rows.push(currentRow);
                }
            }
            
            return rows;
        }

        function showAllLists() {
            // Show loading status for list of lists
            document.getElementById('loadStatus').innerHTML = '<div class="loading-message">Loading list of lists...</div>';
            document.getElementById('loadStatus').style.display = 'block';
            
            // Load and display the meta-list Google Sheet with all feeds
            const masterSheetUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSxfv7lxikjrmro3EJYGE_134vm5HdDszZKt4uKswHhsNJ_-afSaG9RoA4oeNV656r4mTuG3wTu38pM/pub?output=csv';
            
            // Clear current data immediately to prevent flash
            const tableContainer = document.getElementById('participants-table-container');
            const participantsTableCard = document.getElementById('participants-table-card');
            
            // Hide the table card first to prevent flash
            if (participantsTableCard) {
                participantsTableCard.style.display = 'none';
            }
            
            // Clear table content and show loading state
            if (tableContainer) {
                tableContainer.innerHTML = '<div class="loading-state">Loading feeds list...</div>';
            }
            
            // Load the master sheet data
            fetch(masterSheetUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(csvText => {
                    // Check if we got HTML instead of CSV (redirect or error)
                    if (csvText.trim().toLowerCase().startsWith('<html')) {
                        throw new Error('Received HTML instead of CSV data');
                    }
                    
                    // Parse CSV data with robust parser that handles newlines in quoted fields
                    const rows = parseCSVRobust(csvText);
                    if (rows.length === 0) {
                        throw new Error('No data found in CSV');
                    }

                    // Define contEl before using it
                    const contEl = document.getElementById('participants-map-container');
                    try {
                        if (contEl) {
                            const listParam = (typeof getHash === 'function') ? getHash().list : null;
                            if (listParam === 'modelteam') {
                                contEl.style.display = 'block';
                            } else {
                                contEl.style.display = 'none';
                            }
                        }
                    } catch (e) { if (contEl) contEl.style.display = 'block'; }
                    const headers = rows[0];
                    const feedsData = [];
                    
                    // Check if this is a geo site for filtering
                    const isGeoSiteCheck = isGeoSite();
                    document.getElementById('participants-map-no-data').style.display = 'none';
                    try {
                        const contEl2 = document.getElementById('participants-map-container');
                        const listParam2 = (typeof getHash === 'function') ? getHash().list : null;
                        if (contEl2) {
                            if (listParam2 === 'modelteam') contEl2.style.display = 'block'; else contEl2.style.display = 'none';
                        }
                    } catch (e) {
                        try {
                            const listParam = (typeof getHash === 'function') ? getHash().list : null;
                            const pmc3 = document.getElementById('participants-map-container');
                            if (pmc3) {
                                if (listParam === 'modelteam') pmc3.style.display = 'block'; else pmc3.style.display = 'none';
                            }
                        } catch(e) { try { document.getElementById('participants-map-container').style.display = 'block'; } catch(e){} }
                    }
                    // Track skipped binary files for reporting
                    const skippedBinaryFiles = [];
                    
                    // Parse data rows
                    for (let i = 1; i < rows.length; i++) {
                        const values = rows[i];
                        if (values.length > 0) {
                            const feedEntry = {};
                            headers.forEach((header, index) => {
                                feedEntry[header] = values[index] || '';
                            });
                            
                            // Filter entries for geo sites (check the 'List' field)
                            if (isGeoSiteCheck) {
                                const listValue = feedEntry['List'] || feedEntry['list'];
                                if (!allowedGeoOptions.includes(listValue)) {
                                    continue; // Skip this entry for geo sites
                                }
                            }
                            
                            // Filter out large binary/non-data files to prevent CPU overload (but allow .h5 files)
                            const url = feedEntry['URL'] || '';
                            const h5Extensions = ['.hdf5', '.h5'];
                            const otherBinaryExtensions = ['.tiff', '.tif', '.pdf', '.png', '.jpg', '.jpeg', '.zip', '.tar', '.gz'];
                            
                            const isH5File = h5Extensions.some(ext => url.toLowerCase().includes(ext));
                            const isOtherBinaryFile = otherBinaryExtensions.some(ext => url.toLowerCase().includes(ext));
                            
                            if (isOtherBinaryFile) {
                                const title = feedEntry['Title'] || feedEntry['List'] || 'Unknown';
                                skippedBinaryFiles.push({ title, url: url.split('/').pop() });
                                console.log(`Skipping binary file: ${title} (${url})`);
                                continue; // Skip binary files to prevent processing overload
                            }
                            
                            // Allow .h5 files to proceed (they will be handled by the HDF5 proxy)
                            
                            feedsData.push(feedEntry);
                        }
                    }
                    
                    // Display the feeds data using the existing display system
                    currentData = feedsData;
                    // Reset team legend flag for new data
                    initialTeamLegendGenerated = false;
                    displayTableLayout(feedsData, 'All Available Lists');
                    
                    // Update the page title
                    //document.title = 'All Available Lists';
                    
                    // Show UI elements after successful feeds load
                    showListDisplayElements();
                    
                    // Update status to show completion
                    document.getElementById('loadStatus').innerHTML = `<div class="success-message">Loaded ${feedsData.length} lists.</div>`;
                    document.getElementById('loadStatus').style.display = 'block';
                    
                    // Report skipped binary files if any
                    if (skippedBinaryFiles.length > 0) {
                        const skippedList = skippedBinaryFiles.map(item => `• ${item.title} (${item.url})`).join('<br>');
                        showTopMessage(
                            `<strong>Binary Files Excluded</strong><br>` +
                            `${skippedBinaryFiles.length} binary files were excluded from the list to prevent performance issues:<br><br>` +
                            `${skippedList}<br><br>` +
                            `<small>These files cannot be processed as tabular data.</small>`,
                            'warning',
                            10000
                        );
                    }
                    
                    // Update URL hash to list=all
                    updateListHashParam('all');
                    
                    // Close menu
                    document.getElementById('menu-dropdown').style.display = 'none';
                    document.getElementById('menu-toggle').classList.remove('active');
                })
                .catch(error => {
                    console.error('Error loading feeds list:', error);
                    if (tableContainer) {
                        tableContainer.innerHTML = '<div class="error-state">Error loading feeds list. Please try again.<br><small>Error: ' + error.message + '</small></div>';
                    }
                    
                    // Show error in status
                    document.getElementById('loadStatus').innerHTML = '<div class="error-message">Error loading list of lists</div>';
                    document.getElementById('loadStatus').style.display = 'block';
                    
                    // Update URL hash to list=all even on error to maintain state
                    updateListHashParam('all');
                });
        }

        async function refreshListsCSV() {
            const SHEET_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSxfv7lxikjrmro3EJYGE_134vm5HdDszZKt4uKswHhsNJ_-afSaG9RoA4oeNV656r4mTuG3wTu38pM/pub?output=csv';
            const refreshItem = document.getElementById('refresh-csv-toggle');
            const refreshText = refreshItem.querySelector('span');
            const originalText = refreshText.textContent;
            
            // Show loading message in top area
            showTopMessage(
                '<strong>Refreshing Lists.csv</strong><br>Downloading latest data from Google Sheets and comparing with local file...', 
                'warning', 
                0 // Don't auto-hide while processing
            );
            
            // Function to parse CSV text into array of objects using robust parser
            function parseCSV(csvText) {
                const rows = parseCSVRobust(csvText);
                if (rows.length === 0) return [];
                
                const headers = rows[0];
                return rows.slice(1).map(values => {
                    const obj = {};
                    headers.forEach((header, index) => {
                        obj[header] = values[index] || '';
                    });
                    return obj;
                });
            }
            
            // Function to compare CSV data and find changes
            function compareCSVData(oldData, newData) {
                const changes = {
                    added: [],
                    removed: [],
                    modified: []
                };
                
                // Create maps for easier comparison (using List as unique identifier)
                const oldMap = new Map(oldData.map(row => [row.List, row]));
                const newMap = new Map(newData.map(row => [row.List, row]));
                
                // Find added rows
                for (const [list, row] of newMap) {
                    if (!oldMap.has(list)) {
                        changes.added.push(row);
                    }
                }
                
                // Find removed and modified rows
                for (const [list, oldRow] of oldMap) {
                    if (!newMap.has(list)) {
                        changes.removed.push(oldRow);
                    } else {
                        const newRow = newMap.get(list);
                        // Check if any fields changed
                        const fieldsChanged = Object.keys(oldRow).some(key => 
                            oldRow[key] !== newRow[key]
                        );
                        if (fieldsChanged) {
                            changes.modified.push({
                                old: oldRow,
                                new: newRow,
                                list: list
                            });
                        }
                    }
                }
                
                return changes;
            }
            
            try {
                // Show loading state
                refreshText.textContent = 'Refreshing...';
                refreshItem.style.opacity = '0.6';
                
                // Load current cached data for comparison
                let currentCSVText = '';
                let currentData = [];
                
                try {
                    // Try to load from local file first
                    const currentResponse = await fetch('./lists.csv');
                    if (currentResponse.ok) {
                        currentCSVText = await currentResponse.text();
                        currentData = parseCSV(currentCSVText);
                    }
                } catch (fileError) {
                    // Fallback to localStorage if file not accessible
                    const fallbackCSV = localStorage.getItem('fallbackCSV');
                    if (fallbackCSV) {
                        currentCSVText = fallbackCSV;
                        currentData = parseCSV(currentCSVText);
                    }
                }
                
                const beforeRowCount = currentData.length;
                console.log(`Current cached list has ${beforeRowCount} rows`);
                
                console.log('Manually refreshing lists.csv from Google Sheets...');
                const response = await fetch(SHEET_URL);
                
                if (!response.ok) {
                    throw new Error(`Google Sheets fetch failed: ${response.status} ${response.statusText}`);
                }
                
                const csvText = await response.text();
                const newData = parseCSV(csvText);
                const afterRowCount = newData.length;
                
                // Compare data and generate change report
                const changes = compareCSVData(currentData, newData);
                const totalChanges = changes.added.length + changes.removed.length + changes.modified.length;
                
                // Log detailed comparison results
                console.log(`\n=== CSV Refresh Results ===`);
                console.log(`Before: ${beforeRowCount} rows`);
                console.log(`After: ${afterRowCount} rows`);
                console.log(`Net change: ${afterRowCount - beforeRowCount > 0 ? '+' : ''}${afterRowCount - beforeRowCount} rows`);
                console.log(`Total changes: ${totalChanges}`);
                
                if (changes.added.length > 0) {
                    console.log(`\n✅ Added (${changes.added.length}):`);
                    changes.added.forEach(row => {
                        console.log(`  + ${row.List}: ${row.Title || 'No title'}`);
                    });
                }
                
                if (changes.removed.length > 0) {
                    console.log(`\n❌ Removed (${changes.removed.length}):`);
                    changes.removed.forEach(row => {
                        console.log(`  - ${row.List}: ${row.Title || 'No title'}`);
                    });
                }
                
                if (changes.modified.length > 0) {
                    console.log(`\n🔄 Modified (${changes.modified.length}):`);
                    changes.modified.forEach(change => {
                        console.log(`  ~ ${change.list}: ${change.new.Title || 'No title'}`);
                        // Log specific field changes
                        Object.keys(change.old).forEach(key => {
                            if (change.old[key] !== change.new[key]) {
                                console.log(`    ${key}: "${change.old[key]}" → "${change.new[key]}"`);
                            }
                        });
                    });
                }
                
                if (totalChanges === 0) {
                    console.log(`\n✅ No changes detected`);
                }
                console.log(`=========================\n`);

                // Save to local file using Rust API endpoint
                try {
                    const saveResponse = await fetch('http://localhost:8081/api/files/csv', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            filename: 'lists.csv',
                            content: csvText
                        })
                    });
                    
                    if (saveResponse.ok) {
                        const result = await saveResponse.json();
                        console.log('Successfully saved CSV to ./lists.csv:', result);
                        
                        // Show detailed success message with change count
                        const changeText = totalChanges > 0 ? ` (${totalChanges} changes)` : ' (no changes)';
                        refreshText.textContent = `Refreshed ✓${changeText}`;
                        
                        // Show success message in top area
                        const changeMessage = totalChanges > 0 ? 
                            `<strong>Lists.csv Successfully Refreshed</strong><br>Updated with ${totalChanges} changes from Google Sheets and saved to the server.` :
                            `<strong>Lists.csv Successfully Refreshed</strong><br>No changes detected. File is up to date with Google Sheets.`;
                        
                        showTopMessage(changeMessage, 'success', 5000);
                        
                        // Always reload dropdown options from updated lists.csv (even if no changes detected)
                        if (typeof loadGoogleSheetConfig === 'function') {
                            console.log('Reloading dropdown options from updated lists.csv...');
                            
                            // Clear any potential browser cache for lists.csv by adding cache-busting parameter
                            const timestamp = Date.now();
                            console.log('Cache-busting timestamp:', timestamp);
                            
                            await loadGoogleSheetConfig(fileSelect, 'list');
                            console.log('Dropdown options reloaded successfully');
                        }
                        
                        // Show success feedback briefly
                        setTimeout(() => {
                            refreshText.textContent = originalText;
                        }, 4000); // Extended time to read change info
                        
                        // Close menu
                        document.getElementById('menu-dropdown').style.display = 'none';
                        document.getElementById('menu-toggle').classList.remove('active');
                        
                    } else {
                        const error = await saveResponse.json();
                        throw new Error(error.error || 'Server save failed');
                    }
                    
                } catch (saveError) {
                    console.error('Failed to save CSV file:', saveError);
                    
                    // Check if this is a connection refused error (Rust server not running)
                    if (saveError.message.includes('Failed to fetch') || saveError.toString().includes('ERR_CONNECTION_REFUSED')) {
                        showTopMessage(
                            '<strong>Rust API Server Not Running</strong><br>' +
                            'The Rust server at localhost:8081 is not available. ' +
                            'To start it, run:<br>' +
                            '<code style="background: rgba(0,0,0,0.1); padding: 2px 4px; border-radius: 3px;">cd team && cargo run --bin partner_tools -- serve</code><br>' +
                            'CSV data has been cached in browser storage as a fallback.',
                            'error',
                            15000 // Show for 15 seconds
                        );
                    } else {
                        showTopMessage(
                            '<strong>Failed to Save CSV</strong><br>' +
                            'Error: ' + saveError.message + '<br>' +
                            'CSV data has been cached in browser storage as a fallback.',
                            'error',
                            10000
                        );
                    }
                    
                    // Fallback to localStorage
                    localStorage.setItem('fallbackCSV', csvText);
                    localStorage.setItem('fallbackCSVTimestamp', Date.now().toString());
                    
                    console.log('Stored CSV in localStorage as fallback');
                    
                    // Show cached message with change count
                    const changeText = totalChanges > 0 ? ` (${totalChanges} changes)` : ' (no changes)';
                    refreshText.textContent = `Cached ✓${changeText}`;
                    
                    // Still try to reload dropdown options even when data is cached
                    if (typeof loadGoogleSheetConfig === 'function') {
                        console.log('Attempting to reload dropdown options after caching fallback...');
                        try {
                            await loadGoogleSheetConfig(fileSelect, 'list');
                            console.log('Dropdown options reloaded successfully from cached data');
                        } catch (error) {
                            console.log('Could not reload dropdown options:', error.message);
                        }
                    }
                    
                    setTimeout(() => {
                        refreshText.textContent = originalText;
                    }, 4000); // Extended time to read change info
                    
                    // Close menu
                    document.getElementById('menu-dropdown').style.display = 'none';
                    document.getElementById('menu-toggle').classList.remove('active');
                }
                
            } catch (error) {
                console.error('Failed to refresh lists.csv:', error);
                refreshText.textContent = 'Failed ✗';
                
                setTimeout(() => {
                    refreshText.textContent = originalText;
                }, 2000);
            } finally {
                refreshItem.style.opacity = '1';
            }
        }

        function toggleSelectList() {
            const fileSelectContainer = document.querySelector('#fileSelect').parentElement.parentElement;
            const selectListText = document.getElementById('select-list-text');
            
            if (!fileSelectContainer) {
                console.error('File selection container not found!');
                return;
            }
            
            // Use getComputedStyle to get the actual display value
            const computedStyle = window.getComputedStyle(fileSelectContainer);
            const isVisible = computedStyle.display !== 'none';
            
            if (isVisible) {
                fileSelectContainer.style.display = 'none';
                selectListText.textContent = 'Select List';
            } else {
                fileSelectContainer.style.display = 'block';
                selectListText.textContent = 'Hide List';
            }
            
            // Close menu
            document.getElementById('menu-dropdown').style.display = 'none';
            document.getElementById('menu-toggle').classList.remove('active');
        }
        
        function updateCondensedViewButtons() {
            // Update active state for condensed view buttons
            document.querySelectorAll('.view-buttons-condensed .condensed-icon-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const activeBtn = document.getElementById(currentView + '-view-condensed');
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
        }
        
        function toggleFiltersDropdown() {
            const dropdown = document.getElementById('filters-dropdown');
            const isVisible = dropdown.style.display === 'block';
            
            if (isVisible) {
                dropdown.style.display = 'none';
            } else {
                dropdown.style.display = 'block';
            }
        }
        
        function restoreLayoutState() {
            const fullscreenText = document.getElementById('fullscreen-text');
            const condensedText = document.getElementById('condensed-text');
            
            // Restore fullscreen state
            if (isFullscreen) {
                document.body.classList.add('fullscreen-mode');
                fullscreenText.textContent = 'Exit Fullscreen';
                document.body.style.overflow = 'hidden';
            } else {
                fullscreenText.textContent = 'View Fullscreen';
            }
            
            // Restore condensed state
            const card = document.getElementById('participants-table-card');
            if (isCondensed) {
                card.classList.add('condensed-mode');
                condensedText.textContent = 'Expand Layout';
            } else {
                condensedText.textContent = 'Condense Layout';
            }
        }
        // Load README documentation and configuration
        document.addEventListener('DOMContentLoaded', async function() {
            
            // Load dropdown options from lists.csv with proper CORS attributes
            if (typeof loadGoogleSheetConfig === 'function') {
                const fileSelect = document.getElementById('fileSelect');
                if (fileSelect) {
                    console.log('Loading dropdown options from lists.csv...');
                    await loadGoogleSheetConfig(fileSelect, 'list');
                }
            }
            
            // Restore saved view state
            restoreViewState();
            restoreLayoutState();
            
            // Initialize condensed view buttons
            updateCondensedViewButtons();
            
            // Note: loadGroupParticipants() is now called after file initialization
            
            // Check and update group participants panel visibility on page load
            updateGroupParticipantsVisibility();
            
            // Initialize group snapshot info display
            updateGroupSnapshotInfo();
            
            // Initialize group field event listeners for checkbox synchronization
            const groupField = document.getElementById('group');
            if (groupField) {
                // Sync checkboxes when group field changes
                groupField.addEventListener('input', syncCheckboxesWithGroup);
                groupField.addEventListener('change', syncCheckboxesWithGroup);
                
                // Auto-format names when user clicks off the field
                groupField.addEventListener('blur', function() {
                    formatGroupFieldNames();
                    syncCheckboxesWithGroup();
                });
                
                // Initial sync when page loads
                setTimeout(syncCheckboxesWithGroup, 100);
            }
            
            // Add modelteam option to dropdown if it doesn't exist (temporary fix)
            addModelteamOption();
            
            // Set initial header visibility based on current hash (with delay to ensure dropdown is populated)
            setTimeout(updateHeaderVisibility, 500);

            // Ensure Contributions button and participants map visibility reflect initial hash
            setTimeout(updateContribsButtonVisibility, 550);
            
            // Initialize insights visibility from URL (with delay to ensure DOM is ready)
            setTimeout(checkInsightsFromURL, 100);
            
            // Listen for URL changes to handle list parameter changes
            // hashChangeEvent and getHash reside in localsite/js/localsite.js
            document.addEventListener('hashChangeEvent', function (elem) { 

                console.log("team/projects detects hashChangeEvent")

                updateGroupParticipantsVisibility();

                const listParam = getHash().list;
                console.log('HASHCHANGE: Processing list parameter:', listParam);
                
                // Update UI for hash changes (header visibility and title)
                updateUIForHashChange();
                
                // Update list select visibility
                updateListSelectVisibility();
                
                // Update group control visibility
                updateGroupParticipantsVisibility();
                
                // Update menu visibility
                updateMenuVisibility();
                
                checkInsightsFromURL();

                // Handle list parameter changes - only load data if list actually changed
                if (listParam && listParam !== currentLoadedList) {
                    console.log('HASHCHANGE: List changed from', currentLoadedList, 'to', listParam);
                    currentLoadedList = listParam;
                    
                    // Hide UI elements and clear filters when list changes
                    hideListDisplayElements();
                    clearAllFilters();
                    
                    // Check if the option exists in the dropdown
                    const targetOption = Array.from(fileSelect.options).find(option => option.value === listParam);
                    if (targetOption) {
                        console.log('HASHCHANGE: Found option for:', listParam);
                        
                        // Update dropdown selection if needed
                        if (listParam !== fileSelect.value) {
                            console.log('HASHCHANGE: Updating dropdown to match hash:', listParam);
                            fileSelect.value = listParam;
                        }
                        
                        // Update selectedFile and load data
                        selectedFile = targetOption.getAttribute('data-url') || listParam;
                        
                        // Load the corresponding data
                        if (listParam === 'all') {
                            console.log('HASHCHANGE: Loading all feeds');
                            showAllLists();
                        } else {
                            console.log('HASHCHANGE: Loading participant data for:', listParam, 'URL:', selectedFile);
                            getSubsetUsingSnapshot();
                        }
                    } else {
                        console.log('HASHCHANGE: List param not found in dropdown options:', listParam);
                        // Display user-visible message about unavailable list
                        appendStatusMessage(`📋 List "${listParam}" is not available in the current dropdown options. Please select from available options.`, 'info');
                    }
                } else if (listParam) {
                    console.log('HASHCHANGE: List param unchanged:', listParam, '- skipping data reload');
                }

                const displayParam = getHash().display || 'column'; // Default to column if absent
                if (['column', 'table', 'gallery'].includes(displayParam) && displayParam !== currentView) {
                    switchView(displayParam);
                }

            
            
                const teamParam = getHash().team;
                if (teamParam !== currentTeamFilter) {
                    console.log('🔗 Team parameter changed in URL hash:', teamParam);
                    currentTeamFilter = teamParam;
                    
                    // Save to localStorage
                    if (currentTeamFilter) {
                        localStorage.setItem(getListStorageKey('participantsTeamFilter'), currentTeamFilter);
                    } else {
                        localStorage.removeItem(getListStorageKey('participantsTeamFilter'));
                    }
                    
                    // Apply filters
                    applyAllFilters();
                }

                const statusParam = getHash().status;
                const newStatuses = statusParam ? statusParam.split(',') : ['All'];
                const currentStatusArray = Array.from(selectedStatuses);
                
                // Only update if the status selection has actually changed to avoid infinite loops
                if (JSON.stringify(currentStatusArray.sort()) !== JSON.stringify(newStatuses.sort())) {
                    console.log('🔗 Status parameter changed in URL hash:', statusParam);
                    selectedStatuses = new Set(newStatuses);
                    
                    // Save to localStorage
                    localStorage.setItem(getListStorageKey('participantsStatusFilter'), JSON.stringify(Array.from(selectedStatuses)));
                    
                    // Update UI
                    updateStatusButtonText();
                    generateStatusDropdown();
                    
                    // Apply filters
                    applyAllFilters();
                }
            });
            
            // Initialize file selection
            await initializeFileSelection();

            // Ensure visibility of list-select buttons (Insights, Contributions) after initialization
            try { updateListSelectVisibility(); } catch (e) { console.warn('updateListSelectVisibility missing', e); }
            
            // Load group participants after file initialization is complete
            // This ensures clearAllFilters() doesn't wipe out localStorage values
            // Add small delay to ensure DOM is fully ready
            setTimeout(() => {
                console.log('🕐 Loading group participants after DOM is ready');
                loadGroupParticipants();
            }, 100);
            
            // Check for list=all in URL hash to auto-load meta list
            const listParam = getHash().list;
            if (listParam === 'all') {
                showAllLists();
            } else if (listParam === 'geo') {
                // Auto-load geo data
                getSubsetUsingSnapshot();
            } else if (!listParam) {
                // No list parameter - check if should default to geo
                const shouldDefaultToGeo = isGeoSite();
                if (shouldDefaultToGeo) {
                    window.location.hash = 'list=geo';
                    fileSelect.value = 'geo';
                    selectedFile = 'map/cities.csv';
                    getSubsetUsingSnapshot();
                } else {
                    // Auto-load data if default option is selected
                    const selectedOption = fileSelect.options[fileSelect.selectedIndex];
                    if (selectedOption && selectedOption.getAttribute('data-url')) {
                        getSubsetUsingSnapshot();
                    }
                }
            } else {
                // Auto-load data if default option is selected
                const selectedOption = fileSelect.options[fileSelect.selectedIndex];
                if (selectedOption && selectedOption.getAttribute('data-url')) {
                    getSubsetUsingSnapshot();
                }
            }
            
            // Set initial menu visibility state
            updateMenuVisibility();
            
            // Initialize group snapshot info display
            updateGroupSnapshotInfo();
            
            // Show "Refresh lists.csv" option only on localhost
            if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
                document.getElementById('refresh-csv-toggle').style.display = 'block';
            }
            
            // Load snapshot if no auto-data loading occurred
            setTimeout(() => {
                // Only load snapshot if no data was auto-loaded
                if (!window.participantsData || window.participantsData.length === 0) {
                    loadSnapshotOnPageLoad();
                }
            }, 500);
            
            // Add event listeners for 3-dot menu
            document.getElementById('menu-toggle').addEventListener('click', toggleMenu);
            
            document.getElementById('list-feeds-toggle').addEventListener('click', showAllLists);
            document.getElementById('refresh-csv-toggle').addEventListener('click', refreshListsCSV);
            
            document.getElementById('fullscreen-toggle').addEventListener('click', toggleFullscreen);
            document.getElementById('condensed-toggle').addEventListener('click', toggleCondensed);
            document.getElementById('raw-data-toggle').addEventListener('click', toggleRawData);
            document.getElementById('export-csv-menu').addEventListener('click', exportCSVFromMenu);
            document.getElementById('full-url-toggle').addEventListener('click', generateFullURL);
            const snapshotsToggle = document.getElementById('snapshots-toggle');
            if (snapshotsToggle) {
                snapshotsToggle.addEventListener('click', toggleSnapshots);
            }
            
            // Snapshots event listeners
            const closeSnapshots = document.getElementById('close-snapshots');
            if (closeSnapshots) {
                closeSnapshots.addEventListener('click', () => {
                    const snapshotsControl = document.getElementById('snapshots-control');
                    if (snapshotsControl) {
                        snapshotsControl.style.display = 'none';
                    }
                });
            }
            
            const addSnapshotBtn = document.getElementById('add-snapshot-btn');
            if (addSnapshotBtn) {
                addSnapshotBtn.addEventListener('click', addNewSnapshot);
            }
            
            const newSnapshotName = document.getElementById('new-snapshot-name');
            if (newSnapshotName) {
                newSnapshotName.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        addNewSnapshot();
                    }
                });
            }
            
            // Add event listeners for condensed view controls
            document.getElementById('filters-toggle').addEventListener('click', toggleFiltersDropdown);
            
            // Add event listeners for condensed view buttons
            document.querySelectorAll('.view-buttons-condensed .condensed-icon-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const view = this.dataset.view;
                    switchView(view);
                });
            });
            
            // Add event listeners for condensed filters dropdown
            document.getElementById('condensed-sort-toggle').addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                document.getElementById('filters-dropdown').style.display = 'none';
                toggleSortDropdown();
            });
            
            document.getElementById('condensed-status-toggle').addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                document.getElementById('filters-dropdown').style.display = 'none';
                toggleStatusDropdown();
            });
            
            // Close dropdowns when clicking outside
            document.addEventListener('click', function(e) {
                const menuDropdown = document.getElementById('menu-dropdown');
                const menuToggle = document.getElementById('menu-toggle');
                const filtersDropdown = document.getElementById('filters-dropdown');
                const filtersToggle = document.getElementById('filters-toggle');
                
                if (!menuDropdown.contains(e.target) && !menuToggle.contains(e.target)) {
                    menuDropdown.style.display = 'none';
                    menuToggle.classList.remove('active');
                }
                
                if (!filtersDropdown.contains(e.target) && !filtersToggle.contains(e.target)) {
                    filtersDropdown.style.display = 'none';
                }
            });
        });
        
        // Pagination functions
        function updatePaginationControls() {
            const totalPages = Math.ceil(totalRecords / recordsPerPage);
            const paginationControls = document.querySelector('.pagination-controls');
            const prevBtn = document.getElementById('prev-page');
            const nextBtn = document.getElementById('next-page');
            
            if (totalRecords > recordsPerPage) {
                paginationControls.style.display = 'flex';
                prevBtn.disabled = currentPage <= 1;
                nextBtn.disabled = currentPage >= totalPages;
            } else {
                paginationControls.style.display = 'none';
            }
        }
        
        function updateResultsCount(filteredData) {
            const resultsCount = document.getElementById('results-count');
            if (!resultsCount) return;
            
            totalRecords = filteredData.length;
            const originalTotal = originalLoadedCount || totalRecords;
            const totalPages = Math.ceil(totalRecords / recordsPerPage);
            const startRecord = Math.min((currentPage - 1) * recordsPerPage + 1, totalRecords);
            const endRecord = Math.min(currentPage * recordsPerPage, totalRecords);
            
            if (totalRecords === 0) {
                resultsCount.textContent = `0 results in ${totalRecords} (of ${originalTotal})`;
            } else if (totalRecords <= recordsPerPage) {
                if (totalRecords === originalTotal) {
                    // No filtering applied
                    resultsCount.textContent = `${totalRecords} result${totalRecords !== 1 ? 's' : ''}`;
                } else {
                    // Filtering applied
                    resultsCount.textContent = `${totalRecords} result${totalRecords !== 1 ? 's' : ''} (of ${originalTotal})`;
                }
            } else {
                resultsCount.textContent = `${startRecord} to ${endRecord} results in ${totalRecords} (of ${originalTotal})`;
            }
            
            updatePaginationControls();
        }
        
        function paginateData(data) {
            const startIndex = (currentPage - 1) * recordsPerPage;
            const endIndex = Math.min(startIndex + recordsPerPage, data.length);
            
            // For large datasets, check if we need to load more data
            if (window.isLargeDataset && endIndex >= data.length && window.originalLargeDataset) {
                const totalNeeded = currentPage * recordsPerPage;
                const currentAvailable = data.length;
                
                if (totalNeeded > currentAvailable && window.originalLargeDataset.length > currentAvailable) {
                    console.log(`📄 Page ${currentPage} needs more data. Loading additional chunk...`);
                    
                    // Calculate how much more data we need
                    const additionalNeeded = Math.min(
                        recordsPerPage * 3, // Load 3 pages worth
                        window.originalLargeDataset.length - currentAvailable
                    );
                    
                    if (additionalNeeded > 0) {
                        const nextChunk = window.originalLargeDataset.slice(
                            currentAvailable, 
                            currentAvailable + additionalNeeded
                        );
                        
                        console.log(`🔄 Processing additional ${nextChunk.length} records (${currentAvailable} to ${currentAvailable + additionalNeeded})`);
                        const processedChunk = preprocessParticipantData(nextChunk);
                        
                        // Add to existing data
                        if (window.allRowsData) {
                            window.allRowsData = window.allRowsData.concat(processedChunk);
                            data = window.allRowsData;
                        }
                        
                        console.log(`✅ Total processed data now: ${data.length} records`);
                    }
                }
            }
            
            const finalEndIndex = Math.min(startIndex + recordsPerPage, data.length);
            const result = data.slice(startIndex, finalEndIndex);
            
            if (result.length > 0) {
                console.log(`📄 Pagination: Showing page ${currentPage}, records ${startIndex + 1}-${startIndex + result.length} of ${window.originalLargeDataset ? window.originalLargeDataset.length : data.length}`);
            }
            
            return result;
        }
        
        function goToPage(page) {
            const totalPages = Math.ceil(totalRecords / recordsPerPage);
            if (page >= 1 && page <= totalPages) {
                currentPage = page;
                applyAllFilters(); // Re-apply filters and refresh display
            }
        }
        
        // Add pagination event listeners
        document.getElementById('prev-page').addEventListener('click', () => {
            goToPage(currentPage - 1);
        });
        
        document.getElementById('next-page').addEventListener('click', () => {
            goToPage(currentPage + 1);
        });

        // Image Gallery Functionality
        
        // Extract image paths from participant data
        function extractImagePaths(participantData) {
            const imagePaths = [];
            const imageExtensions = /\.(jpg|jpeg|png|gif|webp|svg)$/i;
            
            // Check all fields for image paths
            Object.values(participantData).forEach(value => {
                if (typeof value === 'string') {
                    // Split by common delimiters and check each part
                    const parts = value.split(/[,;\s\n\r]+/);
                    parts.forEach(part => {
                        const trimmed = part.trim();
                        if (trimmed && imageExtensions.test(trimmed)) {
                            // Convert relative paths to absolute if needed
                            let imagePath = trimmed;
                            if (!imagePath.startsWith('http') && !imagePath.startsWith('/')) {
                                imagePath = imagePath.startsWith('../') ? imagePath : '../' + imagePath;
                            }
                            imagePaths.push(imagePath);
                        }
                    });
                }
            });
            
            return imagePaths.slice(0, 9); // Limit to 9 images max
        }

        // Create image container with navigation
        function createImageContainer(imagePaths, isGalleryView = false) {
            if (!imagePaths || imagePaths.length === 0) {
                return `<div class="no-image-placeholder">No images available</div>`;
            }

            const containerId = 'img-' + Math.random().toString(36).substr(2, 9);
            const height = isGalleryView ? 140 : 120;
            
            let html = `<div class="columns-image-container" id="${containerId}" data-current="0" data-auto-advance="false" data-image-paths='${JSON.stringify(imagePaths)}'>`;
            
            // Add the first image
            html += `<img class="columns-image" src="${imagePaths[0]}" alt="Project Image" style="height: ${height}px" onclick="openImageInNewTab('${imagePaths[0]}')" onerror="this.style.display='none'; this.nextElementSibling?.style.display='flex';">`;
            
            // Add placeholder for failed images
            html += `<div class="no-image-placeholder" style="display: none;">Image not found</div>`;
            
            // Add navigation dots if multiple images
            if (imagePaths.length > 1) {
                html += `<div class="image-dots-container">`;
                imagePaths.forEach((_, index) => {
                    const activeClass = index === 0 ? ' active' : '';
                    html += `<div class="image-dot${activeClass}" onclick="showImageByIndex('${containerId}', ${index})"></div>`;
                });
                html += `</div>`;
            }
            
            html += `</div>`;
            return html;
        }

        // Show specific image by index
        function showImageByIndex(containerId, index) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            // Get image paths from container data attribute
            const imagePaths = container.dataset.imagePaths ? JSON.parse(container.dataset.imagePaths) : [];
            if (index >= imagePaths.length) return;
            
            const img = container.querySelector('.columns-image');
            const placeholder = container.querySelector('.no-image-placeholder');
            const dots = container.querySelectorAll('.image-dot');
            
            // Update image
            img.src = imagePaths[index];
            img.style.display = 'block';
            placeholder.style.display = 'none';
            
            // Update dots
            dots.forEach((dot, i) => {
                dot.classList.toggle('active', i === index);
            });
            
            // Update current index
            container.dataset.current = index;
        }

        // Auto-advance functionality
        let autoAdvanceIntervals = new Map();

        function startAutoAdvance(containerId, imagePaths) {
            if (imagePaths.length <= 1) return;
            
            const container = document.getElementById(containerId);
            if (!container) return;
            
            container.classList.add('auto-advancing');
            container.dataset.autoAdvance = 'true';
            
            const interval = setInterval(() => {
                if (container.dataset.autoAdvance !== 'true') {
                    clearInterval(interval);
                    return;
                }
                
                const current = parseInt(container.dataset.current) || 0;
                const next = (current + 1) % imagePaths.length;
                showImage(containerId, next, imagePaths);
            }, 3000);
            
            autoAdvanceIntervals.set(containerId, interval);
        }

        function stopAutoAdvance(containerId) {
            const container = document.getElementById(containerId);
            if (container) {
                container.classList.remove('auto-advancing');
                container.dataset.autoAdvance = 'false';
            }
            
            if (autoAdvanceIntervals.has(containerId)) {
                clearInterval(autoAdvanceIntervals.get(containerId));
                autoAdvanceIntervals.delete(containerId);
            }
        }

        // Keyboard navigation
        let focusedContainer = null;

        function handleKeyboardNavigation(event, containerId, imagePaths) {
            if (!focusedContainer || focusedContainer !== containerId) return;
            
            const container = document.getElementById(containerId);
            if (!container || imagePaths.length <= 1) return;
            
            const current = parseInt(container.dataset.current) || 0;
            
            switch(event.key) {
                case 'ArrowRight':
                    event.preventDefault();
                    const next = (current + 1) % imagePaths.length;
                    showImage(containerId, next, imagePaths);
                    break;
                case 'ArrowLeft':
                    event.preventDefault();
                    const prev = (current - 1 + imagePaths.length) % imagePaths.length;
                    showImage(containerId, prev, imagePaths);
                    break;
                case ' ':
                    event.preventDefault();
                    if (container.dataset.autoAdvance === 'true') {
                        stopAutoAdvance(containerId);
                    } else {
                        startAutoAdvance(containerId, imagePaths);
                    }
                    break;
            }
        }

        // Open image in new tab
        function openImageInNewTab(imagePath) {
            window.open(imagePath, '_blank');
        }

        // Gallery view toggle functionality
        function toggleGalleryTextMode(cardElement) {
            cardElement.classList.toggle('text-mode');
            const toggleBtn = cardElement.querySelector('.gallery-toggle-btn');
            const icon = toggleBtn.querySelector('i[data-feather]');
            
            if (cardElement.classList.contains('text-mode')) {
                icon.setAttribute('data-feather', 'image');
                toggleBtn.title = 'Show image';
            } else {
                icon.setAttribute('data-feather', 'info');
                toggleBtn.title = 'Show info';
            }
            
            // Feather icons will be refreshed by nav.js
        }

        // Add event listeners for hover and keyboard navigation
        document.addEventListener('mouseover', (event) => {
            const container = event.target.closest('.columns-image-container');
            if (container && container.querySelectorAll('.image-dot').length > 1) {
                const imagePaths = Array.from(container.querySelectorAll('.image-dot')).map((_, index) => {
                    return container.querySelector('.columns-image').src.replace(/\/[^\/]*$/, '/image' + index + '.jpg'); // This will be replaced with actual paths
                });
                
                // Extract actual image paths from the dots' onclick attributes
                const actualPaths = [];
                container.querySelectorAll('.image-dot').forEach(dot => {
                    const onclickAttr = dot.getAttribute('onclick');
                    if (onclickAttr) {
                        const match = onclickAttr.match(/\[(.*?)\]/);
                        if (match) {
                            try {
                                const paths = JSON.parse(match[1].replace(/&quot;/g, '"'));
                                paths.forEach(path => {
                                    if (!actualPaths.includes(path)) actualPaths.push(path);
                                });
                            } catch (e) {
                                console.warn('Could not parse image paths from onclick attribute');
                            }
                        }
                    }
                });
                
                focusedContainer = container.id;
                if (actualPaths.length > 1) {
                    startAutoAdvance(container.id, actualPaths);
                }
            }
        });

        document.addEventListener('mouseout', (event) => {
            const container = event.target.closest('.columns-image-container');
            if (container && focusedContainer === container.id) {
                stopAutoAdvance(container.id);
                focusedContainer = null;
            }
        });

        document.addEventListener('keydown', (event) => {
            if (focusedContainer) {
                const container = document.getElementById(focusedContainer);
                if (container) {
                    // Extract image paths from dots
                    const actualPaths = [];
                    container.querySelectorAll('.image-dot').forEach(dot => {
                        const onclickAttr = dot.getAttribute('onclick');
                        if (onclickAttr) {
                            const match = onclickAttr.match(/\[(.*?)\]/);
                            if (match) {
                                try {
                                    const paths = JSON.parse(match[1].replace(/&quot;/g, '"'));
                                    paths.forEach(path => {
                                        if (!actualPaths.includes(path)) actualPaths.push(path);
                                    });
                                } catch (e) {
                                    console.warn('Could not parse image paths from onclick attribute');
                                }
                            }
                        }
                    });
                    
                    if (actualPaths.length > 1) {
                        handleKeyboardNavigation(event, focusedContainer, actualPaths);
                    }
                }
            }
        });

        // README and Cache Management Functions
        function showReadmeSection() {
            const readmeSection = document.getElementById('readme-section');
            const toggleBtn = document.getElementById('toggle-readme');
            
            // Show the section
            readmeSection.style.display = 'block';
            toggleBtn.textContent = 'Hide Documentation';
            
            // Close the menu dropdown
            const menuDropdown = document.getElementById('menu-dropdown');
            const menuToggle = document.getElementById('menu-toggle');
            if (menuDropdown) {
                menuDropdown.style.display = 'none';
                menuToggle.classList.remove('active');
            }
            
            // Scroll to the pageControls instead of the documentation section
            const pageControls = document.getElementById('pageControls');
            if (pageControls) {
                pageControls.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }
        
        function toggleReadmeSection() {
            const readmeSection = document.getElementById('readme-section');
            const toggleBtn = document.getElementById('toggle-readme');
            
            if (readmeSection.style.display === 'none' || readmeSection.style.display === '') {
                // Show the section
                readmeSection.style.display = 'block';
                toggleBtn.textContent = 'Hide Documentation';
                
                // Scroll to the pageControls
                const pageControls = document.getElementById('pageControls');
                if (pageControls) {
                    pageControls.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            } else {
                // Hide the section
                readmeSection.style.display = 'none';
                toggleBtn.textContent = 'Show Documentation';
            }
        }

        function loadReadmeDocumentation() {
            // Use the displayFile function from common.js to load README.md
            if (typeof displayFile === 'function') {
                displayFile('README.md', 'readme-content');
            } else {
                // Fallback if displayFile is not available
                fetch('README.md')
                    .then(response => response.text())
                    .then(text => {
                        const readmeContent = document.getElementById('readme-content');
                        // Simple markdown to HTML conversion for basic formatting
                        const html = text
                            .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                            .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                            .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                            .replace(/\*\*(.*)\*\*/gim, '<strong>$1</strong>')
                            .replace(/\*(.*)\*/gim, '<em>$1</em>')
                            .replace(/```([^`]+)```/gim, '<pre><code>$1</code></pre>')
                            .replace(/`([^`]+)`/gim, '<code>$1</code>')
                            .replace(/\n\n/gim, '</p><p>')
                            .replace(/\n/gim, '<br>');
                        readmeContent.innerHTML = '<p>' + html + '</p>';
                    })
                    .catch(error => {
                        console.warn('Could not load README.md:', error);
                        document.getElementById('readme-content').innerHTML = '<p>README.md documentation could not be loaded.</p>';
                    });
            }
        }

        function getAllCacheData() {
            const currentListId = getHash().list || 'default';
            const cacheData = {
                currentList: currentListId,
                globalSettings: {},
                listSpecificSettings: {},
                allSnapshots: {}
            };
            
            // Get all localStorage keys to find all list-specific data
            const allKeys = Object.keys(localStorage);
            const listPattern = /^([^_]+)_1_(.+)$/;
            const discoveredLists = new Set();
            
            // Global settings (not list-specific)
            const participantsViewMode = localStorage.getItem('participantsViewMode');
            if (participantsViewMode) cacheData.globalSettings.participantsViewMode = participantsViewMode;
            
            const isFullscreen = localStorage.getItem('isFullscreen');
            if (isFullscreen) {
                try {
                    cacheData.globalSettings.isFullscreen = JSON.parse(isFullscreen);
                } catch (e) {
                    cacheData.globalSettings.isFullscreen = isFullscreen;
                }
            }
            
            const isCondensed = localStorage.getItem('isCondensed');
            if (isCondensed) {
                try {
                    cacheData.globalSettings.isCondensed = JSON.parse(isCondensed);
                } catch (e) {
                    cacheData.globalSettings.isCondensed = isCondensed;
                }
            }
            
            // AI Insights cache (global)
            const aiInsightsCache = localStorage.getItem('aiInsightsCache');
            if (aiInsightsCache) {
                try {
                    cacheData.globalSettings.aiInsightsCache = JSON.parse(aiInsightsCache);
                } catch (e) {
                    cacheData.globalSettings.aiInsightsCache = aiInsightsCache;
                }
            }
            
            const claudeInsightsCache = localStorage.getItem('claudeInsightsCache');
            if (claudeInsightsCache) {
                try {
                    cacheData.globalSettings.claudeInsightsCache = JSON.parse(claudeInsightsCache);
                } catch (e) {
                    cacheData.globalSettings.claudeInsightsCache = claudeInsightsCache;
                }
            }
            
            // File selection storage
            const fileSelection = localStorage.getItem('PartnerTools_selected_file');
            if (fileSelection) cacheData.globalSettings.lastSelectedFile = fileSelection;
            
            // Custom files
            const customFilesPrefix = 'PartnerTools_customFile_';
            allKeys.forEach(key => {
                if (key.startsWith(customFilesPrefix)) {
                    const fileName = key.replace(customFilesPrefix, '');
                    if (!cacheData.globalSettings.customFiles) cacheData.globalSettings.customFiles = {};
                    try {
                        cacheData.globalSettings.customFiles[fileName] = JSON.parse(localStorage.getItem(key));
                    } catch (e) {
                        cacheData.globalSettings.customFiles[fileName] = localStorage.getItem(key);
                    }
                }
            });
            
            // Scan for all list-specific data
            allKeys.forEach(key => {
                const match = key.match(listPattern);
                if (match) {
                    const listId = match[1];
                    const settingKey = match[2];
                    discoveredLists.add(listId);
                    
                    if (!cacheData.listSpecificSettings[listId]) {
                        cacheData.listSpecificSettings[listId] = {};
                    }
                    
                    const value = localStorage.getItem(key);
                    try {
                        // Try to parse as JSON for arrays and objects
                        if (value && (value.startsWith('[') || value.startsWith('{'))) {
                            cacheData.listSpecificSettings[listId][settingKey] = JSON.parse(value);
                        } else if (value === 'true' || value === 'false') {
                            cacheData.listSpecificSettings[listId][settingKey] = JSON.parse(value);
                        } else {
                            cacheData.listSpecificSettings[listId][settingKey] = value;
                        }
                    } catch (e) {
                        cacheData.listSpecificSettings[listId][settingKey] = value;
                    }
                }
            });
            
            // Get snapshots for all discovered lists
            discoveredLists.forEach(listId => {
                const snapshotsKey = `${listId}_1_snapshots`;
                const snapshots = localStorage.getItem(snapshotsKey);
                if (snapshots) {
                    try {
                        cacheData.allSnapshots[listId] = JSON.parse(snapshots);
                    } catch (e) {
                        cacheData.allSnapshots[listId] = snapshots;
                    }
                }
            });
            
            // Summary information
            cacheData.summary = {
                discoveredLists: Array.from(discoveredLists).sort(),
                totalListSpecificKeys: Object.values(cacheData.listSpecificSettings).reduce((acc, settings) => acc + Object.keys(settings).length, 0),
                totalGlobalKeys: Object.keys(cacheData.globalSettings).length,
                totalSnapshotCollections: Object.keys(cacheData.allSnapshots).length,
                totalSnapshots: Object.values(cacheData.allSnapshots).reduce((acc, snapshots) => {
                    return acc + (typeof snapshots === 'object' ? Object.keys(snapshots).length : 0);
                }, 0)
            };
            
            return cacheData;
        }

        function objectToYaml(obj, indent = 0) {
            const spaces = '  '.repeat(indent);
            let yaml = '';
            
            for (const [key, value] of Object.entries(obj)) {
                if (value === null || value === undefined) {
                    yaml += `${spaces}${key}: null\n`;
                } else if (typeof value === 'object' && !Array.isArray(value)) {
                    yaml += `${spaces}${key}:\n`;
                    yaml += objectToYaml(value, indent + 1);
                } else if (Array.isArray(value)) {
                    yaml += `${spaces}${key}:\n`;
                    value.forEach(item => {
                        if (typeof item === 'object') {
                            yaml += `${spaces}  -\n`;
                            yaml += objectToYaml(item, indent + 2);
                        } else {
                            yaml += `${spaces}  - ${JSON.stringify(item)}\n`;
                        }
                    });
                } else if (typeof value === 'string') {
                    yaml += `${spaces}${key}: "${value}"\n`;
                } else {
                    yaml += `${spaces}${key}: ${JSON.stringify(value)}\n`;
                }
            }
            
            return yaml;
        }

        function yamlToObject(yamlText) {
            // Simple YAML parser for our specific use case
            const lines = yamlText.split('\n');
            const result = {};
            const stack = [{ obj: result, indent: -1 }];
            
            for (let line of lines) {
                if (line.trim() === '' || line.trim().startsWith('#')) continue;
                
                const match = line.match(/^(\s*)([^:]+):\s*(.*)$/);
                if (!match) continue;
                
                const indent = match[1].length;
                const key = match[2].trim();
                const value = match[3].trim();
                
                // Find the correct parent based on indentation
                while (stack.length > 1 && stack[stack.length - 1].indent >= indent) {
                    stack.pop();
                }
                
                const parent = stack[stack.length - 1].obj;
                
                if (value === '' || value === 'null') {
                    parent[key] = null;
                } else if (value.startsWith('"') && value.endsWith('"')) {
                    parent[key] = value.slice(1, -1);
                } else if (value === 'true') {
                    parent[key] = true;
                } else if (value === 'false') {
                    parent[key] = false;
                } else if (!isNaN(value) && value !== '') {
                    parent[key] = parseFloat(value);
                } else if (value.startsWith('[') && value.endsWith(']')) {
                    try {
                        parent[key] = JSON.parse(value);
                    } catch (e) {
                        parent[key] = value;
                    }
                } else if (value.startsWith('{') && value.endsWith('}')) {
                    try {
                        parent[key] = JSON.parse(value);
                    } catch (e) {
                        parent[key] = value;
                    }
                } else if (value === '') {
                    // This is a parent key for nested values
                    parent[key] = {};
                    stack.push({ obj: parent[key], indent: indent });
                } else {
                    parent[key] = value;
                }
            }
            
            return result;
        }

        function refreshCacheYaml() {
            const cacheData = getAllCacheData();
            const yaml = objectToYaml(cacheData);
            document.getElementById('pageCacheYaml').value = yaml;
        }

        // Auto-update YAML when cache changes
        function updateYamlDisplay() {
            const yamlTextarea = document.getElementById('pageCacheYaml');
            const readmeSection = document.getElementById('readme-section');
            
            // Only update if the documentation section is visible and textarea exists
            if (yamlTextarea && readmeSection && readmeSection.style.display !== 'none') {
                refreshCacheYaml();
            }
        }

        // Override localStorage.setItem to trigger YAML updates
        const originalSetItem = localStorage.setItem;
        localStorage.setItem = function(key, value) {
            originalSetItem.apply(this, arguments);
            
            // Check if this is a cache-related key and update YAML display
            if (key.includes('_1_') || key === 'aiInsightsCache' || key === 'claudeInsightsCache' || 
                key === 'participantsViewMode' || key === 'isFullscreen' || key === 'isCondensed' ||
                key === 'PartnerTools_selected_file' || key.startsWith('PartnerTools_customFile_')) {
                setTimeout(updateYamlDisplay, 100); // Small delay to ensure storage is updated
            }
        };

        function copyCacheYaml() {
            const textarea = document.getElementById('pageCacheYaml');
            if (textarea.value.trim() === '') {
                refreshCacheYaml();
            }
            
            textarea.select();
            textarea.setSelectionRange(0, 99999); // For mobile devices
            
            try {
                document.execCommand('copy');
                // Visual feedback
                const btn = document.getElementById('copy-cache-btn');
                const originalText = btn.textContent;
                btn.textContent = '✅ Copied';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 1500);
            } catch (err) {
                console.error('Failed to copy text: ', err);
                alert('Copy failed. Please select and copy manually.');
            }
        }

        function saveCacheFromYaml() {
            const yamlText = document.getElementById('pageCacheYaml').value;
            
            try {
                const cacheData = yamlToObject(yamlText);
                let itemsUpdated = 0;
                
                // Handle the new structured format
                if (cacheData.globalSettings) {
                    // Apply global settings
                    Object.entries(cacheData.globalSettings).forEach(([key, value]) => {
                        if (key === 'aiInsightsCache' || key === 'claudeInsightsCache') {
                            localStorage.setItem(key, JSON.stringify(value));
                            itemsUpdated++;
                        } else if (key === 'participantsViewMode' || key === 'isFullscreen' || key === 'isCondensed') {
                            if (typeof value === 'boolean') {
                                localStorage.setItem(key, JSON.stringify(value));
                            } else {
                                localStorage.setItem(key, value);
                            }
                            itemsUpdated++;
                        } else if (key === 'lastSelectedFile') {
                            localStorage.setItem('PartnerTools_selected_file', value);
                            itemsUpdated++;
                        } else if (key === 'customFiles' && typeof value === 'object') {
                            // Handle custom files
                            Object.entries(value).forEach(([fileName, fileData]) => {
                                const storageKey = `PartnerTools_customFile_${fileName}`;
                                localStorage.setItem(storageKey, JSON.stringify(fileData));
                                itemsUpdated++;
                            });
                        }
                    });
                }
                
                // Handle list-specific settings
                if (cacheData.listSpecificSettings) {
                    Object.entries(cacheData.listSpecificSettings).forEach(([listId, settings]) => {
                        Object.entries(settings).forEach(([settingKey, value]) => {
                            const storageKey = `${listId}_1_${settingKey}`;
                            if (typeof value === 'object') {
                                localStorage.setItem(storageKey, JSON.stringify(value));
                            } else {
                                localStorage.setItem(storageKey, value);
                            }
                            itemsUpdated++;
                        });
                    });
                }
                
                // Handle snapshots for all lists
                if (cacheData.allSnapshots) {
                    Object.entries(cacheData.allSnapshots).forEach(([listId, snapshots]) => {
                        const storageKey = `${listId}_1_snapshots`;
                        localStorage.setItem(storageKey, JSON.stringify(snapshots));
                        itemsUpdated++;
                    });
                }
                
                // Handle legacy format (flat structure) for backward compatibility
                if (!cacheData.globalSettings && !cacheData.listSpecificSettings && !cacheData.allSnapshots) {
                    Object.entries(cacheData).forEach(([key, value]) => {
                        if (key === 'aiInsightsCache' || key === 'claudeInsightsCache' || key === 'snapshots') {
                            localStorage.setItem(key, JSON.stringify(value));
                            itemsUpdated++;
                        } else if (key === 'participantsViewMode' || key === 'isFullscreen' || key === 'isCondensed') {
                            if (typeof value === 'boolean') {
                                localStorage.setItem(key, JSON.stringify(value));
                            } else {
                                localStorage.setItem(key, value);
                            }
                            itemsUpdated++;
                        } else if (key !== 'currentList' && key !== 'summary') {
                            // List-specific settings for current list
                            const storageKey = getListStorageKey(key);
                            if (typeof value === 'object') {
                                localStorage.setItem(storageKey, JSON.stringify(value));
                            } else {
                                localStorage.setItem(storageKey, value);
                            }
                            itemsUpdated++;
                        }
                    });
                }
                
                // Visual feedback
                const btn = document.getElementById('save-cache-btn');
                const originalText = btn.textContent;
                btn.textContent = `✅ Saved (${itemsUpdated} items)`;
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 2500);
                
                // Suggest page reload to apply changes
                if (confirm(`Cache updated successfully! ${itemsUpdated} items were saved to localStorage.\n\nWould you like to reload the page to apply the changes?`)) {
                    location.reload();
                }
                
            } catch (error) {
                console.error('Failed to parse YAML:', error);
                alert('Failed to parse YAML. Please check the syntax and try again.\n\nError: ' + error.message);
            }
        }

        // ===== NEW SNAPSHOT DROPDOWN FUNCTIONALITY =====
        
        // Initialize snapshot dropdown when page loads
        function initializeSnapshotDropdown() {
            // Use waitForElm to ensure the dropdown is in the DOM before initializing
            if (typeof waitForElm === 'function') {
                waitForElm('#snapshot').then(() => {
                    populateSnapshotDropdown();
                    setupSnapshotEventListeners();
                });
            } else {
                // Fallback if waitForElm is not available
                populateSnapshotDropdown();
                setupSnapshotEventListeners();
            }
        }
        
        // Setup event listeners for snapshot dropdown elements
        function setupSnapshotEventListeners() {
            const snapshotSelect = document.getElementById('snapshot');
            const editBtn = document.getElementById('edit-snapshot-btn');
            const deleteBtn = document.getElementById('delete-snapshot-btn');
            const nameInput = document.getElementById('snapshot-name-input');
            const saveBtn = document.getElementById('save-snapshot-btn');
            const cancelBtn = document.getElementById('cancel-snapshot-btn');
            
            if (snapshotSelect) {
                snapshotSelect.addEventListener('change', handleSnapshotChange);
            }
            
            if (editBtn) {
                editBtn.addEventListener('click', showSnapshotEditor);
            }
            
            if (deleteBtn) {
                deleteBtn.addEventListener('click', deleteCurrentSnapshot);
            }
            
            if (saveBtn) {
                saveBtn.addEventListener('click', saveSnapshotFromEditor);
            }
            
            if (cancelBtn) {
                cancelBtn.addEventListener('click', hideSnapshotEditor);
            }
        }
        
        // Populate snapshot dropdown with existing snapshots
        function populateSnapshotDropdown() {
            const snapshots = loadSnapshots();
            const snapshotSelect = document.getElementById('snapshot');
            
            if (!snapshotSelect) {
                return;
            }
            
            // Clear existing options and add blank "Snapshots..." option first
            snapshotSelect.innerHTML = '<option value="" disabled selected>Snapshots...</option>';
            
            // Add existing snapshots using numeric IDs as values
            Object.keys(snapshots)
                .sort((a, b) => parseInt(a) - parseInt(b)) // Sort by numeric ID
                .forEach(id => {
                    const snapshot = snapshots[id];
                    const option = document.createElement('option');
                    option.value = id; // Use numeric ID as value
                    option.textContent = snapshot.name || `Snapshot ${id}`; // Use display name
                    snapshotSelect.appendChild(option);
                });
            
            // Add "Add new snapshot" at the end
            const addNewOption = document.createElement('option');
            addNewOption.value = 'add_new';
            addNewOption.textContent = 'Add new snapshot';
            snapshotSelect.appendChild(addNewOption);
            
            // Set current selection if there's an active snapshot
            if (currentActiveSnapshot && snapshots[currentActiveSnapshot]) {
                snapshotSelect.value = currentActiveSnapshot;
                showEditDeleteButtons();
            } else {
                hideEditDeleteButtons();
            }
        }
        
        // Handle snapshot dropdown selection change
        function handleSnapshotChange(event) {
            const selectedValue = event.target.value;
            const editBtn = document.getElementById('edit-snapshot-btn');
            const deleteBtn = document.getElementById('delete-snapshot-btn');
            
            if (selectedValue === 'add_new') {
                // "Add new snapshot" selected
                showSnapshotEditor();
                clearGroupField();
                hideEditDeleteButtons();
                // Clear snapshot from hash
                if (typeof goHash === 'function') {
                    goHash({'snapshot': null});
                }
            } else if (selectedValue === '') {
                // "Snapshots..." placeholder selected - clear snapshot filter and show full list
                clearGroupField();
                hideEditDeleteButtons();
                hideSnapshotEditor();
                // Clear snapshot from hash
                if (typeof goHash === 'function') {
                    goHash({'snapshot': null});
                }
                // Refresh the view without any snapshot filtering
                if (window.globalCacheData) {
                    filterAndRenderData(window.globalCacheData);
                }
            } else {
                // Existing snapshot selected
                loadSnapshot(selectedValue);
                showEditDeleteButtons();
                hideSnapshotEditor();
                // Set snapshot in hash
                if (typeof goHash === 'function') {
                    goHash({'snapshot': selectedValue});
                }
            }
        }
        
        // Show the snapshot name editor
        function showSnapshotEditor() {
            const nameInput = document.getElementById('snapshot-name-input');
            const editBtn = document.getElementById('edit-snapshot-btn');
            const deleteBtn = document.getElementById('delete-snapshot-btn');
            const saveBtn = document.getElementById('save-snapshot-btn');
            const cancelBtn = document.getElementById('cancel-snapshot-btn');
            const snapshotControls = document.querySelector('.snapshot-controls');
            
            // Add editing class for responsive layout
            if (snapshotControls) snapshotControls.classList.add('editing');
            
            // Show input field and save/cancel buttons
            if (nameInput) nameInput.style.display = 'block';
            if (saveBtn) saveBtn.style.display = 'inline-block';
            if (cancelBtn) cancelBtn.style.display = 'inline-block';
            
            // Hide edit and delete buttons
            if (editBtn) editBtn.style.display = 'none';
            if (deleteBtn) deleteBtn.style.display = 'none';
            
            // Pre-populate with current selection if editing
            const snapshotSelect = document.getElementById('snapshot');
            if (snapshotSelect && snapshotSelect.value !== '' && snapshotSelect.value !== 'add_new') {
                // Editing existing snapshot - get the display name from the snapshots data
                const snapshots = loadSnapshots();
                const snapshotData = snapshots[snapshotSelect.value];
                nameInput.value = snapshotData ? snapshotData.name : '';
            } else {
                // Adding new snapshot - generate default name with today's date
                const today = new Date();
                const months = ['January', 'February', 'March', 'April', 'May', 'June',
                              'July', 'August', 'September', 'October', 'November', 'December'];
                nameInput.value = `${months[today.getMonth()]} ${String(today.getDate()).padStart(2, '0')}, ${today.getFullYear()}`;
            }
            
            if (nameInput) nameInput.focus();
        }
        
        // Hide the snapshot name editor
        function hideSnapshotEditor() {
            const nameInput = document.getElementById('snapshot-name-input');
            const editBtn = document.getElementById('edit-snapshot-btn');
            const deleteBtn = document.getElementById('delete-snapshot-btn');
            const saveBtn = document.getElementById('save-snapshot-btn');
            const cancelBtn = document.getElementById('cancel-snapshot-btn');
            const snapshotControls = document.querySelector('.snapshot-controls');
            
            // Remove editing class for responsive layout
            if (snapshotControls) snapshotControls.classList.remove('editing');
            
            // Hide input field and save/cancel buttons
            if (nameInput) {
                nameInput.style.display = 'none';
                nameInput.value = '';
            }
            if (saveBtn) saveBtn.style.display = 'none';
            if (cancelBtn) cancelBtn.style.display = 'none';
            
            // Show edit and delete buttons if there's a selected snapshot
            const snapshotSelect = document.getElementById('snapshot');
            if (snapshotSelect && snapshotSelect.value && snapshotSelect.value !== '' && snapshotSelect.value !== 'add_new') {
                if (editBtn) editBtn.style.display = 'inline-block';
                if (deleteBtn) deleteBtn.style.display = 'inline-block';
            }
        }
        
        // Save snapshot from the editor
        function saveSnapshotFromEditor() {
            const nameInput = document.getElementById('snapshot-name-input');
            const snapshotSelect = document.getElementById('snapshot');
            const newName = nameInput.value.trim();
            
            if (!newName) {
                alert('Please enter a snapshot name');
                return;
            }
            
            const snapshots = loadSnapshots();
            const selectedId = snapshotSelect.value;
            
            // Check if name already exists in any other snapshot
            const existingIdWithName = Object.keys(snapshots).find(id => 
                snapshots[id].name === newName && id !== selectedId
            );
            
            if (existingIdWithName) {
                if (!confirm(`Snapshot "${newName}" already exists. Overwrite?`)) {
                    return;
                }
            }
            
            let snapshotId;
            
            if (selectedId && selectedId !== 'add_new' && selectedId !== '') {
                // Editing existing snapshot
                snapshotId = selectedId;
            } else {
                // Creating new snapshot
                snapshotId = getNextSnapshotId(snapshots);
            }
            
            // Save current filter state to the new/renamed snapshot
            const filterState = getCurrentFilterState(newName);
            snapshots[snapshotId] = filterState;
            saveSnapshots(snapshots);
            
            // Update current active snapshot
            currentActiveSnapshot = snapshotId;
            
            // Refresh dropdown and update UI
            populateSnapshotDropdown();
            
            // Set the dropdown to the saved snapshot
            const snapshotSelectElement = document.getElementById('snapshot');
            if (snapshotSelectElement) {
                snapshotSelectElement.value = snapshotId;
            }
            
            updateListTitle();
            hideSnapshotEditor();
            showEditDeleteButtons();
            
            // Update hash
            if (typeof goHash === 'function') {
                goHash({'snapshot': snapshotId});
            }
            
            console.log(`Snapshot "${newName}" saved successfully with ID: ${snapshotId}`);
        }
        
        // Delete current snapshot
        function deleteCurrentSnapshot() {
            const snapshotSelect = document.getElementById('snapshot');
            const currentName = snapshotSelect.value;
            
            if (!currentName) return;
            
            if (confirm(`Are you sure you want to delete snapshot "${currentName}"?`)) {
                const snapshots = loadSnapshots();
                delete snapshots[currentName];
                saveSnapshots(snapshots);
                
                // Clear current active snapshot if it was deleted
                if (currentActiveSnapshot === currentName) {
                    currentActiveSnapshot = null;
                    updateListTitle();
                }
                
                // Reset dropdown to "Snapshots..." placeholder
                snapshotSelect.value = '';
                hideEditDeleteButtons();
                
                // Clear group field
                clearGroupField();
                
                // Refresh the list display
                refreshDisplay();
                
                populateSnapshotDropdown();
            }
        }
        
        // Show edit and delete buttons
        function showEditDeleteButtons() {
            const editBtn = document.getElementById('edit-snapshot-btn');
            const deleteBtn = document.getElementById('delete-snapshot-btn');
            const saveBtn = document.getElementById('save-snapshot-btn');
            const cancelBtn = document.getElementById('cancel-snapshot-btn');
            const nameInput = document.getElementById('snapshot-name-input');
            const snapshotControls = document.querySelector('.snapshot-controls');
            
            // Remove editing class for responsive layout
            if (snapshotControls) snapshotControls.classList.remove('editing');
            
            // Show edit and delete buttons
            if (editBtn) editBtn.style.display = 'inline-block';
            if (deleteBtn) deleteBtn.style.display = 'inline-block';
            
            // Hide save/cancel buttons and input field
            if (saveBtn) saveBtn.style.display = 'none';
            if (cancelBtn) cancelBtn.style.display = 'none';
            if (nameInput) nameInput.style.display = 'none';
        }
        
        // Hide edit and delete buttons
        function hideEditDeleteButtons() {
            const editBtn = document.getElementById('edit-snapshot-btn');
            const deleteBtn = document.getElementById('delete-snapshot-btn');
            const saveBtn = document.getElementById('save-snapshot-btn');
            const cancelBtn = document.getElementById('cancel-snapshot-btn');
            const nameInput = document.getElementById('snapshot-name-input');
            const snapshotControls = document.querySelector('.snapshot-controls');
            
            // Remove editing class for responsive layout
            if (snapshotControls) snapshotControls.classList.remove('editing');
            
            // Hide edit and delete buttons
            if (editBtn) editBtn.style.display = 'none';
            if (deleteBtn) deleteBtn.style.display = 'none';
            
            // Also hide save/cancel buttons and input field
            if (saveBtn) saveBtn.style.display = 'none';
            if (cancelBtn) cancelBtn.style.display = 'none';
            if (nameInput) nameInput.style.display = 'none';
        }
        
        // Clear the group field
        function clearGroupField() {
            const groupInput = document.getElementById('group');
            if (groupInput) {
                groupInput.value = '';
                // Trigger any existing change events
                const event = new Event('input', { bubbles: true });
                groupInput.dispatchEvent(event);
            }
        }
        
        // Refresh the display (trigger filter updates)
        function refreshDisplay() {
            // Call existing filter/display update functions
            if (typeof applyGroupFilter === 'function') {
                applyGroupFilter();
            }
        }

        // Initialize README and cache functionality when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Load README documentation
            setTimeout(() => {
                loadReadmeDocumentation();
                // Initialize cache YAML display
                refreshCacheYaml();
                // Initialize new snapshot dropdown functionality
                initializeSnapshotDropdown();
            }, 1000); // Delay to ensure other scripts have loaded
        });
    </script>
</script>

<!-- PR Diff Modal Overlay -->
<div id="prDiffModalOverlay" aria-hidden="true">
    <div class="pr-diff-modal" role="dialog" aria-modal="true">
        <div id="prDiffModalContent">
            <!-- populated dynamically -->
        </div>
    </div>
</div>

</body>
</html>
