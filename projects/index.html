<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>List Display</title>
    <link rel="icon" type="image/x-icon" href="../img/logo/neighborhood/favicon.png">

    <link type="text/css" rel="stylesheet" href="../../localsite/css/base.css" id="/localsite/css/base.css" />
    <script src="../../localsite/js/localsite.js?showheader=true"></script>

    <link rel="stylesheet" href="../css/common.css">
    <link rel="stylesheet" href="../css/shared-styles.css">
    
    <!-- Map and list displays -->
    <!--
    <link type="text/css" rel="stylesheet" href="../css/widget.css" id="/team/css/widget.css" />
    <script src="../js/widget.js"></script>
    -->

    <!-- Loads Leaflet map .js and .css -->
    <script type="text/javascript" src="../js/widget-embed.js?source=show.trade&map=cities.us"></script>
        
    <!-- Load Shared Auth Modal -->
    <script src="../js/auth-modal.js"></script>

    <style>
        /* Ensure all elements stay within container bounds */
        .card, .participants-table-card, .team-legend, .form-group, .input-button-group,
        .participants-table-container, .sort-dropdown, .status-dropdown {
            max-width: 100%;
            box-sizing: border-box;
        }
        
        /* Ensure form elements stay within bounds */
        .form-control, .form-row, .config-form {
            max-width: 100%;
            box-sizing: border-box;
        }
        
        /* Responsive table handling */
        .participants-table-container {
            overflow-x: auto;
            width: 100%;
        }
        
        .participants-table {
            width: 100%;
            min-width: 0;
        }
        
        .readme-content {
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            padding: 16px;
            background: var(--bg-tertiary);
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-control {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            font-size: 14px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: all 0.2s ease;
        }
        
        .form-control:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .form-control::placeholder {
            color: var(--text-muted);
        }
        
        .form-select {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            font-size: 14px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: all 0.2s ease;
        }
        
        .form-select:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        /* Snapshot dropdown specific styling */
        #snapshot {
            width: auto;
            max-width: 300px;
            min-width: fit-content;
            appearance: menulist;
            -webkit-appearance: menulist;
            -moz-appearance: menulist;
            background-image: none !important;
            padding-right: initial !important;
        }
        
        /* Custom dropdown arrow for fileSelect */
        #fileSelect {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%236b7280' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px 16px;
            padding-right: 40px;
        }

        .dark #fileSelect {
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ccc' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
        }
        
        /* Dark mode button backgrounds */
        .dark #status-toggle,
        .dark #sort-toggle,
        .dark #group-toggle,
        .dark #insights-btn,
        .dark .btn {
            background: var(--bg-tertiary);
        }
        
        /* Settings toggle styling */
        #settings-toggle {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-medium);
            transition: all 0.2s;
        }
        
        #settings-toggle:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        #settings-toggle svg {
            stroke-width: 1;
        }
        
        /* Dark mode styles for settings toggle */
        .dark #settings-toggle {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-medium);
            color: var(--text-secondary);
        }
        
        .dark #settings-toggle:hover {
            background: #666;
            color: var(--text-primary);
            border-color: #777;
        }
        
        .message-log {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            padding: 12px;
            margin-top: 16px;
            max-height: 1000px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
        }
        
        .message-log:empty {
            display: none;
        }
        
        .form-label {
            display: block;
            font-weight: 500;
            margin-bottom: 8px;
            color: var(--text-primary);
            font-size: 14px;
        }
        
        .input-button-group {
            display: flex;
            gap: 12px;
            align-items: flex-end;
        }
        
        .input-button-group .form-control {
            flex: 1;
        }
        
        @media (max-width: 500px) {
            .input-button-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .input-button-group .btn {
                width: 100%;
            }
        }
        
        .setup-steps {
            margin: 20px 0;
        }
        
        .step-item {
            display: flex;
            margin-bottom: 24px;
            padding: 16px;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            background: var(--bg-secondary);
        }
        
        .step-number {
            width: 32px;
            height: 32px;
            background: var(--accent-blue);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 16px;
            flex-shrink: 0;
        }
        
        .step-content {
            flex: 1;
        }
        
        .step-content h4 {
            margin-bottom: 8px;
            color: var(--text-primary);
            font-size: 16px;
        }
        
        .step-content p {
            color: var(--text-secondary);
            margin-bottom: 12px;
            font-size: 14px;
        }
        
        .status-message {
            margin-top: 8px;
            padding: 8px 12px;
            border-radius: var(--radius-md);
            font-size: 13px;
            display: none;
        }
        
        .status-message.success {
            background: rgba(16, 185, 129, 0.1);
            color: var(--accent-green);
            border: 1px solid rgba(16, 185, 129, 0.3);
        }
        
        .status-message.error {
            background: rgba(239, 68, 68, 0.1);
            color: var(--accent-red);
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        
        .status-message.info {
            background: rgba(59, 130, 246, 0.1);
            color: var(--accent-blue);
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        
        /* Dark mode status message styles */
        .dark .status-message.info {
            background: rgba(59, 130, 246, 0.15);
            color: white;
            border: 1px solid rgba(59, 130, 246, 0.4);
        }
        
        .dark .status-message.success {
            color: white;
        }
        
        .dark .status-message.error {
            color: white;
        }

        /* Button highlighting for cached insights */
        .btn.cached-insights {
            background: var(--accent-blue) !important;
            color: white !important;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
        }

        .dark .btn.cached-insights {
            background: var(--accent-blue) !important;
            color: white !important;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4);
        }

        /* Dark mode styling for insights content */
        .dark .insights-content {
            background: var(--bg-tertiary) !important;
            color: var(--text-primary);
        }

        .dark .insights-content .ai-insights-content {
            background: var(--bg-secondary) !important;
        }
        
        
        .config-form {
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: var(--radius-md);
            margin-bottom: 24px;
        }
        
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 16px;
        }
        
        .form-label {
            display: block;
            font-weight: 500;
            margin-bottom: 6px;
            color: var(--text-primary);
            font-size: 14px;
        }
        
        .config-actions {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .form-help {
            display: block;
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 4px;
        }
        
        textarea.form-control {
            resize: vertical;
            min-height: 80px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .button-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .table-container {
            overflow-x: auto;
            margin-bottom: 16px;
        }
        
        .participants-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        
        .participants-table th,
        .participants-table td {
            padding: 12px 8px;
            text-align: left;
            border-bottom: 1px solid var(--border-light);
        }
        
        .participants-table th {
            background: var(--bg-tertiary);
            font-weight: 600;
            color: var(--text-primary);
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .participants-table td {
            color: var(--text-secondary);
            max-width: 200px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            transition: all 0.2s ease;
            vertical-align: middle;
        }
        
        .participants-table td.expanded {
            white-space: normal;
            word-wrap: break-word;
            max-width: none;
            vertical-align: middle;
            display: table-cell;
        }
        
        .participants-table tr:hover {
            background: rgba(59, 130, 246, 0.05);
        }
        
        
        .table-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .pagination-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .pagination-btn {
            width: 32px;
            height: 32px;
            border: 1px solid var(--border-medium);
            border-radius: 6px;
            background: var(--bg-secondary);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s ease;
        }
        
        .pagination-btn:hover:not(:disabled) {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* 3-dot menu styles */
        .menu-container {
            position: relative;
            display: inline-block;
            margin-left: 8px;
        }
        
        .menu-button {
            width: 32px;
            height: 32px;
            border: 1px solid var(--border-medium);
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bolder;
            transition: all 0.2s;
        }
        
        .menu-button:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .menu-button.active {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }
        
        .menu-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-medium);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            min-width: 180px;
            z-index: 1000;
            margin-top: 4px;
            display: none;
        }
        
        .menu-item {
            padding: 12px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 14px;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border-light);
        }
        
        .menu-item:last-child {
            border-bottom: none;
        }
        
        .menu-item:hover {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .menu-item.active {
            background-color: var(--accent-blue);
            color: white;
        }
        
        /* Fullscreen styles */
        .fullscreen-mode {
            width: 100% !important;
            min-height: 100vh !important;
            z-index: 9999 !important;
            background: var(--bg-primary) !important;
            overflow-x: hidden !important;
            overflow-y: auto !important;
            padding: 0 !important;
            margin: 0 !important;
            box-sizing: border-box !important;
        }
        
        .fullscreen-mode .container {
            max-width: 100% !important;
            width: 100% !important;
            margin: 0 !important;
            padding: 20px !important;
            box-sizing: border-box !important;
            overflow-x: hidden !important;
        }
        
        .fullscreen-mode .breadcrumb {
            display: none !important;
        }
        
        .fullscreen-mode .header {
            display: none !important;
        }
        
        .fullscreen-mode table {
            table-layout: fixed !important;
            width: 100% !important;
            overflow-x: auto !important;
        }
        
        .fullscreen-mode .card {
            max-width: 100% !important;
            overflow-x: hidden !important;
        }
        
        /* Maintain 3-dot menu spacing in fullscreen mode */
        .fullscreen-mode .participants-table .columns-menu {
            right: 8px !important;
        }
        
        /* Ensure menu column has consistent width in all modes */
        .fullscreen-mode .participants-table td:last-child {
            width: 70px !important;
            min-width: 70px !important;
            padding: 8px 16px !important;
        }
        
        
        /* Condensed layout styles */
        .condensed-mode .view-buttons {
            display: none;
        }
        
        .condensed-mode .view-buttons-condensed {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .condensed-mode .legend-controls {
            display: none;
        }
        
        .condensed-mode .legend-controls-condensed {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .view-buttons-condensed {
            display: none;
        }
        
        .legend-controls-condensed {
            display: none;
        }
        
        .condensed-icon-btn {
            width: 32px;
            height: 32px;
            border: 1px solid var(--border-light);
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }
        
        .condensed-icon-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .condensed-icon-btn.active {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }
        
        @media (max-width: 600px) {
            .form-row {
                grid-template-columns: 1fr;
            }
            
            .config-actions {
                flex-direction: column;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .participants-table {
                font-size: 12px;
            }
            
            .participants-table th,
            .participants-table td {
                padding: 8px 4px;
            }
            
            .table-info {
                flex-direction: column;
                gap: 8px;
            }
            
            .upload-group {
                flex-direction: column;
                gap: 8px;
            }
        }
        
        .upload-group {
            display: flex;
            gap: 8px;
            align-items: flex-end;
        }
        
        .alternative-upload {
            border-left: 3px solid var(--accent-blue);
        }
        
        .alternative-upload h4 {
            font-size: 16px;
        }
        
        /* Snapshot dropdown styling */
        .snapshot-name-editor {
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            padding: 12px;
            background: var(--bg-tertiary);
        }
        
        #edit-snapshot-btn, #delete-snapshot-btn {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            flex-shrink: 0;
        }
        
        #delete-snapshot-btn {
            font-size: 24px;
            font-weight: bold;
            line-height: 1;
        }
        
        .add-snapshot {
            display: flex;
            gap: 8px;
        }
        
        .add-snapshot input {
            flex: 1;
        }
        
        /* Group Participants Control */
        .group-control {
            margin-bottom: 20px;
            padding: 16px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-light);
            display: none; /* Hidden by default, shown only for modelteam list */
        }
        
        .group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .group-snapshot-info {
            font-size: 12px;
            color: var(--text-muted);
        }
        
        .group-snapshot-info a {
            color: var(--accent-blue);
            text-decoration: none;
        }
        
        .group-snapshot-info a:hover {
            text-decoration: underline;
        }
        
        .group-input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .group-input-group input {
            flex: 1;
        }
        
        #group {
            text-align: right;
            caret-color: var(--text-primary) !important;
            padding-right: 18px !important; /* Extra padding to ensure cursor visibility */
            box-sizing: border-box;
        }
        
        #group:focus {
            caret-color: var(--accent-blue) !important;
        }
        
        #group-toggle {
            white-space: nowrap;
            min-width: 100px;
        }
        
        /* Button backgrounds for consistent styling */
        #status-toggle,
        #sort-toggle {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-light);
        }
        
        #group-toggle.active {
            background: var(--accent-green);
            color: white;
            border-color: var(--accent-green);
        }
        
        #group-toggle-text[contenteditable="true"] {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            padding: 2px 4px;
            outline: 2px solid var(--accent-blue);
            outline-offset: 1px;
        }
        
        #group-toggle-text {
            cursor: pointer;
        }
        
        #group-toggle-text:hover {
            text-decoration: underline;
        }
        
        /* Group participant highlighting */
        .columns-group {
            border: 3px solid var(--accent-green) !important;
            box-shadow: 0 0 0 1px var(--accent-green) !important;
        }
        
        .columns-group .columns-name {
            color: var(--accent-green) !important;
            font-weight: 700 !important;
        }
        
        /* Keep gallery names white when group border is added */
        .columns-group .gallery-name {
            color: white !important;
            font-weight: 700 !important;
        }
        
        /* Table row highlighting */
        .participants-table tr.columns-group {
            background: rgba(16, 185, 129, 0.1) !important;
            border-left: 4px solid var(--accent-green) !important;
        }
        
        .participants-table tr.columns-group td:first-child {
            color: var(--accent-green) !important;
            font-weight: 600 !important;
        }
        
        /* Raw Data Control */
        .raw-data-control {
            margin-bottom: 20px;
            padding: 16px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-light);
        }
        
        .raw-data-control textarea {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: auto;
        }
        
        /* View Controls */
        .view-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 12px;
        }
        
        .view-buttons {
            display: flex;
            gap: 8px;
        }
        
        .view-btn {
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid var(--border-light);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }
        
        .view-btn.active {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }
        
        .view-btn:hover:not(.active) {
            background: var(--border-light);
        }
        
        #add-visit-btn {
            text-decoration: none !important;
            background: #22c55e !important;
            color: white !important;
            border-color: #22c55e !important;
            opacity: 0.8;
            padding: 8px 16px !important;
        }
        
        #add-visit-btn:hover {
            opacity: 1;
            background: #16a34a !important;
            border-color: #16a34a !important;
        }
        
        #map-btn {
            text-decoration: none !important;
            background: #3b82f6 !important;
            color: white !important;
            border-color: #3b82f6 !important;
            opacity: 0.8;
            padding: 8px 16px !important;
        }
        
        #map-btn:hover {
            opacity: 1;
            background: #2563eb !important;
            border-color: #2563eb !important;
        }
        
        #sign-in-btn {
            padding: 8px 16px !important;
        }
        
        #insights-btn {
            padding: 8px 16px !important;
        }
        
        #list-title {
            border: none !important;
        }
        
        #aiInsights {
            margin-top: 0 !important;
            padding-top: 0 !important;
            margin-bottom: 12px !important;
            display: none !important; /* Hidden by default */
        }
        
        /* Column View (Default) - Using table-list style */
        .participants-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-top: 16px;
        }
        
        .columns-card {
            background: var(--bg-tertiary);
            padding: 16px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-light);
            transition: all 0.2s;
            position: relative;
        }
        
        .columns-card:hover {
            background: var(--bg-secondary);
            box-shadow: var(--shadow-sm);
        }
        
        .columns-name {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
            font-size: 16px;
            display: flex;
            align-items: center;
        }
        
        .columns-checkbox {
            width: 18px;
            height: 18px;
            margin-right: 8px;
            vertical-align: middle;
            cursor: pointer;
            z-index: 10;
        }
        
        /* 3-dot menu for participant cards */
        .columns-menu {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            z-index: 5;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-size: 18px;
            color: var(--text-secondary);
        }
        
        .columns-menu:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        
        .columns-menu-dropdown {
            position: absolute;
            top: 100%;
            right: 26px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            min-width: 150px;
            z-index: 999999;
            display: none;
            margin-top: -20px;
        }

        /* Specific positioning for table view dropdown */
        .participants-table .columns-menu-dropdown {
            right: 32px;
            margin-top: -34px;
        }
        
        
        /* Override table container z-index issues */
        .table-container {
            position: relative;
            z-index: 1;
            overflow-x: auto;
            overflow-y: visible;
        }
        
        /* Only allow overflow for menu cells to show dropdowns */
        .participants-table td {
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Menu cells need overflow visible for dropdown */
        .participants-table td:last-child {
            overflow: visible;
            width: 50px !important;
            min-width: 50px !important;
            padding: 8px 12px !important;
        }
        
        /* 3-dot menu vertical centering only in table view */
        .participants-table .columns-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-size: 18px;
            color: var(--text-secondary);
            cursor: pointer;
            z-index: 5;
            background: transparent;
        }

        /* Hover effect for the menu button */
        .participants-table .columns-menu:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* Ensure the menu cell is sticky as well */
        .participants-table td:last-child {
            position: sticky !important;
            right: 0 !important;
            background: var(--bg-secondary) !important;
            border-left: 1px solid var(--border-light) !important;
            box-shadow: -2px 0 4px rgba(0, 0, 0, 0.1) !important;
            z-index: 10 !important;
        }

        /* Make the menu header column sticky too */
        .participants-table th:last-child {
            position: sticky !important;
            right: 0 !important;
            background: var(--bg-tertiary) !important;
            border-left: 1px solid var(--border-light) !important;
            box-shadow: -2px 0 4px rgba(0, 0, 0, 0.1) !important;
            z-index: 11 !important;
            width: 50px !important;
            min-width: 50px !important;
        }

        /* Dark mode support for sticky menu column */
        .dark .participants-table td:last-child,
        .dark .participants-table th:last-child {
            background: var(--bg-secondary) !important;
            border-left: 1px solid var(--border-medium) !important;
            box-shadow: -2px 0 4px rgba(0, 0, 0, 0.3) !important;
        }

        .dark .participants-table .columns-menu {
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-medium);
            box-shadow: -2px 0 4px rgba(0, 0, 0, 0.3);
        }
        
        /* 3-dot menu dark color for gallery view visibility */
        .gallery-card .columns-menu {
            color: #000000 !important;
        }
        
        .gallery-card .columns-menu:hover {
            color: #000000 !important;
            background: rgba(255, 255, 255, 0.2);
        }
        
        /* Ensure participants table container doesn't clip dropdowns */
        .participants-table-container {
            overflow-x: auto;
            overflow-y: visible;
        }
        
        /* Table right-click context menu */
        .table-context-menu {
            position: fixed;
            z-index: 999999;
            background: var(--bg-secondary);
            border: 1px solid var(--border-medium);
            border-radius: var(--radius-md);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            min-width: 150px;
            padding: 4px 0;
            opacity: 1;
        }
        
        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background-color 0.2s ease;
        }
        
        .context-menu-item:hover {
            background: var(--bg-tertiary);
        }
        
        
        .columns-menu-item {
            padding: 12px 16px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            min-height: 40px;
            text-align: center;
        }
        
        .columns-menu-item:hover {
            background: var(--bg-tertiary);
        }
        
        .columns-menu-item a {
            color: inherit;
            text-decoration: none;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            padding: 0;
            text-align: center;
        }
        
        /* Table-specific checkbox styling */
        table .columns-checkbox {
            position: relative;
            top: auto;
            right: auto;
            margin: 0;
            display: inline-block;
        }
        
        .columns-info {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 2px;
        }
        
        .columns-info strong {
            color: var(--text-primary);
            font-weight: 500;
        }
        
        .columns-projects {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 8px;
            line-height: 1.4;
            border-top: 1px solid var(--border-light);
            padding-top: 8px;
        }
        
        .columns-projects strong {
            color: var(--text-primary);
            font-weight: 500;
        }
        
        /* Gallery View */
        .participants-gallery {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 16px;
        }
        
        .gallery-card {
            background: linear-gradient(135deg, var(--card-bg-1), var(--card-bg-2));
            border-radius: var(--radius-lg);
            padding: 20px;
            text-align: center;
            color: white;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .gallery-card:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: var(--shadow-lg);
        }
        
        .gallery-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.1) 50%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .gallery-card:hover::before {
            opacity: 1;
        }
        
        .gallery-name {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        
        .gallery-info {
            font-size: 12px;
            opacity: 0.9;
            font-weight: 500;
        }
        
        /* Team-based color variations for gallery cards */
        .gallery-card.team-js { --card-bg-1: #667eea; --card-bg-2: #764ba2; }
        .gallery-card.team-ml { --card-bg-1: #f093fb; --card-bg-2: #f5576c; }
        .gallery-card.team-react { --card-bg-1: #4facfe; --card-bg-2: #00f2fe; }
        .gallery-card.team-io { --card-bg-1: #43e97b; --card-bg-2: #38f9d7; }
        .gallery-card.team-ai { --card-bg-1: #fa709a; --card-bg-2: #fee140; }
        .gallery-card.team-flask { --card-bg-1: #ff9a9e; --card-bg-2: #fecfef; }
        .gallery-card.team-suite { --card-bg-1: #a8edea; --card-bg-2: #fed6e3; }
        .gallery-card.team-us { --card-bg-1: #ffecd2; --card-bg-2: #fcb69f; }
        .gallery-card.team-auth { --card-bg-1: #89f7fe; --card-bg-2: #66a6ff; }
        .gallery-card.team-discord { --card-bg-1: #c2e9fb; --card-bg-2: #a1c4fd; }
        .gallery-card.team-default { --card-bg-1: #d299c2; --card-bg-2: #fef9d7; }
        
        /* Team Legend */
        .team-legend {
            margin-bottom: 20px;
            padding: 16px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-light);
        }
        
        .legend-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .legend-header h4 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }
        
        .btn-sm {
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 4px;
        }
        
        /* Larger X for dropdown close buttons */
        #close-sort, #close-status {
            font-size: 24px;
            line-height: 1;
            padding: 0;
            min-width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: auto;
        }
        
        .legend-items {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
        }
        
        .legend-item:hover {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }
        
        .legend-item.active {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            flex-shrink: 0;
        }
        
        /* Legend Controls */
        .legend-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            position: relative;
        }
        
        .button-with-dropdown {
            position: relative;
            display: inline-block;
        }
        
        /* Sort Dropdown */
        .sort-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            min-width: 200px;
            z-index: 1000;
            margin-top: 4px;
        }
        
        .sort-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-light);
        }
        
        .sort-header h4 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }
        
        .sort-items {
            padding: 8px 0;
        }
        
        .sort-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .sort-item:hover {
            background-color: var(--bg-tertiary);
        }
        
        .sort-item.active {
            background-color: var(--accent-blue);
            color: white;
        }
        
        .sort-arrow {
            font-size: 12px;
            font-weight: bold;
            min-width: 16px;
            text-align: center;
        }
        
        /* Status Dropdown */
        .status-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            min-width: 220px;
            z-index: 1000;
            margin-top: 4px;
        }
        
        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-light);
        }
        
        .status-header h4 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }
        
        .status-items {
            padding: 8px 0;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .status-item {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .status-item:hover {
            background-color: var(--bg-tertiary);
        }
        
        .status-checkbox {
            margin-right: 8px;
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        .status-label {
            flex: 1;
            cursor: pointer;
        }
        
        /* Responsive Design */
        @media (max-width: 1000px) {
            .participants-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 900px) {
            .container {
                padding: 0 16px;
            }
            
            .view-controls {
                flex-wrap: wrap;
                gap: 8px;
            }
            
            .table-info {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            
            .form-row {
                grid-template-columns: 1fr;
            }
            
            .config-actions {
                flex-direction: column;
                gap: 8px;
            }
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 0 16px;
            }
            
            .participants-grid {
                grid-template-columns: 1fr;
            }
            
            .participants-gallery {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .view-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .participants-table-container {
                overflow-x: auto;
            }
            
            .participants-table {
                min-width: 600px;
            }
            
            .table-info {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            
            .pagination-controls {
                align-self: flex-end;
            }
            
            .view-buttons {
                justify-content: center;
            }
            
            .legend-items {
                justify-content: center;
            }
        }
        
        @media (max-width: 480px) {
            .participants-gallery {
                grid-template-columns: 1fr;
            }
            
            .view-buttons {
                flex-direction: column;
            }
        }
        
        /* Loading and error states */
        .loading-state, .error-state {
            text-align: center;
            padding: 40px 20px;
            font-size: 16px;
            color: var(--text-secondary);
        }
        
        .error-state {
            color: #dc2626;
        }
        
        /* Clickable meta list items */
        .columns-card[style*="cursor: pointer"]:hover,
        .gallery-card[style*="cursor: pointer"]:hover,
        .participants-table tr[style*="cursor: pointer"]:hover {
            background-color: rgba(59, 130, 246, 0.1) !important;
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
            transition: all 0.2s ease;
        }
        
        
        /* Raw Data Editor Close Button */
        #raw-data-close {
            transition: all 0.2s ease;
            border-radius: var(--radius-sm);
            min-width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #raw-data-close:hover {
            background-color: var(--bg-tertiary);
            border-color: var(--border-medium);
            color: var(--text-primary);
        }
        
        /* Button Groups for AI Insights */
        .insights-status {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .insight-button-group {
            display: flex;
            gap: 8px;
            align-items: center;
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 8px;
            border: 1px solid var(--border-light);
            box-shadow: var(--shadow-sm);
            transition: all 0.2s;
        }

        .insight-button-group:hover {
            box-shadow: var(--shadow-md);
            background: var(--bg-secondary);
        }

        .insight-button-group .btn {
            margin: 0;
            border-radius: 8px;
            flex: 1;
        }

        .refresh-btn {
            width: 40px;
            height: 40px;
            min-width: 40px;
            max-width: 40px;
            padding: 0;
            margin: 0;
            border-radius: 6px;
            background: var(--accent-blue);
            color: white;
            border: 1px solid var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            box-shadow: var(--shadow-sm);
            transition: all 0.2s;
            cursor: pointer;
            flex-shrink: 0;
            box-sizing: border-box;
        }

        .refresh-btn:hover {
            background: #2563EB;
            transform: scale(1.05);
            box-shadow: var(--shadow-md);
        }

        .refresh-btn:active {
            transform: scale(0.95);
        }

        .refresh-btn span {
            font-size: 32px;
            line-height: 1;
            font-weight: normal;
            margin-top: -4px;
        }

        /* AI Insights Styles */
        .insights-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .ai-icon {
            font-size: 24px;
        }

        .insights-content {
            background: var(--bg-primary);
            border-radius: var(--radius-md);
            padding: 16px;
            border: 1px solid var(--border-light);
        }

        .loading-status {
            margin-bottom: 16px;
            padding: 12px;
            border-radius: var(--radius-md);
            text-align: left;
            font-style: italic;
            font-weight: bold;
        }

        /* Prompt Modal */
        .prompt-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .prompt-modal.hidden {
            display: none;
        }

        .prompt-modal-content {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            padding: 24px;
            max-width: 500px;
            width: 90%;
            box-shadow: var(--shadow-lg);
        }

        .prompt-modal-content h3 {
            margin-bottom: 16px;
            color: var(--text-primary);
            font-size: 20px;
            font-weight: 600;
        }

        .prompt-modal-content textarea {
            width: 100%;
            min-height: 120px;
            padding: 12px;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
            margin-bottom: 16px;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        /* Image Gallery Styles */
        .columns-image-container {
            position: relative;
            width: 100%;
            height: 120px;
            margin-bottom: 12px;
            overflow: hidden;
            border-radius: var(--radius-md);
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .columns-image {
            width: 100%;
            height: 120px;
            object-fit: cover;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .columns-image:hover {
            transform: scale(1.02);
        }

        .image-dots-container {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 6px;
            z-index: 2;
        }

        .image-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(128, 128, 128, 0.7);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .image-dot.active {
            background: rgba(255, 255, 255, 0.9);
            transform: scale(1.2);
        }

        .image-dot:hover {
            background: rgba(255, 255, 255, 0.8);
        }

        /* Gallery View Image Styles */
        .gallery-card {
            position: relative;
            overflow: hidden;
            min-height: 180px;
        }

        .gallery-card .columns-image-container {
            height: 140px;
            margin-bottom: 0;
            border-radius: var(--radius-md) var(--radius-md) 0 0;
        }

        .gallery-card .columns-image {
            height: 140px;
        }

        .gallery-card .gallery-content {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: transparent;
            padding: 12px;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: flex-start;
            text-align: left;
        }
        
        /* Dark overlay for cards with background images */
        .gallery-card.has-background-image .gallery-content {
            background: rgba(0, 0, 0, 0.7);
            color: white;
        }
        
        
        .gallery-card.has-background-image .gallery-name {
            color: white;
        }
        
        .gallery-card.has-background-image .gallery-info {
            color: rgba(255, 255, 255, 0.9);
        }

        .gallery-card.text-mode .gallery-content {
            background: rgba(0, 0, 0, 0.85);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: flex-start;
            text-align: left;
        }
        
        /* Text mode for cards without images */
        .gallery-card.text-mode:not(.has-background-image) .gallery-content {
            top: 0;
            bottom: 0;
        }

        .gallery-toggle-btn {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: none;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 3;
            padding: 4px;
        }

        .gallery-toggle-btn:hover {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 4px;
            transform: scale(1.1);
        }

        .no-image-placeholder {
            width: 100%;
            height: 120px;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            font-size: 12px;
            border-radius: var(--radius-md);
        }

        /* Auto-advance indicator */
        .image-container.auto-advancing .image-dot.active {
            animation: pulse 0.3s ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1.2); }
            50% { transform: scale(1.4); }
        }

        /* Image loading placeholder */
        .columns-image-container.loading {
            background: linear-gradient(90deg, var(--bg-tertiary) 25%, var(--bg-secondary) 50%, var(--bg-tertiary) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        .dark .view-btn:hover:not(.active) {
            color: #fff !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="breadcrumb">
            <a href="../admin/">Partner Tools</a>
        </div>

        <div class="header" id="teamHeader" style="text-align: left; display: none; padding: 0px">
            <h1>
                <div class="gemini-icon">G</div>
                Coding Meetup Integration
            </h1>
            <p>Filters a Google Sheet to share member details <a href="../admin/cloud/">during meetups</a>.
                <!--  will eventually pull a list from a Google Meetup to filter the  -->
            </p>
        </div>

        <div id="teamwidget"></div>

        <!-- Top Message Display Area -->
        <div id="top-message-area" style="display: none; margin-bottom: 20px;">
            <div class="card" style="border-left: 4px solid #f59e0b; background: #fef3c7; color: #92400e;">
                <div id="top-message-content"></div>
            </div>
        </div>

        <div style="margin-bottom: 20px;">
            <div id="pageControls" class="input-button-group" style="display:flex; width: 100%; align-items: center;">
                <div style="display: flex; gap: 12px; align-items: center;">
                    <select id="fileSelect" class="form-control" style="width: auto; min-width: 200px; max-width: calc(100% - 32px); flex: none;">
                        <option value="custom">Choose File...</option>
                    </select>
                    <button class="btn btn-primary" id="get-participants">
                        <span class="loading-spinner" id="participants-spinner" style="display: none;"></span>
                        Get List
                    </button>
                </div>
                <div class="menu-container" style="display: flex; align-items: flex-start; gap: 8px; margin-left: auto;">
                    <button class="btn btn-secondary" id="settings-toggle" onclick="toggleReadmeSection()" style="padding: 4px 6px; font-size: 14px; color: var(--text-secondary); min-width: 32px; height: 32px;" title="Documentation & Cache">
                        <i data-feather="settings"></i>
                    </button>
                    <button class="menu-button" id="menu-toggle">
                        
                    </button>
                    <div class="menu-dropdown" id="menu-dropdown">
                        <div class="menu-item" id="fullscreen-toggle">
                            <span id="fullscreen-text">View Fullscreen</span>
                        </div>
                        <div class="menu-item" id="condensed-toggle">
                            <span id="condensed-text">Condense Layout</span>
                        </div>
                        <div class="menu-item" id="raw-data-toggle">
                            <span id="raw-data-text">View Raw Data</span>
                        </div>
                        <div class="menu-item" id="export-csv-menu">
                            <span>Export CSV</span>
                        </div>
                        <div class="menu-item" id="full-url-toggle">
                            <span>Full URL</span>
                        </div>
                        <div class="menu-item" id="list-feeds-toggle">
                            <span>All Lists</span>
                        </div>
                        <div class="menu-item" id="refresh-csv-toggle" style="display: none;">
                            <span>Refresh lists.csv</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Custom file upload (hidden by default) -->
            <div class="form-group" id="customFileSection" style="display: none;">
                <div class="file-input-wrapper">
                    <input type="file" id="excelFile" class="file-input" accept=".xlsx,.xls,.csv" style="display: none;" />
                    <div class="file-input-display" id="fileDisplay" style="border: 1px solid var(--border-light); border-radius: var(--radius-md); padding: 16px; background: var(--bg-secondary); cursor: pointer; text-align: center;">
                        <div class="file-info">
                            <div class="file-name">Click to upload file</div>
                            <div class="file-details" style="color: var(--text-muted); font-size: 12px;">Supports .csv, .xls and .xlsx formats</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- README Documentation Section -->
        <div class="card" id="readme-section" style="margin-top: 20px; display: none;">
            <div style="margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center;">
                <h3 style="margin: 0; color: var(--text-primary);"> Page Documentation & Cache</h3>
                <button class="btn btn-secondary" id="toggle-readme" onclick="toggleReadmeSection()" style="font-size: 12px; padding: 6px 12px;">
                    Hide Documentation
                </button>
            </div>
            
            <!-- Browser Cache YAML Editor -->
            <div style="margin-bottom: 20px;">
                <div style="margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                    <h4 style="margin: 0; color: var(--text-primary);"> Browser Cache (YAML)</h4>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-secondary" id="copy-cache-btn" onclick="copyCacheYaml()" style="font-size: 11px; padding: 4px 8px;">
                             Copy
                        </button>
                        <button class="btn btn-primary" id="save-cache-btn" onclick="saveCacheFromYaml()" style="font-size: 11px; padding: 4px 8px;">
                             Save
                        </button>
                        <button class="btn btn-secondary" id="refresh-cache-btn" onclick="refreshCacheYaml()" style="font-size: 11px; padding: 4px 8px;">
                             Refresh
                        </button>
                    </div>
                </div>
                <textarea id="pageCacheYaml" style="width: 100%; height: 250px; padding: 20px" placeholder="Browser cache will appear here..."></textarea>
                <div style="font-size: 11px; color: var(--text-muted); margin-top: 5px;">
                    Edit the YAML above and click Save to update your browser cache. Click Refresh to reload current cache values.
                </div>
            </div>
            
            <div style="border-top: 1px solid var(--border-light); padding-top: 20px;">
                <div id="readme-content"></div>
            </div>
        </div>

        <div class="card" id="participants-table-card" style="display: none;">

            <div id="list-title-holder" style="margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-light); padding-bottom: 15px;">
                <h2 class="card-title" id="list-title" style="margin: 0;"> Participants List</h2>
                <div style="display: flex; gap: 10px;">
                    <button id="insights-btn" class="btn btn-secondary view-btn" style="display: none;" onclick="toggleInsights()">Insights</button>
                    <a href="edit.html?add=visit" id="add-visit-btn" class="btn btn-secondary view-btn" style="display: none;">Add City Visit</a>
                    <a href="map/#list=cities" id="map-btn" class="btn btn-primary view-btn" style="display: none;">Map</a>
                    <button id="sign-in-btn" class="btn btn-primary" style="display: none;" onclick="showAuthModal()">Sign In</button>
                </div>
            </div>

            <!-- AI Insights -->
            <div id="aiInsights" style="display: none;">
                <div class="insights-header">
                    <div class="insights-status" id="insightsStatus">
                        <div class="insight-button-group">
                            <button id="claudeInsightsBtn" class="btn btn-secondary" onclick="handleClaudeInsightsClick()">
                                <span id="claudeInsightsText">Claude Insights</span>
                            </button>
                            <button id="claudeRefreshBtn" class="btn btn-secondary refresh-btn" onclick="showRefreshPrompt('claude')" title="Refresh with custom prompt" style="display: none;">
                                <span></span>
                            </button>
                        </div>
                        <div class="insight-button-group">
                            <button id="geminiInsightsBtn" class="btn btn-primary" onclick="handleGeminiInsightsClick()">
                                <span id="geminiInsightsText">Gemini Insights</span>
                            </button>
                            <button id="geminiRefreshBtn" class="btn btn-primary refresh-btn" onclick="showRefreshPrompt('gemini')" title="Refresh with custom prompt" style="display: none;">
                                <span></span>
                            </button>
                        </div>
                        <div class="max-rows-control" style="display: flex; align-items: center; gap: 6px; margin-top: 8px; font-size: 12px;">
                            <label for="maxRowsInput" style="color: var(--text-secondary); white-space: nowrap;">Max rows:</label>
                            <input type="number" id="maxRowsInput" value="20" min="1" max="100" style="width: 50px; padding: 4px 6px; border: 1px solid var(--border-light); border-radius: 4px; font-size: 12px;" title="Maximum number of rows to send to Gemini API">
                        </div>
                    </div>
                </div>
                <div id="insightsContent" class="insights-content">
                    <div style="color: var(--text-secondary); font-style: italic; text-align: center; padding: 20px;">
                        Click "Claude Insights" or "Gemini Insights" for AI analysis. Use the  refresh button for custom prompts.
                    </div>
                </div>
            </div>
            
            <div class="group-control" id="group-control">
                <!-- Snapshot Selection moved to top -->
                <label class="form-label">Snapshot</label>
                <div class="input-button-group">
                    <select id="snapshot" class="form-select">
                        <option value="" disabled selected>Snapshots...</option>
                    </select>
                    <button class="btn btn-secondary" id="edit-snapshot-btn" title="Edit snapshot name" style="display: none;">Edit</button>
                    <button class="btn btn-secondary" id="delete-snapshot-btn" title="Delete snapshot" style="display: none;"></button>
                </div>
                
                <!-- Hidden snapshot name editor -->
                <div class="form-group snapshot-name-editor" id="snapshot-name-editor" style="display: none; margin-top: 12px;">
                    <input type="text" id="snapshot-name-input" class="form-control" placeholder="Enter snapshot name...">
                    <div style="margin-top: 8px; display: flex; gap: 8px;">
                        <button class="btn btn-primary" id="save-snapshot-btn">Save</button>
                        <button class="btn btn-secondary" id="cancel-snapshot-btn">Cancel</button>
                    </div>
                </div>
                
                <div class="group-header">
                    <span id="group-snapshot-info" class="group-snapshot-info"></span>
                </div>
                <div class="group-input-group">
                    <input type="text" id="group" class="form-control" placeholder="Enter names separated by commas (e.g., Loren, Ivy, Gary)...">
                    <button class="btn btn-secondary" id="group-toggle">
                        <span id="group-toggle-text">Group</span>
                        <span id="group-count">(0)</span>
                    </button>
                </div>
                <small class="form-help">Type names and press comma or enter to highlight. Click "Group" to show only marked participants.</small>
            </div>
            
            <!-- Raw Data Editor -->
            <div class="raw-data-control" id="raw-data-control" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <label class="form-label" style="margin-bottom: 0;">Raw Data Editor</label>
                    <button class="btn" id="raw-data-close" style="padding: 4px 8px; font-size: 16px; line-height: 1; background: none; border: 1px solid var(--border-light); color: var(--text-secondary);" title="Close Raw Data Editor"></button>
                </div>
                <div class="form-group" style="margin-bottom: 12px;">
                    <label class="form-label" style="font-size: 12px; margin-bottom: 4px;">Data Source</label>
                    <input type="text" id="raw-data-source" class="form-control" readonly style="font-size: 11px; background-color: var(--bg-tertiary); color: var(--text-secondary);" placeholder="Data source path will appear here...">
                </div>
                <div class="form-group">
                    <textarea id="raw-data-editor" class="form-control" rows="10" placeholder="Raw JSON data will appear here..."></textarea>
                    <div style="margin-top: 8px;">
                        <button class="btn btn-primary" id="apply-raw-data">Display Changes</button>
                        <button class="btn btn-secondary" id="revert-raw-data">Revert</button>
                    </div>
                    <small class="form-help">Edit the JSON data and click "Display Changes" to update the participant list. Click "Revert" to restore original data.</small>
                </div>
            </div>
            
            <!-- Team Legend and Sort Controls (Shared across all views) -->
            <div class="team-legend" id="team-legend" style="display: none;">
                <div class="legend-header">
                    <h4>Filter by Team</h4>
                    <div class="legend-controls">
                        <div class="button-with-dropdown">
                            <button class="btn btn-sm btn-secondary" id="sort-toggle">Sort by</button>
                            <div class="sort-dropdown" id="sort-dropdown" style="display: none;">
                                <div class="sort-header">
                                    <h4>Sort by</h4>
                                    <button class="btn btn-sm btn-secondary" id="close-sort"></button>
                                </div>
                                <div class="sort-items" id="sort-items"></div>
                            </div>
                        </div>
                        <div class="button-with-dropdown">
                            <button class="btn btn-sm btn-secondary" id="status-toggle">Status</button>
                            <div class="status-dropdown" id="status-dropdown" style="display: none;">
                                <div class="status-header">
                                    <h4>Filter by Status</h4>
                                    <button class="btn btn-sm btn-secondary" id="close-status"></button>
                                </div>
                                <div class="status-items" id="status-items"></div>
                            </div>
                        </div>
                    </div>
                    <div class="legend-controls-condensed">
                        <button class="condensed-icon-btn" id="filters-toggle" title="Filters">
                            
                        </button>
                        <div class="menu-dropdown" id="filters-dropdown" style="display: none;">
                            <div class="menu-item" id="condensed-sort-toggle">Sort by</div>
                            <div class="menu-item" id="condensed-status-toggle">Status</div>
                        </div>
                    </div>
                </div>
                <div class="legend-items" id="legend-items"></div>
            </div>
            
            <!-- View Toggle Controls -->
            <div class="view-controls">
                <div class="view-buttons">
                    <button class="btn btn-secondary view-btn active" id="column-view-btn" data-view="column">
                        Columns
                    </button>
                    <button class="btn btn-secondary view-btn" id="table-view-btn" data-view="table">
                        Table
                    </button>
                    <button class="btn btn-secondary view-btn" id="gallery-view-btn" data-view="gallery">
                        Gallery
                    </button>
                </div>
                <div class="view-buttons-condensed">
                    <button class="condensed-icon-btn" id="column-view-condensed" data-view="column" title="Columns">
                        
                    </button>
                    <button class="condensed-icon-btn" id="table-view-condensed" data-view="table" title="Table">
                        
                    </button>
                    <button class="condensed-icon-btn" id="gallery-view-condensed" data-view="gallery" title="Gallery">
                        
                    </button>
                </div>
                <div class="table-info">
                    <span id="results-count" style="margin-right:10px">0 results</span>
                    <div class="pagination-controls" style="display: none;">
                        <button id="prev-page" class="pagination-btn" title="Previous page"></button>
                        <button id="next-page" class="pagination-btn" title="Next page"></button>
                    </div>
                </div>
            </div>
            
            
            <!-- Column View (Default) -->
            <div class="view-container" id="column-view">
                <div class="participants-grid" id="participants-column-grid"></div>
            </div>
            
            <!-- Table View -->
            <div class="view-container" id="table-view" style="display: none;">
                <div class="table-container">
                    <table id="participants-table" class="participants-table">
                        <thead id="table-header"></thead>
                        <tbody id="table-body"></tbody>
                    </table>
                </div>
            </div>
            
            <!-- Gallery View -->
            <div class="view-container" id="gallery-view" style="display: none;">
                <div class="participants-gallery" id="participants-gallery-grid"></div>
            </div>
            
            <!-- Email List (Admin Mode Only) -->
            <div id="emailListContainer" style="display: none; margin-top: 20px; border-top: 1px solid var(--border-light); padding-top: 20px;">
                <h3 style="margin-bottom: 12px; color: var(--text-primary); font-size: 16px; font-weight: 600;">
                     Extracted Emails
                </h3>
                <textarea 
                    id="emailList" 
                    readonly 
                    style="width: 100%; min-height: 80px; padding: 12px; border: 1px solid var(--border-light); border-radius: var(--radius-md); background: var(--bg-tertiary); color: var(--text-secondary); font-family: 'Courier New', monospace; font-size: 13px; resize: vertical; line-height: 1.4;"
                    placeholder="No emails found in the dataset"
                ></textarea>
                <div style="margin-top: 8px; font-size: 12px; color: var(--text-muted);">
                    <span id="emailCount">0 emails</span>  Click to select all
                </div>
            </div>
        </div>
        
        <!-- Gemini Setup Container (shown when Gemini key is not available) -->
        <div id="gemini-setup-container" style="display: none;"></div>
        
        <!-- Prompt Modal for custom AI prompts -->
        <div class="prompt-modal hidden" id="promptModal">
            <div class="prompt-modal-content">
                <h3 id="promptModalTitle">Refresh AI Insights</h3>
                <div style="margin-bottom: 16px; color: var(--text-secondary); font-size: 14px;">
                    Enter a custom prompt to send with your dataset:
                </div>
                <textarea id="promptInput" placeholder="Tell me an amazing poem about this data.">Tell me an amazing poem about this data.</textarea>
                <div class="modal-actions">
                    <button class="btn btn-secondary" onclick="closePromptModal()">Cancel</button>
                    <button id="promptSubmitBtn" class="btn btn-primary" onclick="submitPrompt()">Refresh Insights</button>
                </div>
            </div>
        </div>
        
        <!-- Status Messages (external to card) -->
        <div id="statusMessages" class="message-log" style="margin-bottom: 20px;"></div>
        
        <!-- Load Status Panel -->
        <div class="card" id="loadStatus" style="display: none;">
            <div id="participants-result"></div>
        </div>

    </div>

    <script src="../js/common.js"></script>
    <script src="../js/setup.js"></script>
    <script src="../js/list.js"></script>
    <script>
        const GEMINI_API_BASE = 'http://localhost:8081/api';
        
        // AI Insights variables
        let currentActiveAI = null;
        let currentPromptAI = null;
        const aiInsightsCache = JSON.parse(localStorage.getItem('aiInsightsCache') || '{}');
        const claudeInsightsCache = JSON.parse(localStorage.getItem('claudeInsightsCache') || '{}');
        
        // Pending analysis storage (like admin page)
        let pendingGeminiAnalysis = null;
        let pendingClaudeAnalysis = null;
        
        // AI Insights Functions
        function showAIInsightsSection() {
            const aiInsights = document.getElementById('aiInsights');
            if (aiInsights && window.participantsData && window.participantsData.length > 0) {
                // Only show if insights=all is in URL, otherwise respect the hidden state
                const insightsParam = getHash().insights;
                if (insightsParam === 'all') {
                    aiInsights.style.setProperty('display', 'block', 'important');
                }
                showAIInsightsButtons();
            }
        }
        
        function showAIInsightsButtons() {
            const cacheKey = getCurrentDataSource();
            const hasGeminiCache = aiInsightsCache[cacheKey];
            const hasClaudeCache = claudeInsightsCache[cacheKey];
            
            // Update button states
            const claudeBtn = document.getElementById('claudeInsightsBtn');
            const claudeText = document.getElementById('claudeInsightsText');
            const claudeRefresh = document.getElementById('claudeRefreshBtn');
            const geminiBtn = document.getElementById('geminiInsightsBtn');
            const geminiText = document.getElementById('geminiInsightsText');
            const geminiRefresh = document.getElementById('geminiRefreshBtn');
            
            if (claudeBtn && claudeText && claudeRefresh) {
                claudeBtn.disabled = false;
                claudeText.textContent = hasClaudeCache ? 'Claude Insights (Cached)' : 'Claude Insights';
                claudeRefresh.style.display = hasClaudeCache ? 'flex' : 'none';
                // Don't auto-highlight - highlighting only shows the currently displayed insights
            }
            
            if (geminiBtn && geminiText && geminiRefresh) {
                geminiBtn.disabled = false;
                geminiText.textContent = hasGeminiCache ? 'Gemini Insights (Cached)' : 'Gemini Insights';
                geminiRefresh.style.display = hasGeminiCache ? 'flex' : 'none';
                // Don't auto-highlight - highlighting only shows the currently displayed insights
            }
        }
        
        function getCurrentDataSource() {
            const selectedOption = fileSelect.options[fileSelect.selectedIndex];
            if (selectedOption && selectedOption.getAttribute('data-url')) {
                return selectedOption.getAttribute('data-url');
            }
            return selectedFile || 'unknown';
        }
        
        function handleClaudeInsightsClick() {
            if (!window.participantsData || window.participantsData.length === 0) {
                appendStatusMessage('No data available for analysis. Please load a list first.', 'error');
                return;
            }
            
            const cacheKey = getCurrentDataSource();
            if (claudeInsightsCache[cacheKey]) {
                displayCachedInsights(cacheKey, 'claude');
            } else {
                showRefreshPrompt('claude');
            }
        }
        
        function handleGeminiInsightsClick() {
            if (!window.participantsData || window.participantsData.length === 0) {
                appendStatusMessage('No data available for analysis. Please load a list first.', 'error');
                return;
            }
            
            const cacheKey = getCurrentDataSource();
            if (aiInsightsCache[cacheKey]) {
                displayCachedInsights(cacheKey, 'gemini');
            } else {
                showRefreshPrompt('gemini');
            }
        }
        
        async function displayCachedInsights(cacheKey, aiType) {
            const cache = aiType === 'claude' ? claudeInsightsCache : aiInsightsCache;
            const insights = cache[cacheKey];
            
            if (insights) {
                // Clear any existing highlighting first
                const claudeBtn = document.getElementById('claudeInsightsBtn');
                const geminiBtn = document.getElementById('geminiInsightsBtn');
                if (claudeBtn) claudeBtn.classList.remove('cached-insights');
                if (geminiBtn) geminiBtn.classList.remove('cached-insights');
                
                // Highlight only the button for the currently displayed insights
                const button = document.getElementById(aiType === 'claude' ? 'claudeInsightsBtn' : 'geminiInsightsBtn');
                if (button) {
                    button.classList.add('cached-insights');
                }
                
                // Use shared display functions
                if (aiType === 'claude') {
                    await displaySharedClaudeInsights(
                        insights.analysis, 
                        insights.totalRecords || 0, 
                        insights.sampleSize || 0, 
                        false, 
                        insights.customPrompt || insights.prompt || 'Standard data analysis prompt'
                    );
                } else {
                    await displaySharedGeminiInsights(
                        insights.analysis, 
                        insights.totalRecords || 0, 
                        insights.sampleSize || 0, 
                        false, 
                        insights.customPrompt || insights.prompt || 'Standard data analysis prompt'
                    );
                }
                
                // Update button states
                currentActiveAI = aiType;
                updateActiveAIButtons();
            }
        }
        
        function showRefreshPrompt(aiType) {
            currentPromptAI = aiType;
            const modal = document.getElementById('promptModal');
            const title = document.getElementById('promptModalTitle');
            
            title.textContent = `${aiType === 'claude' ? 'Claude' : 'Gemini'} Analysis`;
            modal.classList.remove('hidden');
        }
        
        function closePromptModal() {
            const modal = document.getElementById('promptModal');
            modal.classList.add('hidden');
            currentPromptAI = null;
        }
        
        // Function to get currently filtered and sorted data for AI analysis
        function getCurrentlyDisplayedData() {
            // Start with the sorted data (allRowsData has sort order applied)
            if (!allRowsData || allRowsData.length === 0) {
                console.warn(' getCurrentlyDisplayedData called but allRowsData is empty');
                return [];
            }
            
            let filteredData = [...allRowsData];
            
            // Apply status filter (same logic as in applyAllFilters)
            if (!selectedStatuses.has('All') && selectedStatuses.size > 0) {
                filteredData = filteredData.filter(participant => {
                    const status = participant.Status || 'Unknown';
                    return selectedStatuses.has(status);
                });
            }
            
            // Apply team filter if active
            if (currentTeamFilter) {
                filteredData = filteredData.filter(participant => {
                    const participantTeamClasses = getAllTeamClasses(participant.Team);
                    return participantTeamClasses.includes(currentTeamFilter);
                });
            }
            
            // Apply group participants filter if active
            if (showOnlyGroup) {
                filteredData = filteredData.filter(participant => {
                    const name = getParticipantName(participant);
                    return Array.from(groupParticipants).some(groupName => 
                        groupName.toLowerCase() === name.toLowerCase()
                    );
                });
            }
            
            return filteredData;
        }

        async function submitPrompt() {
            const prompt = document.getElementById('promptInput').value;
            const aiType = currentPromptAI;
            
            if (!prompt || !aiType || !window.participantsData) return;
            
            closePromptModal();
            
            // Show loading state
            const content = document.getElementById('insightsContent');
            content.innerHTML = '<div style="padding: 20px; text-align: center;"> Generating insights...</div>';
            
            try {
                // Get currently filtered and sorted data instead of raw data
                const currentlyDisplayedData = getCurrentlyDisplayedData();
                const maxRows = parseInt(document.getElementById('maxRowsInput')?.value || 20);
                const analysisData = currentlyDisplayedData.slice(0, maxRows);
                
                // Get all available headers from the original data to include complete row information
                const allHeaders = window.participantsData.length > 0 ? Object.keys(window.participantsData[0]) : [];
                
                console.log(` AI Analysis Data Summary:
- Original dataset: ${window.participantsData.length} records
- After filters: ${currentlyDisplayedData.length} records  
- Sent for analysis: ${analysisData.length} records
- All available columns: ${allHeaders.length} (${allHeaders.join(', ')})
- Current sort: ${currentSortColumn || 'none'} ${currentSortOrder || ''}`);
                
                // Ensure analysis data includes all columns, not just visible ones
                const completeAnalysisData = analysisData.map(row => {
                    const completeRow = {};
                    allHeaders.forEach(header => {
                        completeRow[header] = row[header] || null;
                    });
                    return completeRow;
                });
                
                const endpoint = aiType === 'claude' ? '/claude/analyze' : '/gemini/analyze';
                const response = await fetch(`${GEMINI_API_BASE}${endpoint}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(aiType === 'claude' ? {
                        prompt: prompt,
                        dataset_info: {
                            record_count: window.participantsData.length,
                            filtered_count: currentlyDisplayedData.length,
                            sample_data: completeAnalysisData,
                            headers: allHeaders,
                            sort_info: {
                                column: currentSortColumn || null,
                                order: currentSortOrder || null
                            },
                            filter_info: {
                                status_filter: selectedStatuses.size > 0 && !selectedStatuses.has('All') ? Array.from(selectedStatuses) : null,
                                team_filter: currentTeamFilter || null,
                                group_filter: showOnlyGroup || false
                            }
                        }
                    } : {
                        // For Gemini, include dataset directly in prompt with filter/sort context
                        prompt: `${prompt}

**Dataset Context:**
-- Original Total Records: ${window.participantsData.length}
-- After Filters Applied: ${currentlyDisplayedData.length}
-- Sample Size for Analysis: ${completeAnalysisData.length}
-- All Available Headers: ${allHeaders.join(', ')}
-- Current Sort Order: ${currentSortColumn ? `${currentSortColumn} (${currentSortOrder})` : 'Default order'}
-- Active Filters: ${(() => {
    const filters = [];
    if (selectedStatuses.size > 0 && !selectedStatuses.has('All')) {
        filters.push(`Status: ${Array.from(selectedStatuses).join(', ')}`);
    }
    if (currentTeamFilter) {
        filters.push(`Team: ${currentTeamFilter}`);
    }
    if (showOnlyGroup) {
        filters.push('Group participants only');
    }
    return filters.length > 0 ? filters.join('; ') : 'None';
})()}

**Sample Data (JSON format - filtered/sorted as displayed):**
${JSON.stringify(completeAnalysisData, null, 2)}`,
                        data_context: null
                    })
                });
                
                const result = await response.json();
                
                if (result.success && result.analysis) {
                    // Append token usage information if available
                    let analysisWithTokens = result.analysis;
                    if (result.token_usage) {
                        analysisWithTokens = appendTokenUsage(result.analysis, result.token_usage);
                    }
                    
                    // Store in pending analysis (don't save to cache yet - user needs to save)
                    const pendingData = {
                        success: true,
                        analysis: analysisWithTokens,
                        totalRecords: window.participantsData.length,
                        filteredRecords: currentlyDisplayedData.length,
                        sampleSize: completeAnalysisData.length,
                        timestamp: new Date().toISOString(),
                        customPrompt: prompt,
                        sortInfo: {
                            column: currentSortColumn || null,
                            order: currentSortOrder || null
                        },
                        filterInfo: {
                            status: selectedStatuses.size > 0 && !selectedStatuses.has('All') ? Array.from(selectedStatuses) : null,
                            team: currentTeamFilter || null,
                            groupOnly: showOnlyGroup || false
                        }
                    };
                    
                    if (aiType === 'claude') {
                        pendingClaudeAnalysis = pendingData;
                        // Display with Save/Cancel buttons - show filtered count in UI
                        await displaySharedClaudeInsights(analysisWithTokens, currentlyDisplayedData.length, completeAnalysisData.length, true, prompt);
                        showTopMessage(' Claude analysis complete! Choose Save to keep or Cancel to revert.', 'success', 0);
                    } else {
                        pendingGeminiAnalysis = pendingData;
                        // Display with Save/Cancel buttons - show filtered count in UI
                        await displaySharedGeminiInsights(analysisWithTokens, currentlyDisplayedData.length, completeAnalysisData.length, true, prompt);
                        showTopMessage(' Gemini analysis complete! Choose Save to keep or Cancel to revert.', 'success', 0);
                    }
                    
                    showAIInsightsButtons(); // Update button states
                    
                } else {
                    content.innerHTML = `<div style="padding: 16px; color: var(--error-color);">Analysis failed: ${result.error || 'Unknown error'}</div>`;
                }
                
            } catch (error) {
                console.error('AI analysis error:', error);
                // Check if this is likely a connection error (server not running)
                const isConnectionError = error.message.includes('fetch') || 
                                        error.message.includes('NetworkError') || 
                                        error.message.includes('Failed to fetch');
                
                if (isConnectionError) {
                    content.innerHTML = `<div style="padding: 16px; color: #92400E; background: #FEF3C7; border: 1px solid #F59E0B; border-radius: 4px;">
                         Analysis failed: Start the Rust API server first<br>
                        <small style="margin-top: 4px; display: block; opacity: 0.8;">The AI insights require the backend server to be running on port 8081</small>
                    </div>`;
                    showTopMessage(' AI Analysis failed: Rust API server not running on port 8081', 'error', 8000);
                } else {
                    content.innerHTML = `<div style="padding: 16px; color: var(--error-color);">Analysis failed: ${error.message}</div>`;
                }
            }
        }
        
        function updateActiveAIButtons() {
            // Update button states based on active AI
            const claudeBtn = document.getElementById('claudeInsightsBtn');
            const geminiBtn = document.getElementById('geminiInsightsBtn');
            
            if (claudeBtn && geminiBtn) {
                claudeBtn.classList.toggle('active', currentActiveAI === 'claude');
                geminiBtn.classList.toggle('active', currentActiveAI === 'gemini');
            }
        }
        
        // Save/Cancel functions for Claude analysis (required by shared functions)
        function saveClaudeAnalysis() {
            if (pendingClaudeAnalysis) {
                const cacheKey = getCurrentDataSource();
                console.log('Saving Claude analysis to cache with key:', cacheKey);
                
                
                // Save to cache
                claudeInsightsCache[cacheKey] = pendingClaudeAnalysis;
                localStorage.setItem('claudeInsightsCache', JSON.stringify(claudeInsightsCache));
                
                // Clear pending analysis
                pendingClaudeAnalysis = null;
                
                // Re-display without Save/Cancel buttons
                displaySharedClaudeInsights(
                    claudeInsightsCache[cacheKey].analysis, 
                    claudeInsightsCache[cacheKey].totalRecords, 
                    claudeInsightsCache[cacheKey].sampleSize, 
                    false,
                    claudeInsightsCache[cacheKey].customPrompt
                );
                
                showAIInsightsButtons(); // Update button states
            }
        }
        
        function cancelClaudeAnalysis() {
            if (pendingClaudeAnalysis) {
                pendingClaudeAnalysis = null;
                const cacheKey = getCurrentDataSource();
                
                // Check if there's a cached version to restore
                if (claudeInsightsCache[cacheKey]) {
                    displayCachedInsights(cacheKey, 'claude');
                } else {
                    const content = document.getElementById('insightsContent');
                    content.innerHTML = '<div style="color: var(--text-secondary); font-style: italic; text-align: center; padding: 20px;">Click "Claude Insights" or "Gemini Insights" for AI analysis. Use the  refresh button for custom prompts.</div>';
                }
            }
        }
        
        // Save/Cancel functions for Gemini analysis (required by shared functions)
        function saveGeminiAnalysis() {
            if (pendingGeminiAnalysis) {
                const cacheKey = getCurrentDataSource();
                console.log('Saving Gemini analysis to cache with key:', cacheKey);
                
                
                // Save to cache
                aiInsightsCache[cacheKey] = pendingGeminiAnalysis;
                localStorage.setItem('aiInsightsCache', JSON.stringify(aiInsightsCache));
                
                // Clear pending analysis
                pendingGeminiAnalysis = null;
                
                // Re-display without Save/Cancel buttons
                displaySharedGeminiInsights(
                    aiInsightsCache[cacheKey].analysis, 
                    aiInsightsCache[cacheKey].totalRecords, 
                    aiInsightsCache[cacheKey].sampleSize, 
                    false,
                    aiInsightsCache[cacheKey].customPrompt
                );
                
                showAIInsightsButtons(); // Update button states
            }
        }
        
        function cancelGeminiAnalysis() {
            if (pendingGeminiAnalysis) {
                pendingGeminiAnalysis = null;
                const cacheKey = getCurrentDataSource();
                
                // Check if there's a cached version to restore
                if (aiInsightsCache[cacheKey]) {
                    displayCachedInsights(cacheKey, 'gemini');
                } else {
                    const content = document.getElementById('insightsContent');
                    content.innerHTML = '<div style="color: var(--text-secondary); font-style: italic; text-align: center; padding: 20px;">Click "Claude Insights" or "Gemini Insights" for AI analysis. Use the  refresh button for custom prompts.</div>';
                }
            }
        }

        // Google Meetup Participants
        const getParticipantsButton = document.getElementById('get-participants');
        const participantsSpinner = document.getElementById('participants-spinner');
        const participantsResult = document.getElementById('participants-result');
        const fileSelect = document.getElementById('fileSelect');
        const customFileSection = document.getElementById('customFileSection');
        const fileInput = document.getElementById('excelFile');
        const fileDisplay = document.getElementById('fileDisplay');
        const statusMessages = document.getElementById('statusMessages');
        
        let selectedFile = null;
        let customFiles = {};

        // Helper function to append messages to statusMessages
        function appendStatusMessage(message, type = 'info') {
            const messageDiv = document.createElement('div');
            messageDiv.className = `status-message ${type}`;
            messageDiv.style.display = 'block'; // Ensure message is visible
            messageDiv.innerHTML = message;
            statusMessages.appendChild(messageDiv);
        }

        // Helper function to show messages in top message area
        function showTopMessage(message, type = 'warning', duration = 10000) {
            const messageArea = document.getElementById('top-message-area');
            const messageContent = document.getElementById('top-message-content');
            
            if (messageArea && messageContent) {
                messageContent.innerHTML = message;
                
                // Update styling based on message type
                const card = messageArea.querySelector('.card');
                if (type === 'error') {
                    card.style.borderLeftColor = '#ef4444';
                    card.style.background = '#fef2f2';
                    card.style.color = '#dc2626';
                } else if (type === 'success') {
                    card.style.borderLeftColor = '#10b981';
                    card.style.background = '#f0fdf4';
                    card.style.color = '#065f46';
                } else { // warning
                    card.style.borderLeftColor = '#f59e0b';
                    card.style.background = '#fef3c7';
                    card.style.color = '#92400e';
                }
                
                messageArea.style.display = 'block';
                
                // Auto-hide after specified duration
                if (duration > 0) {
                    setTimeout(() => {
                        messageArea.style.display = 'none';
                    }, duration);
                }
            }
        }

        // Helper function to hide top message
        function hideTopMessage() {
            const messageArea = document.getElementById('top-message-area');
            if (messageArea) {
                messageArea.style.display = 'none';
            }
        }

        // Helper function to get modelteam URL from dropdown options
        function getModelteamUrl() {
            const modelteamOption = Array.from(fileSelect.options).find(option => option.value === 'modelteam');
            return modelteamOption ? modelteamOption.getAttribute('data-url') : null;
        }
        
        async function getSubsetUsingSnapshot() {
            // Check for admin=1 and list=modelteam in hash
            const hash = getHash();
            const isAdmin = hash.admin === '1';
            const isModelTeam = hash.list === 'modelteam';
            
            let meetupLink;
            let isCors;
            let allFields;
            let config = null; // Declare config in broader scope
            
            if (isAdmin && isModelTeam) {
                // Use community/people.env for admin modelteam (treated as CSV)
                meetupLink = '../../community/people.env';
                isCors = false;
                console.log('Admin mode: Loading from community/people.env (treated as CSV)');
            } else {
                // Normal processing
                const currentValue = fileSelect.value;
                const selectedOption = Array.from(fileSelect.options).find(opt => opt.value === currentValue);
                meetupLink = selectedOption?.getAttribute('data-url') || selectedFile;
                isCors = selectedOption?.getAttribute('data-cors') === 'true';
                allFields = selectedOption?.getAttribute('data-all-fields');
                
                // Get config for filtering (e.g., int_required)
                const intRequired = selectedOption?.getAttribute('data-int-required');
                config = intRequired ? { int_required: intRequired } : null;
                
                console.log('=== getSubsetUsingSnapshot DEBUG ===');
                console.log('Current fileSelect value:', currentValue);
                console.log('Found option:', selectedOption ? selectedOption.textContent : 'Not found');
                console.log('Option data-url:', selectedOption?.getAttribute('data-url'));
                console.log('Option data-cors attribute:', selectedOption?.getAttribute('data-cors'));
                console.log('Option data-all-fields attribute:', selectedOption?.getAttribute('data-all-fields'));
                console.log('isCors resolved to:', isCors);
                console.log('selectedFile variable:', selectedFile);
                console.log('Final meetupLink:', meetupLink);
                
                // If no valid URL found, try to get modelteam URL from dropdown
                if (!meetupLink) {
                    meetupLink = getModelteamUrl();
                    if (!meetupLink) {
                        appendStatusMessage('Please select a valid data source or wait for options to load.', 'error');
                        return;
                    }
                }
            }

            // Check if the URL points to a binary file that would overwhelm CPU
            const binaryExtensions = ['.tiff', '.tif', '.hdf5', '.h5', '.pdf', '.png', '.jpg', '.jpeg', '.zip', '.tar', '.gz'];
            const isBinaryFile = binaryExtensions.some(ext => meetupLink.toLowerCase().includes(ext));
            
            if (isBinaryFile) {
                const currentList = getHash().list || fileSelect.value || 'Unknown';
                const currentOption = Array.from(fileSelect.options).find(opt => opt.value === currentList);
                const listTitle = currentOption?.textContent || currentList;
                
                showTopMessage(
                    `<strong>Binary File Detected</strong><br>` +
                    `The selected item "${listTitle}" points to a binary file (${meetupLink.split('/').pop()}) which cannot be processed as tabular data.<br>` +
                    `<small>Supported formats: CSV, JSON, API endpoints that return structured data.</small>`,
                    'error',
                    8000
                );
                
                getParticipantsButton.disabled = false;
                participantsSpinner.style.display = 'none';
                return;
            }

            try {
                getParticipantsButton.disabled = true;
                participantsSpinner.style.display = 'inline-block';
                
                // Hide table and clear content immediately to prevent flash
                const participantsTableCard = document.getElementById('participants-table-card');
                const tableContainer = document.getElementById('participants-table-container');
                
                if (participantsTableCard) {
                    participantsTableCard.style.display = 'none';
                }
                if (tableContainer) {
                    tableContainer.innerHTML = '<div class="loading-state">Loading data...</div>';
                }

                // Add iframe for bsky list if detected
                const hash = getHash ? getHash() : {};
                console.log('Current hash:', hash, 'list value:', hash.list);
                if (hash.list === 'bsky') {
                    console.log('Creating bsky iframe container');
                    const bskyIframeContainer = document.createElement('div');
                    bskyIframeContainer.id = 'bsky-iframe-container';
                    bskyIframeContainer.style.marginBottom = '20px';
                    bskyIframeContainer.style.padding = '10px';
                    bskyIframeContainer.style.border = '1px solid #ddd';
                    bskyIframeContainer.style.borderRadius = '8px';
                    bskyIframeContainer.style.backgroundColor = '#f9f9f9';
                    
                    const label = document.createElement('div');
                    label.style.fontSize = '14px';
                    label.style.fontWeight = 'bold';
                    label.style.marginBottom = '8px';
                    label.style.color = '#333';
                    label.textContent = 'BlueSky RSS Feed (via CORS proxy)';
                    bskyIframeContainer.appendChild(label);
                    
                    const iframe = document.createElement('iframe');
                    iframe.src = `https://cors-anywhere.herokuapp.com`;
                    iframe.style.width = '100%';
                    iframe.style.height = '400px';
                    iframe.style.border = '4px solid blue';
                    iframe.style.borderRadius = '4px';
                    bskyIframeContainer.appendChild(iframe);
                    
                    const note = document.createElement('div');
                    note.style.fontSize = '12px';
                    note.style.color = '#666';
                    note.style.marginTop = '8px';
                    note.textContent = 'RSS feed displayed via cors-anywhere.herokuapp.com to bypass CORS restrictions';
                    bskyIframeContainer.appendChild(note);
                    
                    // Insert before the table container
                    if (tableContainer && tableContainer.parentNode) {
                        tableContainer.parentNode.insertBefore(bskyIframeContainer, tableContainer);
                    }
                }

                // Use unified data loading from js/list.js
                console.log(`Loading data from: ${meetupLink}, CORS: ${isCors}`);
                console.log('API_BASE:', GEMINI_API_BASE);
                console.log('Config for filtering:', config);
                const loadResult = await loadUnifiedData(meetupLink, {
                    forceCorsProxy: isCors,
                    API_BASE: GEMINI_API_BASE,
                    allFields: allFields,
                    config: config
                });
                console.log('Load result status:', loadResult.success, 'data length:', loadResult.data?.length);
                
                if (!loadResult.data || loadResult.data.length === 0) {
                    const errorMessage = `No data found in the source\n\nPath attempted: ${meetupLink}`;
                    
                    // Show error in status messages
                    appendStatusMessage(`<h4>No Data Found</h4><p>${errorMessage}</p>`, 'error');
                    
                    // Populate Raw Data Editor with the load result
                    const rawDataEditor = document.getElementById('raw-data-editor');
                    const rawDataSource = document.getElementById('raw-data-source');
                    
                    if (rawDataEditor) {
                        rawDataEditor.value = JSON.stringify(loadResult, null, 2);
                    }
                    
                    if (rawDataSource) {
                        rawDataSource.value = meetupLink;
                    }
                    
                    // Show Raw Data Editor panel
                    const rawDataControl = document.getElementById('raw-data-control');
                    if (rawDataControl) {
                        rawDataControl.style.display = 'block';
                        
                        // Update toggle text
                        const rawDataText = document.getElementById('raw-data-text');
                        if (rawDataText) {
                            rawDataText.textContent = 'Hide Raw Data';
                        }
                        
                        // Set rawDataVisible flag
                        if (typeof rawDataVisible !== 'undefined') {
                            rawDataVisible = true;
                        }
                    }
                    
                    // Show the table card so the 3-dot menu remains accessible
                    document.getElementById('participants-table-card').style.display = 'block';
                    
                    // Show upload fallback
                    const uploadFallback = document.getElementById('upload-fallback');
                    if (uploadFallback) {
                        uploadFallback.style.display = 'block';
                    }
                    
                    return; // Exit the function instead of throwing
                }
                
                // Filter out any null/undefined rows
                const validData = loadResult.data.filter(row => row && typeof row === 'object');
                
                if (validData.length === 0) {
                    const errorMessage = `No valid data found in the source\n\nPath attempted: ${meetupLink}`;
                    
                    // Show error in status messages
                    appendStatusMessage(`<h4>No Valid Data Found</h4><p>${errorMessage}</p>`, 'error');
                    
                    // Populate Raw Data Editor with the load result
                    const rawDataEditor = document.getElementById('raw-data-editor');
                    const rawDataSource = document.getElementById('raw-data-source');
                    
                    if (rawDataEditor) {
                        rawDataEditor.value = JSON.stringify(loadResult, null, 2);
                    }
                    
                    if (rawDataSource) {
                        rawDataSource.value = meetupLink;
                    }
                    
                    // Show Raw Data Editor panel
                    const rawDataControl = document.getElementById('raw-data-control');
                    if (rawDataControl) {
                        rawDataControl.style.display = 'block';
                        
                        // Update toggle text
                        const rawDataText = document.getElementById('raw-data-text');
                        if (rawDataText) {
                            rawDataText.textContent = 'Hide Raw Data';
                        }
                        
                        // Set rawDataVisible flag
                        if (typeof rawDataVisible !== 'undefined') {
                            rawDataVisible = true;
                        }
                    }
                    
                    // Show the table card so the 3-dot menu remains accessible
                    document.getElementById('participants-table-card').style.display = 'block';
                    
                    // Show upload fallback
                    const uploadFallback = document.getElementById('upload-fallback');
                    if (uploadFallback) {
                        uploadFallback.style.display = 'block';
                    }
                    
                    return; // Exit the function instead of throwing
                }
                
                // Reset team legend flag for new data
                initialTeamLegendGenerated = false;
                
                // Always populate Raw Data Editor when data is successfully fetched
                const rawDataEditor = document.getElementById('raw-data-editor');
                const rawDataSource = document.getElementById('raw-data-source');
                
                if (rawDataEditor) {
                    // Use the raw data before preprocessing
                    originalRawData = JSON.parse(JSON.stringify(loadResult.data));
                    rawDataEditor.value = JSON.stringify(loadResult.data, null, 2);
                }
                
                if (rawDataSource) {
                    rawDataSource.value = meetupLink;
                }
                
                displayTableLayout(validData);
                
                // Extract and display emails if Email column exists
                extractAndDisplayEmails(validData);
                
                // Store the original loaded count for pagination
                originalLoadedCount = validData.length;
                
                const sourceDescription = isCors ? 
                    `CORS-restricted ${loadResult.format.toUpperCase()} source using Rust proxy` : 
                    `${loadResult.format.toUpperCase()} source`;
                appendStatusMessage(`Successfully loaded ${validData.length} records from ${sourceDescription}`, 'success');
                
                // Show UI elements after successful data load
                showListDisplayElements();
                
                // Show AI Insights section after successful data load
                showAIInsightsSection();
                
                // Add iframe for bsky list after successful data load
                if (typeof hash === 'undefined') {
                    hash = getHash ? getHash() : {};
                }
                
                // Hide existing CORS iframe container if switching to non-bsky feed
                const existingContainer = document.getElementById('cors-iframe-container');
                if (existingContainer) {
                    if (hash.list === 'bsky') {
                        existingContainer.style.display = 'block';
                    } else {
                        existingContainer.style.display = 'none';
                    }
                }
                
                if (hash.list === 'bsky') {
                    console.log('Adding bsky iframe after successful data load');
                    
                    // Remove any existing iframe container only if it exists
                    if (existingContainer) {
                        existingContainer.remove();
                    }
                    
                    const corsIframeContainer = document.createElement('div');
                    corsIframeContainer.id = 'cors-iframe-container';
                    corsIframeContainer.style.marginBottom = '20px';
                    corsIframeContainer.style.padding = '10px';
                    corsIframeContainer.style.border = '1px solid #ddd';
                    corsIframeContainer.style.borderRadius = '8px';
                    corsIframeContainer.style.backgroundColor = '#f9f9f9';
                    
                    const label = document.createElement('div');
                    label.style.fontSize = '14px';
                    label.style.fontWeight = 'bold';
                    label.style.marginBottom = '8px';
                    label.style.color = '#333';
                    label.textContent = 'BlueSky RSS Feed (via CORS proxy)';
                    corsIframeContainer.appendChild(label);
                    
                    const iframe = document.createElement('iframe');
                    iframe.src = `https://cors-anywhere.herokuapp.com`;
                    iframe.style.width = '100%';
                    iframe.style.height = '350px';
                    iframe.style.minHeight = 'unset';
                    iframe.style.border = '4px solid blue';
                    iframe.style.borderRadius = '4px';
                    corsIframeContainer.appendChild(iframe);
                    
                    const note = document.createElement('div');
                    note.style.fontSize = '12px';
                    note.style.color = '#666';
                    note.style.marginTop = '8px';
                    note.innerHTML = `RSS feed displayed via <a href="https://cors-anywhere.herokuapp.com" target="_blank">cors-anywhere.herokuapp.com</a> to bypass CORS restrictions`;
                    corsIframeContainer.appendChild(note);
                    
                    // Insert at the bottom of the main content area
                    const mainContent = document.getElementById('participants-table-card') || document.getElementById('table-view');
                    if (mainContent && mainContent.parentNode) {
                        mainContent.parentNode.appendChild(corsIframeContainer);
                    }
                }
                
                // Load most recent snapshot for this list after data is loaded
                loadSnapshotOnPageLoad();

            } catch (error) {
                console.error('Full error details:', error);
                
                // Enhanced error reporting for call stack issues
                let errorMessage = error.message;
                let additionalInfo = '';
                
                if (error.message && error.message.includes('Maximum call stack size exceeded')) {
                    // Get stack trace info and estimate call stack depth
                    const stackTrace = error.stack || '';
                    const stackLines = stackTrace.split('\n').filter(line => line.trim().length > 0);
                    const stackDepth = stackLines.length;
                    
                    // Try to get some memory usage info if available
                    let memoryInfo = '';
                    if (performance && performance.memory) {
                        const memory = performance.memory;
                        const usedMB = Math.round(memory.usedJSHeapSize / 1024 / 1024);
                        const totalMB = Math.round(memory.totalJSHeapSize / 1024 / 1024);
                        const limitMB = Math.round(memory.jsHeapSizeLimit / 1024 / 1024);
                        memoryInfo = ` Memory usage: ${usedMB}MB used, ${totalMB}MB total, ${limitMB}MB limit.`;
                    }
                    
                    additionalInfo = ` Stack depth: ~${stackDepth} frames.${memoryInfo}`;
                    console.error('Call stack overflow details:');
                    console.error('- Estimated stack depth:', stackDepth, 'frames');
                    console.error('- Stack trace preview:', stackLines.slice(0, 10));
                    if (performance && performance.memory) {
                        console.error('- Memory info:', performance.memory);
                    }
                }
                
                // Always populate Raw Data Editor with error response for debugging
                const rawDataEditor = document.getElementById('raw-data-editor');
                const rawDataSource = document.getElementById('raw-data-source');
                
                if (rawDataEditor && error.rawResponse) {
                    // Show the raw error response from the API
                    originalRawData = JSON.parse(JSON.stringify(error.rawResponse));
                    rawDataEditor.value = JSON.stringify(error.rawResponse, null, 2);
                    console.log('Populated Raw Data Editor with error response:', error.rawResponse);
                }
                
                if (rawDataSource && error.requestUrl) {
                    rawDataSource.value = error.requestUrl;
                }
                
                appendStatusMessage(`<h4>Error Loading Data</h4><p>${errorMessage}${additionalInfo}</p>`, 'error');
                
                // Show the table card so the 3-dot menu remains accessible
                document.getElementById('participants-table-card').style.display = 'block';
                
                // Log error for debugging
                console.log('Showing upload fallback due to error:', error.message);
            } finally {
                getParticipantsButton.disabled = false;
                participantsSpinner.style.display = 'none';
            }
        }


        // Extract and display emails from data when Email column exists
        function extractAndDisplayEmails(data) {
            const emailContainer = document.getElementById('emailListContainer');
            const emailTextarea = document.getElementById('emailList');
            const emailCountSpan = document.getElementById('emailCount');
            
            // Check if we should show emails (localsite + modelteam)
            const isLocalsite = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            const hash = getHash ? getHash() : {};
            const isModelteam = hash.list === 'modelteam';
            
            if (!isLocalsite || !isModelteam) {
                if (emailContainer) emailContainer.style.display = 'none';
                return;
            }
            
            if (!data || !Array.isArray(data) || data.length === 0) {
                if (emailContainer) emailContainer.style.display = 'none';
                return;
            }
            
            // Find email columns (case-insensitive)
            const headers = Object.keys(data[0] || {});
            const emailColumns = headers.filter(header => 
                header.toLowerCase().includes('email') || 
                header.toLowerCase().includes('e-mail') ||
                header.toLowerCase() === 'mail'
            );
            
            if (emailColumns.length === 0) {
                // Show message about admin mode and community/people.csv file
                if (emailContainer) {
                    emailContainer.style.display = 'block';
                    
                    if (emailTextarea) {
                        emailTextarea.value = '';
                        emailTextarea.placeholder = 'No email columns found in current data. Use admin mode to load emails from local CSV.';
                    }
                    
                    if (emailCountSpan) {
                        emailCountSpan.innerHTML = `
                            <div style="color: var(--text-secondary); font-size: 12px; line-height: 1.4; margin-top: 4px;">
                                 To display emails: Add <code style="background: var(--bg-tertiary); padding: 2px 4px; border-radius: 3px;">&admin=1</code> to URL<br>
                                 Emails loaded from: <code style="background: var(--bg-tertiary); padding: 2px 4px; border-radius: 3px;">community/people.env</code> (treated as CSV, relative to team/projects/)
                            </div>
                        `;
                    }
                }
                return;
            }
            
            // Extract unique emails from all email columns
            const emailSet = new Set();
            
            data.forEach(row => {
                emailColumns.forEach(column => {
                    const emailValue = row[column];
                    if (emailValue && typeof emailValue === 'string') {
                        // Split by common separators and clean up
                        const emails = emailValue.split(/[,;|\s]+/)
                            .map(email => email.trim().toLowerCase())
                            .filter(email => {
                                // Basic email validation
                                return email && 
                                       email.includes('@') && 
                                       email.includes('.') && 
                                       email.length > 5 &&
                                       /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
                            });
                        
                        emails.forEach(email => emailSet.add(email));
                    }
                });
            });
            
            // Convert to sorted array
            const uniqueEmails = Array.from(emailSet).sort();
            
            if (uniqueEmails.length === 0) {
                if (emailContainer) emailContainer.style.display = 'none';
                return;
            }
            
            // Display the emails
            const emailsText = uniqueEmails.join(', ');
            if (emailTextarea) {
                emailTextarea.value = emailsText;
                emailTextarea.addEventListener('click', function() {
                    this.select();
                });
            }
            
            if (emailCountSpan) {
                emailCountSpan.textContent = `${uniqueEmails.length} email${uniqueEmails.length !== 1 ? 's' : ''}`;
            }
            
            if (emailContainer) {
                emailContainer.style.display = 'block';
            }
            
            // Store emails for filtering
            window.extractedEmails = uniqueEmails;
            window.allExtractedEmails = uniqueEmails;
        }

        // Update email list based on filtered participant data
        function updateFilteredEmails(filteredData) {
            const emailTextarea = document.getElementById('emailList');
            const emailCountSpan = document.getElementById('emailCount');
            
            if (!filteredData || filteredData.length === 0) {
                if (emailTextarea) {
                    emailTextarea.value = '';
                }
                if (emailCountSpan) {
                    emailCountSpan.textContent = '0 emails';
                }
                return;
            }
            
            // Find email columns in the current data structure
            const headers = Object.keys(filteredData[0] || {});
            const emailColumns = headers.filter(header => 
                header.toLowerCase().includes('email') || 
                header.toLowerCase().includes('e-mail') ||
                header.toLowerCase() === 'mail'
            );
            
            if (emailColumns.length === 0) {
                return;
            }
            
            // Extract unique emails from filtered data
            const emailSet = new Set();
            
            filteredData.forEach(row => {
                emailColumns.forEach(column => {
                    const emailValue = row[column];
                    if (emailValue && typeof emailValue === 'string') {
                        // Split by common separators and clean up
                        const emails = emailValue.split(/[,;|\s]+/)
                            .map(email => email.trim().toLowerCase())
                            .filter(email => {
                                // Basic email validation
                                return email && 
                                       email.includes('@') && 
                                       email.includes('.') && 
                                       email.length > 5 &&
                                       /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
                            });
                        
                        emails.forEach(email => emailSet.add(email));
                    }
                });
            });
            
            // Convert to sorted array
            const filteredEmails = Array.from(emailSet).sort();
            
            // Update the display
            const emailsText = filteredEmails.join(', ');
            if (emailTextarea) {
                emailTextarea.value = emailsText;
            }
            
            if (emailCountSpan) {
                emailCountSpan.textContent = `${filteredEmails.length} email${filteredEmails.length !== 1 ? 's' : ''}`;
            }
            
            // Update the stored filtered emails
            window.extractedEmails = filteredEmails;
            
            console.log(` Email filtering complete: ${window.allExtractedEmails.length} total  ${filteredEmails.length} filtered`);
        }

        // Note: parseCSV function is now available from js/list.js
        
        // Helper function to get list-specific localStorage key
        function getListStorageKey(baseKey) {
            const listId = getHash().list || 'default';
            return `${listId}_1_${baseKey}`;
        }
        
        // Current view mode and filtering
        let currentView = getHash().display || localStorage.getItem(getListStorageKey('participantsViewMode')) || 'column'; // Check URL hash first, then list-specific storage, then default to column
        let currentTeamFilter = getHash().team || localStorage.getItem(getListStorageKey('participantsTeamFilter')) || null;
        let currentLoadedList = null; // Track which list is currently loaded
        let initialTeamLegendGenerated = false;
        
        // Flag to prevent group parameter processing during status updates
        let isUpdatingStatus = false;
        
        // Track previous group parameter state to avoid false alerts
        let previousGroupParam = null;
        
        // File selection state
        const STORAGE_KEY = 'listObject';
        let allRowsData = [];
        let originalLoadedCount = 0; // Track total records loaded from source
        let groupParticipants = new Set();
        
        // Layout state
        let isFullscreen = JSON.parse(localStorage.getItem('isFullscreen') || 'false');
        let isCondensed = JSON.parse(localStorage.getItem('isCondensed') || 'false');
        
        // Sort functionality - only use localStorage (not in URL hash anymore)
        let currentSortColumn = localStorage.getItem(getListStorageKey('participantsSortColumn')) || 'Rows';
        let currentSortOrder = localStorage.getItem(getListStorageKey('participantsSortOrder')) || 'asc';
        
        // Pagination functionality
        let currentPage = 1;
        const recordsPerPage = 200;
        let totalRecords = 0;
        let originalDataOrder = [];
        
        // Status filtering - check URL hash first, then localStorage
        let selectedStatuses = new Set(getHash().status ? getHash().status.split(',') : JSON.parse(localStorage.getItem(getListStorageKey('participantsStatusFilter')) || '["All"]'));
        let availableStatuses = [];
        
        // Group participants toggle state - only load from cache if snapshots exist
        function getInitialGroupToggleState() {
            const snapshots = JSON.parse(localStorage.getItem(getSnapshotsStorageKey()) || '{}');
            const hasSnapshots = Object.keys(snapshots).length > 0;
            
            // If no snapshots exist, default to false regardless of cache
            if (!hasSnapshots) {
                return false;
            }
            
            return JSON.parse(localStorage.getItem(getListStorageKey('showOnlyGroup')) || 'false');
        }
        let showOnlyGroup = getInitialGroupToggleState();
        
        // Team color mapping
        const teamColors = {
            'js': { class: 'team-js', color: '#667eea', name: 'JS' },
            'ml': { class: 'team-ml', color: '#f093fb', name: 'ML' },
            'react': { class: 'team-react', color: '#4facfe', name: 'React' },
            'io': { class: 'team-io', color: '#43e97b', name: 'IO' },
            'ai': { class: 'team-ai', color: '#fa709a', name: 'AI' },
            'flask': { class: 'team-flask', color: '#ff9a9e', name: 'Flask' },
            'suite': { class: 'team-suite', color: '#a8edea', name: 'Suite' },
            'us': { class: 'team-us', color: '#ffecd2', name: 'US' },
            'auth': { class: 'team-auth', color: '#89f7fe', name: 'Auth' },
            'discord': { class: 'team-discord', color: '#c2e9fb', name: 'Discord' },
            'modelteam': { class: 'team-modelteam', color: '#10B981', name: 'Model Team' },
            'default': { class: 'team-default', color: '#d299c2', name: 'Other' }
        };
        
        // Display participants in all views
        function displayTableLayout(data) {
            console.log('displayTableLayout called with data:', data);
            if (!data || data.length === 0) {
                console.log('displayTableLayout: No data provided, returning early');
                return;
            }
            
            // For large datasets, only preprocess a sample for initial setup and the first page
            console.log('displayTableLayout: Processing large dataset with', data.length, 'records');
            
            let preprocessedData;
            if (data.length > 10000) {
                console.log(' Large dataset detected - using chunked preprocessing');
                // For large datasets, only preprocess first chunk + sample for column detection
                const sampleSize = Math.min(1000, data.length);
                const firstChunk = data.slice(0, recordsPerPage * 3); // First 3 pages worth
                const sampleData = data.slice(0, sampleSize);
                
                console.log(` Preprocessing sample of ${sampleSize} records for column detection`);
                preprocessParticipantData(sampleData.slice(0, 10)); // Just for column setup
                
                console.log(` Preprocessing first chunk of ${firstChunk.length} records`);
                preprocessedData = preprocessParticipantData(firstChunk);
                
                // Store original data for later pagination
                window.originalLargeDataset = data;
                window.isLargeDataset = true;
                
                console.log(` Initial chunk processed. Total dataset: ${data.length}, Initial chunk: ${preprocessedData.length}`);
            } else {
                console.log('displayTableLayout: Preprocessing all data...');
                preprocessedData = preprocessParticipantData(data);
                window.isLargeDataset = false;
            }
            
            const tableCard = document.getElementById('participants-table-card');
            const resultsCount = document.getElementById('results-count');
            
            // Reset to first page when new data loads
            currentPage = 1;
            
            // Update results count with pagination
            if (window.isLargeDataset) {
                // For large datasets, use original data length for total count
                totalRecords = data.length;
                updateResultsCount(data); // Pass original data for count calculation
            } else {
                updateResultsCount(preprocessedData);
            }
            
            // Store preprocessed data globally
            window.participantsData = preprocessedData;
            allRowsData = preprocessedData;
            originalDataOrder = [...preprocessedData]; // Store original order
            
            // Update Raw Data Editor with preprocessed data if it's currently visible
            if (rawDataVisible) {
                const rawDataEditor = document.getElementById('raw-data-editor');
                const rawDataSource = document.getElementById('raw-data-source');
                
                if (rawDataEditor && rawDataEditor.value) {
                    // Only update if the Raw Data Editor doesn't already have raw data
                    // (the raw data was already populated in getMeetupParticipants)
                    console.log('Raw Data Editor already populated with raw data, skipping preprocessed update');
                } else if (rawDataEditor) {
                    // Fallback: populate with preprocessed data if raw data wasn't available
                    originalRawData = JSON.parse(JSON.stringify(preprocessedData));
                    rawDataEditor.value = JSON.stringify(preprocessedData, null, 2);
                    
                    if (rawDataSource) {
                        rawDataSource.value = getCurrentDataSource();
                    }
                }
            }
            
            // Generate team legend only once from the initial full dataset
            if (!initialTeamLegendGenerated) {
                generateTeamLegend(preprocessedData);
                initialTeamLegendGenerated = true;
            }
            
            // Load group participants from storage and apply highlighting
            loadGroupParticipants();
            updateGroupHighlighting();
            
            // Re-validate group names now that data is available
            if (groupParticipants.size > 0) {
                validateGroupNames(Array.from(groupParticipants));
            }
            
            // Update group participants panel visibility
            updateGroupParticipantsVisibility();
            
            // Render will be handled by applyAllFilters after setTimeout
            
            // Apply saved sort preferences (without re-rendering, setTimeout will handle rendering)
            if (currentSortColumn) {
                applySortToData(false);
            }
            
            // Update status button text
            updateStatusButtonText();
            
            // Restore group toggle UI state
            updateGroupToggleUI();
            
            // Apply all saved filters (team + status + group)
            console.log('displayTableLayout: Scheduling applyAllFilters with setTimeout...');
            setTimeout(() => {
                console.log('displayTableLayout: setTimeout callback executing, calling applyAllFilters...');
                applyAllFilters();
            }, 100);
            
            // Show the card and initialize view
            tableCard.style.display = 'block';
            switchView(currentView);
        }
        
        // Helper function to get TopFields for current list
        function getCurrentTopFields() {
            const currentValue = document.getElementById('fileSelect')?.value;
            if (!currentValue) return null;
            
            const selectedOption = Array.from(document.getElementById('fileSelect').options).find(opt => opt.value === currentValue);
            const topFields = selectedOption?.getAttribute('data-top-fields');
            
            if (topFields) {
                console.log(' TopFields found for', currentValue, ':', topFields);
                return topFields.split(',').map(field => field.trim());
            }
            
            console.log(' No TopFields found for', currentValue, '- using default display');
            return null;
        }
        
        // Helper function to format field names for display
        function formatFieldName(fieldName) {
            if (!fieldName) return '';
            
            // Replace underscores with spaces and capitalize first letter of each word
            return fieldName
                .replace(/_/g, ' ')
                .replace(/\b\w/g, char => char.toUpperCase());
        }
        
        // Helper function to format URLs in display values
        function formatValueForDisplay(value) {
            if (!value || typeof value !== 'string') return value;
            
            // Check if the value starts with http:// or https://
            const urlMatch = value.match(/^(https?:\/\/[^\s"'<>]+)/i);
            if (urlMatch) {
                const fullUrl = urlMatch[0];
                // Truncate URL display text to 50 characters with ellipsis
                const displayText = value.length > 50 ? value.substring(0, 50) + '...' : value;
                return `<a href="${fullUrl}" target="_blank" rel="noopener noreferrer">${displayText}</a>`;
            }
            
            return value;
        }
        
        // Check if Rust server is available
        let rustServerAvailable = null;
        async function checkRustServer() {
            if (rustServerAvailable !== null) return rustServerAvailable;
            
            try {
                const response = await fetch('http://localhost:8081/api/health', {
                    method: 'GET',
                    timeout: 1000
                });
                rustServerAvailable = response.ok;
            } catch (error) {
                rustServerAvailable = false;
            }
            return rustServerAvailable;
        }
        
        // Helper function to generate site previews for URLs
        async function getSitePreview(url, targetDivId) {
            if (!url || !targetDivId) return;
            
            const targetDiv = document.getElementById(targetDivId);
            if (!targetDiv) return;
            
            try {
                // Always use iframe for bsky list regardless of Rust server status
                const hash = getHash ? getHash() : {};
                if (hash.list === 'bsky') {
                    const iframe = document.createElement('iframe');
                    iframe.src = `https://cors-anywhere.herokuapp.com/${url}`;
                    iframe.style.width = '100%';
                    iframe.style.height = '100px';
                    iframe.style.border = '1px solid #ccc';
                    iframe.style.borderRadius = '4px';
                    iframe.style.marginTop = '4px';
                    targetDiv.appendChild(iframe);
                    
                    // Add small label
                    const label = document.createElement('div');
                    label.style.fontSize = '9px';
                    label.style.color = '#999';
                    label.style.marginTop = '2px';
                    label.textContent = 'via cors-anywhere.herokuapp.com';
                    targetDiv.appendChild(label);
                    return; // Exit early for bsky
                }
                
                const isRustAvailable = await checkRustServer();
                
                if (isRustAvailable) {
                    // Use Rust server for scraping
                    const response = await fetch(`http://localhost:8081/api/scrape?url=${encodeURIComponent(url)}`);
                    if (response.ok) {
                        const data = await response.json();
                        
                        if (data.image) {
                            const img = document.createElement('img');
                            img.src = data.image;
                            img.style.width = '100%';
                            img.style.height = 'auto';
                            img.style.maxHeight = '120px';
                            img.style.objectFit = 'cover';
                            img.style.borderRadius = '4px';
                            img.onerror = () => img.remove();
                            targetDiv.appendChild(img);
                        }
                        
                        if (data.title) {
                            const titleDiv = document.createElement('div');
                            titleDiv.style.fontSize = '11px';
                            titleDiv.style.color = '#666';
                            titleDiv.style.marginTop = '4px';
                            titleDiv.style.overflow = 'hidden';
                            titleDiv.style.textOverflow = 'ellipsis';
                            titleDiv.style.whiteSpace = 'nowrap';
                            titleDiv.textContent = data.title.length > 30 ? 
                                data.title.substring(0, 30) + '...' : data.title;
                            targetDiv.appendChild(titleDiv);
                        }
                    }
                } else {
                    // Rust server not available - no fallback for non-bsky lists
                }
                
            } catch (error) {
                // Silently fail if preview generation fails
                console.debug('Preview generation failed:', error);
            }
        }
        
        // Helper function to determine which field is being used as the title
        function getTitleFieldName(participant, topFieldsFirstField = null) {
            if (!participant || typeof participant !== 'object') {
                return null;
            }
            
            // Check TopFields first field if provided
            if (topFieldsFirstField && participant[topFieldsFirstField] !== undefined && 
                participant[topFieldsFirstField] !== null && participant[topFieldsFirstField] !== '') {
                return topFieldsFirstField;
            }
            
            // Use same logic as getParticipantName to find which field is actually used
            const nameFields = ['Name', 'name', 'participant_name', 'full_name', 'display_name', 'displayName'];
            
            for (const field of nameFields) {
                if (participant[field] !== undefined && participant[field] !== null && participant[field] !== '') {
                    return field;
                }
            }
            
            return null;
        }
        
        // Helper function to create field display HTML for a participant
        function createFieldDisplayHTML(participant, topFields, isGallery = false, titleFieldName = null) {
            let fieldsToUse = topFields;
            
            // If TopFields is null, find best fields from the dataset with filtering
            if (!topFields || topFields.length === 0) {
                const dataKeys = Object.keys(participant || {});
                
                // Filter out unwanted fields
                const filteredKeys = dataKeys.filter(field => {
                    const fieldLower = field.toLowerCase();
                    
                    // Skip these specific field names (case insensitive)
                    if (['edit', 'index', 'preview', 'order'].includes(fieldLower)) {
                        return false;
                    }
                    
                    // Skip fields ending with _id or ID
                    if (fieldLower.endsWith('_id') || field.endsWith('ID')) {
                        return false;
                    }
                    
                    return true;
                });
                
                fieldsToUse = filteredKeys;
                console.log(' Using filtered dataset columns as TopFields source:', fieldsToUse);
            }
            
            if (!fieldsToUse || fieldsToUse.length === 0) {
                return ''; // No fields to display
            }
            
            let html = '';
            let fieldsDisplayed = 0;
            const maxTotalFields = 5; // Total fields including the name/title field
            const maxAdditionalFields = maxTotalFields - 1; // Subtract 1 for the name/title field
            
            // For TopFields mode, check if more than 5 fields are specified
            const isTopFieldsMode = topFields && topFields.length > 0;
            const actualMaxFields = isTopFieldsMode && topFields.length > maxTotalFields ? 
                topFields.length - 1 : maxAdditionalFields;
            
            // Find up to maxAdditionalFields unique fields with non-empty values (4 by default, unless TopFields has more than 5)
            for (let i = 0; i < fieldsToUse.length && fieldsDisplayed < actualMaxFields; i++) {
                const field = fieldsToUse[i];
                const value = participant[field];
                
                // Skip the field that's being used as the title
                if (titleFieldName && field === titleFieldName) {
                    continue;
                }
                
                // For TopFields mode, also skip the first field if no titleFieldName provided
                if (!titleFieldName && i === 0) {
                    continue;
                }
                
                // Skip fields with empty/blank values
                if (!value || value.toString().trim() === '') {
                    continue;
                }
                
                const isProjectsField = field.toLowerCase() === 'projects';
                const isLastField = fieldsDisplayed === (actualMaxFields - 1);
                
                // Add line break before Projects field if it's the last field
                //const lineBreak = (isLastField && isProjectsField) ? '<br>' : '';
                
                const formattedFieldName = formatFieldName(field);
                
                // Format URLs in the value
                const formattedValue = formatValueForDisplay(value);
                
                if (isGallery) {
                    // All fields (except first) get bold field name with colon
                    html += `<div class="gallery-info"><strong>${formattedFieldName}:</strong> ${formattedValue}</div>`;
                } else {
                    // All fields (except first) get bold field name with colon
                    if (isProjectsField) {
                        html += `<div class="columns-projects"><strong>${formattedFieldName}:</strong> ${formattedValue}</div>`;
                    } else if (field.toLowerCase() === 'status') {
                        html += `<div class="columns-info"><strong>${formattedFieldName}:</strong> <span class="columns-status">${formattedValue}</span></div>`;
                    } else {
                        html += `<div class="columns-info"><strong>${formattedFieldName}:</strong> ${formattedValue}</div>`;
                    }
                }
                
                fieldsDisplayed++;
            }
            return html;
        }

        // Render column view (default) - Using table-list style
        function renderColumnView(data) {
            const container = document.getElementById('participants-column-grid');
            container.innerHTML = '';
            
            // Check if data is valid
            if (!data || data.length === 0) {
                console.error('No data provided to renderColumnView');
                return;
            }
            
            const isMetaList = getHash().list === 'all';
            
            let imageCount = 0;
            data.forEach(participant => {
                if (!participant) return; // Skip null/undefined participants
                
                // Extract image paths from participant data
                const imagePaths = extractImagePaths(participant);
                
                // Only display first 12 items with images, or all items if no images found in any
                if (imagePaths.length > 0 && imageCount >= 12) return;
                if (imagePaths.length > 0) imageCount++;
                
                const card = document.createElement('div');
                card.className = 'columns-card';
                
                // Get TopFields for dynamic display
                const topFields = getCurrentTopFields();
                const firstTopField = topFields && topFields.length > 0 ? topFields[0] : null;
                
                const name = getParticipantName(participant, firstTopField);
                card.dataset.participantName = name;
                
                // Get the actual field name being used as title
                const titleFieldName = getTitleFieldName(participant, firstTopField);
                
                // Add clickable functionality for meta list
                if (isMetaList && participant.List) {
                    card.style.cursor = 'pointer';
                    card.title = `Click to view data from: ${participant.Title || participant.List}`;
                    card.addEventListener('click', () => {
                        setURLHashParam('list', participant.List);
                        updateParticipantListTitle(participant.Title || participant.List);
                    });
                }
                
                // Create image container if images are found
                const imageContainer = imagePaths.length > 0 ? createImageContainer(imagePaths, false) : '';
                
                // Generate field display HTML using TopFields or fallback
                const fieldDisplayHTML = createFieldDisplayHTML(participant, topFields, false, titleFieldName);
                
                card.innerHTML = `
                    <div class="columns-menu">
                        
                        <div class="columns-menu-dropdown">
                            <div class="columns-menu-item">
                                <a href="https://model.earth/projects/hub/#search=${encodeURIComponent(name)}" target="_blank">View Projects</a>
                            </div>
                        </div>
                    </div>
                    ${imageContainer}
                    <div class="columns-name">
                        <input type="checkbox" class="columns-checkbox" data-name="${name}">
                        ${name}
                    </div>
                    ${fieldDisplayHTML}
                `;
                
                container.appendChild(card);
                
                // Add checkbox event listener
                const checkbox = card.querySelector('.columns-checkbox');
                if (checkbox) {
                    checkbox.addEventListener('change', function() {
                        handleCheckboxChange(this.dataset.name, this.checked);
                    });
                }
                
                // Add 3-dot menu event listener
                const menu = card.querySelector('.columns-menu');
                if (menu) {
                    menu.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const dropdown = this.querySelector('.columns-menu-dropdown');
                        // Close other dropdowns
                        document.querySelectorAll('.columns-menu-dropdown').forEach(d => {
                            if (d !== dropdown) d.style.display = 'none';
                        });
                        // Toggle this dropdown
                        dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
                    });
                    
                    // Add event listener to menu items to close dropdown when clicked
                    const menuItems = menu.querySelectorAll('.columns-menu-item');
                    menuItems.forEach(item => {
                        item.addEventListener('click', function() {
                            const dropdown = menu.querySelector('.columns-menu-dropdown');
                            if (dropdown) {
                                dropdown.style.display = 'none';
                            }
                        });
                    });
                }
            });
            
            // Sync checkboxes after rendering cards
            setTimeout(syncCheckboxesWithGroup, 10);
        }
        
        // Handle checkbox changes
        function handleCheckboxChange(participantName, isChecked) {
            const groupField = document.getElementById('group');
            if (!groupField) return;
            
            let groupList = groupField.value.split(',').map(name => name.trim()).filter(name => name);
            
            if (isChecked) {
                // Add name if not already in the list
                if (!groupList.includes(participantName)) {
                    groupList.push(participantName);
                    groupParticipants.add(participantName);
                }
            } else {
                // Remove name from the list
                groupList = groupList.filter(name => name !== participantName);
                groupParticipants.delete(participantName);
            }
            
            groupField.value = groupList.join(', ');
            
            // Update the group count in the toggle button (same as processGroupInput)
            updateGroupCount();
            updateGroupHighlighting();
            
            // Save to storage (same as processGroupInput)
            saveGroupParticipants();
            // Note: URL hash parameters for groups have been discontinued
            
            // Auto-save to browser cache with date-based snapshot
            if (groupList.length > 0) {
                saveGroupToDateSnapshot(groupList);
            }
            
            // Apply filters if group filter is active (same as processGroupInput)
            if (showOnlyGroup) {
                applyAllFilters();
            }
            
            // Auto-save to current active snapshot if one is selected (same as processGroupInput)
            // Do this AFTER all other state updates to ensure getCurrentFilterState() gets the latest values
            if (currentActiveSnapshot) {
                saveSnapshot(currentActiveSnapshot);
                // Update the UI to reflect the snapshot is still active
                updateGroupSnapshotInfo();
            }
            
            // Trigger change event to update any other listeners
            groupField.dispatchEvent(new Event('change'));
        }
        
        // Save group to date-based snapshot for caching
        function saveGroupToDateSnapshot(groupList) {
            if (groupList.length === 0) return;
            
            // Create snapshot name with today's date
            const today = new Date();
            const months = ['January', 'February', 'March', 'April', 'May', 'June',
                          'July', 'August', 'September', 'October', 'November', 'December'];
            let snapshotName = `${months[today.getMonth()]} ${String(today.getDate()).padStart(2, '0')}, ${today.getFullYear()}`;
            
            // Check for duplicates and append incremental number if needed
            const snapshots = loadSnapshots();
            const originalName = snapshotName;
            let counter = 1;
            
            while (snapshots[snapshotName]) {
                counter++;
                snapshotName = `${originalName} (${counter})`;
            }
            
            // Save as a snapshot
            const filterState = getCurrentFilterState();
            filterState.groupParticipants = groupList;
            snapshots[snapshotName] = filterState;
            saveSnapshots(snapshots);
            
            // Set this snapshot as active
            currentActiveSnapshot = snapshotName;
            updateListTitle();
            
            console.log(` Auto-saved group selection to snapshot: ${snapshotName}`);
        }
        
        // Sync checkboxes based on group field (case insensitive)
        function syncCheckboxesWithGroup() {
            const groupField = document.getElementById('group');
            if (!groupField) return;
            
            const groupList = groupField.value.split(',').map(name => name.trim()).filter(name => name);
            const groupListLower = groupList.map(name => name.toLowerCase());
            const checkboxes = document.querySelectorAll('.columns-checkbox');
            
            checkboxes.forEach(checkbox => {
                const participantName = checkbox.dataset.name;
                const participantNameLower = participantName.toLowerCase();
                checkbox.checked = groupListLower.includes(participantNameLower);
            });
        }
        
        // Format group field names: capitalize first letter, lowercase rest, alphabetical order
        function formatGroupFieldNames() {
            const groupField = document.getElementById('group');
            if (!groupField) return;
            
            const names = groupField.value.split(',')
                .map(name => name.trim())
                .filter(name => name.length > 0)
                .map(name => {
                    // Capitalize first letter, lowercase the rest
                    return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
                })
                .sort(); // Alphabetical order
            
            groupField.value = names.join(', ');
            
            // Update group participants set and trigger related updates
            updateGroupCount();
            updateGroupHighlighting();
            saveGroupParticipants();
        }
        
        // Render table view
        function renderTableView(data) {
            const tableHeader = document.getElementById('table-header');
            const tableBody = document.getElementById('table-body');
            
            // Check if data is valid
            if (!data || data.length === 0) {
                console.error('No data provided to renderTableView');
                return;
            }
            
            // Get headers from first row
            const headers = Object.keys(data[0] || {});

            // Filter out columns that are empty for every row (omit empty columns) and unwanted columns
            const visibleHeaders = headers.filter(header => {
                // Skip Preview column
                if (header.toLowerCase() === 'preview') {
                    return false;
                }
                
                // If any row has a non-empty value for this header, keep it
                return data.some(row => {
                    if (!row) return false;
                    const v = row[header];
                    if (v === null || v === undefined) return false;
                    if (typeof v === 'string') return v.trim().length > 0;
                    // non-string values (numbers, booleans) count as present
                    return true;
                });
            });

            // Fallback to original headers if filtering removed everything
            const headersToRender = (visibleHeaders && visibleHeaders.length > 0) ? visibleHeaders : headers;
            
            // Create table header
            tableHeader.innerHTML = '';
            const headerRow = document.createElement('tr');
            
            headersToRender.forEach(header => {
                const th = document.createElement('th');
                th.style.cursor = 'pointer';
                th.style.userSelect = 'none';
                th.style.position = 'relative';
                
                // Add click handler for sorting
                th.addEventListener('click', () => sortBy(header));
                
                // Add header text and sort arrow
                const headerText = document.createElement('span');
                headerText.textContent = formatFieldName(header);
                th.appendChild(headerText);
                
                // Add sort arrow if this is the current sort column
                if (currentSortColumn === header) {
                    const arrow = document.createElement('span');
                    arrow.innerHTML = currentSortOrder === 'asc' ? ' ' : ' ';
                    arrow.style.marginLeft = '4px';
                    arrow.style.fontSize = '12px';
                    th.appendChild(arrow);
                }
                
                headerRow.appendChild(th);
            });
            
            // Add checkbox column header at the beginning
            const checkboxTh = document.createElement('th');
            checkboxTh.style.width = '40px';
            checkboxTh.style.textAlign = 'center';
            headerRow.insertBefore(checkboxTh, headerRow.firstChild);

            // Preview column removed
            
            // Add menu column header at the end
            const menuTh = document.createElement('th');
            menuTh.style.width = '50px';
            menuTh.style.textAlign = 'center';
            headerRow.appendChild(menuTh);
            
            tableHeader.appendChild(headerRow);
            
            // Create table body
            tableBody.innerHTML = '';
            const isMetaList = getHash().list === 'all';
            
            data.forEach(row => {
                if (!row) return; // Skip null/undefined rows
                const tr = document.createElement('tr');
                tr.dataset.participantName = getParticipantName(row);

                // No row-level href navigation: links will be created only for @mentions and https:// URLs inside cells
                
                // Add row-level click handling variables
                let mouseDownTime = 0;
                let mouseDownPos = { x: 0, y: 0 };
                let savedSelectionOnMouseDown = null;
                
                // Track mouse down on the row to detect selection attempts and capture selection
                tr.addEventListener('mousedown', (e) => {
                    mouseDownTime = Date.now();
                    mouseDownPos = { x: e.clientX, y: e.clientY };
                    
                    // Capture any existing selection immediately on mousedown
                    const selection = window.getSelection();
                    if (selection.rangeCount > 0 && selection.toString().length > 0) {
                        savedSelectionOnMouseDown = selection.getRangeAt(0).cloneRange();
                    } else {
                        savedSelectionOnMouseDown = null;
                    }
                });
                
                // Add row-level click event to toggle expanded state
                tr.addEventListener('click', (e) => {
                    // Handle meta list navigation first
                    if (isMetaList && row.List) {
                        const clickTime = Date.now();
                        const timeDiff = clickTime - mouseDownTime;
                        const distance = Math.sqrt(
                            Math.pow(e.clientX - mouseDownPos.x, 2) + 
                            Math.pow(e.clientY - mouseDownPos.y, 2)
                        );
                        
                        // Only navigate if it's a quick click (not text selection)
                        if (timeDiff <= 200 && distance <= 5) {
                            setURLHashParam('list', row.List);
                            updateParticipantListTitle(row.Title || row.List);
                            return;
                        }
                    }
                    
                    const clickTime = Date.now();
                    const timeDiff = clickTime - mouseDownTime;
                    const distance = Math.sqrt(
                        Math.pow(e.clientX - mouseDownPos.x, 2) + 
                        Math.pow(e.clientY - mouseDownPos.y, 2)
                    );
                    
                    // Don't toggle if this appears to be the end of a text selection
                    // (long press or mouse movement suggests selection intent)
                    if (timeDiff > 200 || distance > 5) {
                        return;
                    }

                    // No row-level navigation here; anchors inside cells handle navigation.
                    
                    // Toggle expanded class for all cells in this row
                    const allCellsInRow = tr.querySelectorAll('td');
                    allCellsInRow.forEach(cell => {
                        cell.classList.toggle('expanded');
                    });
                    
                    // Restore selection that was captured on mousedown
                    if (savedSelectionOnMouseDown) {
                        const selection = window.getSelection();
                        setTimeout(() => {
                            selection.removeAllRanges();
                            selection.addRange(savedSelectionOnMouseDown);
                        }, 0);
                    }
                });
                
                // Add clickable functionality for meta list
                if (isMetaList && row.List) {
                    tr.style.cursor = 'pointer';
                    tr.title = `Click to view data from: ${row.Title || row.List}`;
                }
                
                // Add checkbox column first
                const checkboxTd = document.createElement('td');
                checkboxTd.style.textAlign = 'center';
                checkboxTd.style.verticalAlign = 'middle';
                checkboxTd.style.padding = '8px';
                checkboxTd.style.position = 'relative';
                
                const name = getParticipantName(row);
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'columns-checkbox';
                checkbox.dataset.name = name;
                checkbox.style.width = '18px';
                checkbox.style.height = '18px';
                checkbox.style.cursor = 'pointer';
                checkbox.style.margin = '0';
                checkbox.style.display = 'inline-block';
                checkbox.style.position = 'relative';
                checkbox.style.zIndex = '10';
                
                // Add event listener with capture phase to occur before row click
                checkbox.addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevent row click
                    e.stopImmediatePropagation(); // Stop all other event handlers
                }, true);
                
                checkbox.addEventListener('change', function(e) {
                    e.stopPropagation(); // Prevent row click
                    handleCheckboxChange(this.dataset.name, this.checked);
                });
                
                // Prevent row click when clicking anywhere in the checkbox cell
                checkboxTd.addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevent row click
                    e.stopImmediatePropagation(); // Stop all other event handlers
                });
                
                checkboxTd.appendChild(checkbox);
                tr.appendChild(checkboxTd);

                // Preview column removed
                
                // Add data columns
                headersToRender.forEach(header => {
                    const td = document.createElement('td');
                    const rawVal = row[header] || '';

                    // If the value already contains an anchor tag, render it as HTML
                    if (typeof rawVal === 'string' && /<a\s+href=/i.test(rawVal)) {
                        td.innerHTML = rawVal;
                        // If there are anchors inside, prevent their clicks from bubbling to the row
                        td.querySelectorAll('a').forEach(a => {
                            a.addEventListener('click', (e) => {
                                e.stopPropagation();
                            });
                        });
                    } else if (typeof rawVal === 'string') {
                        // Tokenize the string and only convert @mentions and https:// URLs into anchors
                        const tokens = rawVal.split(/(\s+)/); // keep whitespace tokens
                        tokens.forEach(token => {
                            if (!token) return;
                            // URL starting with https:// or http://
                            const urlMatch = token.match(/^(https?:\/\/[^\s"'<>]+)/i);
                            const atMatch = token.match(/^@([a-zA-Z0-9_\-\.]+)/);

                            if (urlMatch) {
                                const a = document.createElement('a');
                                a.href = urlMatch[0];
                                // Truncate URL display text to 50 characters with ellipsis
                                const displayText = token.length > 50 ? token.substring(0, 50) + '...' : token;
                                a.textContent = displayText;
                                a.target = '_blank';
                                a.rel = 'noopener noreferrer';
                                a.addEventListener('click', (e) => e.stopPropagation());
                                td.appendChild(a);
                                
                                // Add preview for URLs in Name/Title column
                                if (header.toLowerCase() === 'name' || header.toLowerCase() === 'title') {
                                    const previewId = 'preview_' + Math.random().toString(36).substr(2, 9);
                                    const previewDiv = document.createElement('div');
                                    previewDiv.id = previewId;
                                    previewDiv.style.marginTop = '6px';
                                    previewDiv.style.maxWidth = '160px';
                                    td.appendChild(previewDiv);
                                    
                                    // Generate preview if getSitePreview function exists
                                    if (typeof getSitePreview === 'function') {
                                        try {
                                            getSitePreview(urlMatch[0], previewId);
                                        } catch (err) {
                                            // ignore preview errors
                                        }
                                    }
                                }
                            } else if (atMatch) {
                                const handle = atMatch[1];
                                const a = document.createElement('a');
                                // Link @handles to a search or profile page if desired; for now, link to bsky profile pattern
                                a.href = `https://bsky.app/profile/${encodeURIComponent(handle)}`;
                                a.textContent = token;
                                a.target = '_blank';
                                a.rel = 'noopener noreferrer';
                                a.addEventListener('click', (e) => e.stopPropagation());
                                td.appendChild(a);
                            } else {
                                // Regular text (including whitespace)
                                td.appendChild(document.createTextNode(token));
                            }
                        });
                    } else {
                        // Non-string values (numbers, null, etc.)
                        td.textContent = rawVal;
                    }

                    tr.appendChild(td);
                });
                
                // Preview population code removed

                // Add menu column last (using same approach as column/gallery views)
                const menuTd = document.createElement('td');
                menuTd.style.textAlign = 'center';
                menuTd.style.verticalAlign = 'middle';
                menuTd.style.padding = '8px 12px';
                menuTd.style.position = 'relative';
                menuTd.style.width = '50px';
                menuTd.style.minWidth = '50px';
                menuTd.style.zIndex = '100';
                
                menuTd.innerHTML = `
                    <div class="columns-menu">
                        
                        <div class="columns-menu-dropdown">
                            <div class="columns-menu-item">
                                <a href="https://model.earth/projects/hub/#search=${encodeURIComponent(name)}" target="_blank">View Projects</a>
                            </div>
                        </div>
                    </div>
                `;
                
                // Add the same 3-dot menu event listener as column/gallery views
                const menu = menuTd.querySelector('.columns-menu');
                if (menu) {
                    menu.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const dropdown = this.querySelector('.columns-menu-dropdown');
                        // Close other dropdowns
                        document.querySelectorAll('.columns-menu-dropdown').forEach(d => {
                            if (d !== dropdown) d.style.display = 'none';
                        });
                        // Toggle this dropdown
                        dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
                    });
                    
                    // Add event listener to menu items to close dropdown when clicked
                    const menuItems = menu.querySelectorAll('.columns-menu-item');
                    menuItems.forEach(item => {
                        item.addEventListener('click', function() {
                            const dropdown = menu.querySelector('.columns-menu-dropdown');
                            if (dropdown) {
                                dropdown.style.display = 'none';
                            }
                        });
                    });
                }
                
                tr.appendChild(menuTd);
                
                tableBody.appendChild(tr);
            });
            
            // Sync checkboxes after rendering table
            setTimeout(syncCheckboxesWithGroup, 10);
            
        }
        
        // Get team class based on team value (checks all teams in comma-separated list)
        function getTeamClass(teamString) {
            if (!teamString) return 'team-default';
            
            // Split by comma and check each team
            const teams = teamString.split(',').map(team => team.trim().toLowerCase());
            
            // Check for team keywords in order of priority
            for (const team of teams) {
                if (team.includes('js')) return 'team-js';
                if (team.includes('ml')) return 'team-ml';
                if (team.includes('react')) return 'team-react';
                if (team.includes('io')) return 'team-io';
                if (team.includes('ai')) return 'team-ai';
                if (team.includes('flask')) return 'team-flask';
                if (team.includes('suite')) return 'team-suite';
                if (team.includes('us')) return 'team-us';
                if (team.includes('auth')) return 'team-auth';
                if (team.includes('discord')) return 'team-discord';
            }
            
            return 'team-default';
        }
        
        // Get all matching team classes for a participant (for filtering)
        function getAllTeamClasses(teamString) {
            console.log('getAllTeamClasses called with:', teamString);
            if (!teamString) {
                console.log('No team string provided, using default');
                return ['team-default'];
            }
            
            const matchingTeams = [];
            const teams = teamString.split(',').map(team => team.trim().toLowerCase());
            console.log('Teams after processing:', teams);
            
            // Check each team and collect all matches
            for (const team of teams) {
                if (team.includes('js')) matchingTeams.push('team-js');
                else if (team.includes('ml')) matchingTeams.push('team-ml');
                else if (team.includes('react')) matchingTeams.push('team-react');
                else if (team.includes('io')) matchingTeams.push('team-io');
                else if (team.includes('ai')) matchingTeams.push('team-ai');
                else if (team.includes('flask')) matchingTeams.push('team-flask');
                else if (team.includes('suite')) matchingTeams.push('team-suite');
                else if (team.includes('us')) matchingTeams.push('team-us');
                else if (team.includes('auth')) matchingTeams.push('team-auth');
                else if (team.includes('discord')) matchingTeams.push('team-discord');
            }
            
            const result = matchingTeams.length > 0 ? matchingTeams : ['team-default'];
            console.log('Team detection result:', result);
            return result;
        }
        
        // Generate team legend
        function generateTeamLegend(data) {
            console.log('generateTeamLegend called with data:', data.length, 'items');
            const teamLegend = document.getElementById('team-legend');
            const legendItems = document.getElementById('legend-items');
            
            // Check if data is valid
            if (!data || data.length === 0) {
                console.log('No data provided, hiding team legend');
                teamLegend.style.display = 'none';
                return;
            }
            
            // Check if Team column exists in the data
            const hasTeamColumn = data.length > 0 && data[0].hasOwnProperty('Team');
            if (!hasTeamColumn) {
                console.log('No Team column found in data, hiding team legend');
                teamLegend.style.display = 'none';
                return;
            }
            
            // Get unique teams from data (collect all team classes for each participant)
            const teams = new Set();
            data.forEach((participant, index) => {
                if (!participant) return; // Skip null/undefined participants
                console.log(`Participant ${index} - Team field:`, participant.Team);
                const teamClasses = getAllTeamClasses(participant.Team);
                teamClasses.forEach(teamClass => teams.add(teamClass));
            });
            
            console.log('Unique teams found:', Array.from(teams));
            
            // Create legend items
            legendItems.innerHTML = '';
            
            // Add "Show All" button as first item (active by default)
            const showAllItem = document.createElement('div');
            showAllItem.className = 'legend-item active';
            showAllItem.id = 'clear-team-filter';
            showAllItem.innerHTML = `
                <div class="legend-color" style="background: #ddd;"></div>
                <span>Show All</span>
            `;
            showAllItem.addEventListener('click', clearTeamFilter);
            legendItems.appendChild(showAllItem);
            
            // Add team filter buttons
            console.log('Creating team filter buttons for teams:', Array.from(teams));
            teams.forEach(teamClass => {
                const teamInfo = Object.values(teamColors).find(t => t.class === teamClass) || teamColors.default;
                console.log(`Creating filter for team: ${teamClass}, info:`, teamInfo);
                
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                legendItem.dataset.team = teamClass;
                legendItem.innerHTML = `
                    <div class="legend-color" style="background: ${teamInfo.color};"></div>
                    <span>${teamInfo.name}</span>
                `;
                
                legendItem.addEventListener('click', () => filterByTeam(teamClass));
                legendItems.appendChild(legendItem);
                console.log('Added team filter button:', teamInfo.name);
            });
            
            // Always show team legend if teams are detected (even if only one team)
            teamLegend.style.display = teams.size > 0 ? 'block' : 'none';
            
            // Restore team filter highlighting from storage
            restoreTeamFilterHighlighting();
        }
        
        // Restore team filter highlighting when recalled from browser storage
        function restoreTeamFilterHighlighting() {
            if (currentTeamFilter) {
                console.log('Restoring team filter highlighting for:', currentTeamFilter);
                
                // Clear all active states first
                document.querySelectorAll('.legend-item').forEach(item => {
                    item.classList.remove('active');
                });
                
                // Find and highlight the matching team legend item
                const matchingItem = document.querySelector(`.legend-item[data-team="${currentTeamFilter}"]`);
                if (matchingItem) {
                    matchingItem.classList.add('active');
                    console.log('Team filter highlighting restored for:', currentTeamFilter);
                } else {
                    console.log('No matching legend item found for team filter:', currentTeamFilter);
                }
            } else {
                // No team filter active, highlight "Show All"
                document.querySelectorAll('.legend-item').forEach(item => {
                    item.classList.remove('active');
                });
                const showAllItem = document.getElementById('clear-team-filter');
                if (showAllItem) {
                    showAllItem.classList.add('active');
                }
            }
        }
        
        // Filter by team
        function filterByTeam(teamClass) {
            // If clicking on the already selected team, clear the filter
            if (currentTeamFilter === teamClass) {
                clearTeamFilter();
                return;
            }
            
            currentTeamFilter = teamClass;
            
            // Clear active snapshot since filters changed manually
            clearActiveSnapshot();
            
            // Save team filter preference to localStorage
            localStorage.setItem(getListStorageKey('participantsTeamFilter'), teamClass);
            
            // Update legend active state
            document.querySelectorAll('.legend-item').forEach(item => {
                item.classList.toggle('active', item.dataset.team === teamClass);
            });
            
            // Remove active state from "Show All" button
            const showAllButton = document.getElementById('clear-team-filter');
            if (showAllButton) {
                showAllButton.classList.remove('active');
            }
            
            // Apply all filters (team + status)
            applyAllFilters();
        }
        
        // Clear team filter
        function clearTeamFilter() {
            currentTeamFilter = null;
            
            // Clear active snapshot since filters changed manually
            clearActiveSnapshot();
            
            // Remove team filter preference from localStorage
            localStorage.removeItem(getListStorageKey('participantsTeamFilter'));
            
            // Update legend active state
            document.querySelectorAll('.legend-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Make "Show All" button active
            const showAllButton = document.getElementById('clear-team-filter');
            if (showAllButton) {
                showAllButton.classList.add('active');
            }
            
            // Apply all filters (status only now)
            applyAllFilters();
        }
        
        // Render gallery view
        function renderGalleryView(data) {
            renderGalleryCards(data);
        }
        
        // Render gallery cards
        function renderGalleryCards(data) {
            const container = document.getElementById('participants-gallery-grid');
            container.innerHTML = '';
            
            // Check if data is valid
            if (!data || data.length === 0) {
                console.error('No data provided to renderGalleryCards');
                return;
            }
            
            const isMetaList = getHash().list === 'all';
            
            let imageCount = 0;
            data.forEach(participant => {
                if (!participant) return; // Skip null/undefined participants
                
                // Extract image paths from participant data
                const imagePaths = extractImagePaths(participant);
                
                // Only display first 12 items with images, or all items if no images found in any
                if (imagePaths.length > 0 && imageCount >= 12) return;
                if (imagePaths.length > 0) imageCount++;
                
                const card = document.createElement('div');
                const teamClass = getTeamClass(participant.Team);
                card.className = `gallery-card ${teamClass}`;
                
                // Get TopFields for dynamic display
                const topFields = getCurrentTopFields();
                const firstTopField = topFields && topFields.length > 0 ? topFields[0] : null;
                
                const name = getParticipantName(participant, firstTopField);
                card.dataset.participantName = name;
                
                // Get the actual field name being used as title
                const titleFieldName = getTitleFieldName(participant, firstTopField);
                
                // Add clickable functionality for meta list
                if (isMetaList && participant.List) {
                    card.style.cursor = 'pointer';
                    card.title = `Click to view data from: ${participant.Title || participant.List}`;
                    card.addEventListener('click', () => {
                        setURLHashParam('list', participant.List);
                        updateParticipantListTitle(participant.Title || participant.List);
                    });
                }
                
                // Set background image if available
                if (imagePaths.length > 0) {
                    card.style.backgroundImage = `url(${imagePaths[0]})`;
                    card.style.backgroundSize = 'cover';
                    card.style.backgroundPosition = 'center';
                    card.style.backgroundRepeat = 'no-repeat';
                    card.classList.add('has-background-image');
                }
                
                // Generate field display HTML using TopFields or fallback
                const fieldDisplayHTML = createFieldDisplayHTML(participant, topFields, true, titleFieldName);
                
                card.innerHTML = `
                    <div class="columns-menu">
                        
                        <div class="columns-menu-dropdown">
                            <div class="columns-menu-item">
                                <a href="https://model.earth/projects/hub/#search=${encodeURIComponent(name)}" target="_blank">View Projects</a>
                            </div>
                        </div>
                    </div>
                    <div class="gallery-content">
                        <div class="gallery-name">
                            <input type="checkbox" class="columns-checkbox" data-name="${name}">
                            ${name}
                        </div>
                        ${fieldDisplayHTML}
                    </div>
                    <button class="gallery-toggle-btn" onclick="toggleGalleryTextMode(this.parentElement)" title="Show info">
                        <i data-feather="info" style="width: 20px; height: 20px; stroke-width: 2.5px;"></i>
                    </button>
                `;
                
                container.appendChild(card);
                
                // Add checkbox event listener
                const checkbox = card.querySelector('.columns-checkbox');
                if (checkbox) {
                    checkbox.addEventListener('change', function(e) {
                        e.stopPropagation(); // Prevent card click
                        handleCheckboxChange(this.dataset.name, this.checked);
                    });
                }
                
                // Add 3-dot menu event listener
                const menu = card.querySelector('.columns-menu');
                if (menu) {
                    menu.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const dropdown = this.querySelector('.columns-menu-dropdown');
                        // Close other dropdowns
                        document.querySelectorAll('.columns-menu-dropdown').forEach(d => {
                            if (d !== dropdown) d.style.display = 'none';
                        });
                        // Toggle this dropdown
                        dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
                    });
                    
                    // Add event listener to menu items to close dropdown when clicked
                    const menuItems = menu.querySelectorAll('.columns-menu-item');
                    menuItems.forEach(item => {
                        item.addEventListener('click', function() {
                            const dropdown = menu.querySelector('.columns-menu-dropdown');
                            if (dropdown) {
                                dropdown.style.display = 'none';
                            }
                        });
                    });
                }
            });
            
            // Sync checkboxes after rendering gallery
            setTimeout(syncCheckboxesWithGroup, 10);
            
            // Feather icons will be initialized by nav.js
        }
        
        // Sort functionality
        function generateSortDropdown() {
            const sortItems = document.getElementById('sort-items');
            if (!allRowsData || !allRowsData.length) {
                // Show helpful message when no data is available
                sortItems.innerHTML = '<div class="no-data-message" style="padding: 10px; text-align: center; color: #666; font-style: italic;">Data is loading, please wait...</div>';
                return;
            }
            
            // Get available columns from data
            const columns = Object.keys(allRowsData[0]);
            
            // Add "Rows" as first option (original order)
            const sortOptions = ['Rows', ...columns];
            
            sortItems.innerHTML = '';
            sortOptions.forEach(column => {
                const sortItem = document.createElement('div');
                sortItem.className = 'sort-item';
                sortItem.dataset.column = column;
                
                const isActive = currentSortColumn === column;
                if (isActive) {
                    sortItem.classList.add('active');
                }
                
                const arrow = currentSortOrder === 'asc' ? '' : '';
                sortItem.innerHTML = `
                    <span>${column}</span>
                    <span class="sort-arrow">${isActive ? arrow : ''}</span>
                `;
                
                sortItem.addEventListener('click', () => sortBy(column));
                sortItems.appendChild(sortItem);
            });
        }
        
        function sortBy(column) {
            // If clicking the same column, toggle order
            if (currentSortColumn === column) {
                currentSortOrder = currentSortOrder === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortColumn = column;
                currentSortOrder = 'asc';
            }
            
            // Clear active snapshot since sort changed manually
            clearActiveSnapshot();
            
            // Save sort preferences
            localStorage.setItem(getListStorageKey('participantsSortColumn'), currentSortColumn);
            localStorage.setItem(getListStorageKey('participantsSortOrder'), currentSortOrder);
            
            // Note: sortby and sortorder are no longer automatically added to URL hash
            // They are only included in the "Full URL" feature
            
            // Apply sort to data
            applySortToData();
            
            // Update dropdown display
            generateSortDropdown();
            
            // Hide dropdown
            document.getElementById('sort-dropdown').style.display = 'none';
        }
        
        function applySortToData(shouldRerender = true) {
            let sortedData = [...allRowsData];
            
            if (currentSortColumn === 'Rows') {
                // Sort by original row order
                if (currentSortOrder === 'desc') {
                    sortedData.reverse();
                } else {
                    sortedData = [...originalDataOrder];
                }
            } else {
                // Sort by column data
                sortedData.sort((a, b) => {
                    let valueA = a[currentSortColumn] || '';
                    let valueB = b[currentSortColumn] || '';
                    
                    // Convert to string for comparison
                    valueA = valueA.toString().toLowerCase();
                    valueB = valueB.toString().toLowerCase();
                    
                    if (currentSortOrder === 'asc') {
                        return valueA.localeCompare(valueB);
                    } else {
                        return valueB.localeCompare(valueA);
                    }
                });
            }
            
            // Update global data
            allRowsData = sortedData;
            
            // Re-render all views with current filters applied (only if requested)
            if (shouldRerender) {
                applyAllFilters();
            }
        }
        
        function toggleSortDropdown() {
            const dropdown = document.getElementById('sort-dropdown');
            const statusDropdown = document.getElementById('status-dropdown');
            const isVisible = dropdown.style.display === 'block';
            
            // Close status dropdown first
            statusDropdown.style.display = 'none';
            
            if (isVisible) {
                dropdown.style.display = 'none';
            } else {
                generateSortDropdown();
                dropdown.style.display = 'block';
            }
        }
        
        // Status filtering functionality
        function generateStatusDropdown() {
            const statusItems = document.getElementById('status-items');
            if (!allRowsData || !allRowsData.length) {
                // Show helpful message when no data is available
                statusItems.innerHTML = '<div class="no-data-message" style="padding: 10px; text-align: center; color: #666; font-style: italic;">Data is loading, please wait...</div>';
                return;
            }
            
            // Get unique status values from data
            const statuses = new Set();
            allRowsData.forEach(participant => {
                const status = participant.Status || 'Unknown';
                statuses.add(status);
            });
            
            availableStatuses = ['All', ...Array.from(statuses).sort()];
            
            statusItems.innerHTML = '';
            availableStatuses.forEach(status => {
                const statusItem = document.createElement('div');
                statusItem.className = 'status-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'status-checkbox';
                checkbox.checked = selectedStatuses.has(status);
                checkbox.id = `status-${status}`;
                
                const label = document.createElement('label');
                label.className = 'status-label';
                label.htmlFor = `status-${status}`;
                label.textContent = status;
                
                statusItem.appendChild(checkbox);
                statusItem.appendChild(label);
                
                // Add checkbox change handler
                checkbox.addEventListener('change', (e) => {
                    handleStatusChange(status, e.target.checked);
                });
                
                // Add click handler for the label only
                label.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    checkbox.checked = !checkbox.checked;
                    handleStatusChange(status, checkbox.checked);
                });
                
                statusItems.appendChild(statusItem);
            });
        }
        
        function handleStatusChange(status, isChecked) {
            // Clear active snapshot since filters changed manually
            clearActiveSnapshot();
            
            // Set flag to prevent group parameter processing during status update
            isUpdatingStatus = true;
            
            if (status === 'All') {
                if (isChecked) {
                    // Check all statuses
                    selectedStatuses.clear();
                    selectedStatuses.add('All');
                    // Update all checkboxes
                    document.querySelectorAll('.status-checkbox').forEach(cb => {
                        cb.checked = cb.id === 'status-All';
                    });
                }
            } else {
                if (isChecked) {
                    // Uncheck "All" and add specific status
                    selectedStatuses.delete('All');
                    selectedStatuses.add(status);
                    document.getElementById('status-All').checked = false;
                } else {
                    // Remove specific status
                    selectedStatuses.delete(status);
                    
                    // If no specific statuses selected, check "All"
                    if (selectedStatuses.size === 0) {
                        selectedStatuses.add('All');
                        document.getElementById('status-All').checked = true;
                    }
                }
            }
            
            // Save to localStorage
            localStorage.setItem(getListStorageKey('participantsStatusFilter'), JSON.stringify(Array.from(selectedStatuses)));
            
            // Update URL hash parameter
            const statusArray = Array.from(selectedStatuses);
            if (statusArray.includes('All') || statusArray.length === 0) {
                // Remove hash parameter for default "All" status
                setURLHashParam('status', null);
            } else {
                setURLHashParam('status', statusArray.join(','));
            }
            
            // Update button text
            updateStatusButtonText();
            
            // Apply filters
            applyAllFilters();
            
            // Clear the flag after a short delay to allow hash changes to settle
            setTimeout(() => {
                isUpdatingStatus = false;
            }, 100);
        }
        
        function updateStatusButtonText() {
            const button = document.getElementById('status-toggle');
            const statusArray = Array.from(selectedStatuses);
            
            if (statusArray.includes('All') || statusArray.length === 0) {
                button.textContent = 'Status';
            } else if (statusArray.length === 1) {
                button.textContent = statusArray[0] + ' Only';
            } else {
                button.textContent = statusArray[0] + '...';
            }
        }
        
        function toggleStatusDropdown() {
            const dropdown = document.getElementById('status-dropdown');
            const sortDropdown = document.getElementById('sort-dropdown');
            const isVisible = dropdown.style.display === 'block';
            
            // Close sort dropdown first
            sortDropdown.style.display = 'none';
            
            if (isVisible) {
                dropdown.style.display = 'none';
            } else {
                generateStatusDropdown();
                dropdown.style.display = 'block';
            }
        }
        
        function applyAllFilters() {
            console.log(' applyAllFilters called');
            console.log(' allRowsData:', allRowsData);
            console.log(' allRowsData length:', allRowsData ? allRowsData.length : 'undefined');
            
            if (!allRowsData || allRowsData.length === 0) {
                console.warn(' applyAllFilters called but allRowsData is empty or undefined');
                console.log(' Current state - selectedStatuses:', selectedStatuses);
                console.log(' Current state - currentTeamFilter:', currentTeamFilter);
                console.log(' Current state - showOnlyGroup:', showOnlyGroup);
                return;
            }
            
            console.log(' Starting filter process with', allRowsData.length, 'participants');
            let filteredData = [...allRowsData];
            console.log(' Initial filteredData length:', filteredData.length);
            
            // Apply group participants filter first if active
            // This ensures team filtering can work on the group subset
            if (showOnlyGroup) {
                console.log(' Applying group participants filter. Group participants:', Array.from(groupParticipants));
                const beforeGroupFilter = filteredData.length;
                filteredData = filteredData.filter(participant => {
                    const name = getParticipantName(participant);
                    const passes = Array.from(groupParticipants).some(groupName => 
                        groupName.toLowerCase() === name.toLowerCase()
                    );
                    if (!passes) {
                        console.log(' Participant filtered out by group status:', name);
                    }
                    return passes;
                });
                console.log(' Group filter result:', beforeGroupFilter, '', filteredData.length);
            } else {
                console.log(' Skipping group participants filter (not active)');
            }
            
            // Apply team filter if active (works on group-filtered results if group filter is active)
            if (currentTeamFilter) {
                console.log(' Applying team filter:', currentTeamFilter);
                console.log(` Team filtering ${showOnlyGroup ? 'within group participants' : 'all participants'}`);
                const beforeTeamFilter = filteredData.length;
                filteredData = filteredData.filter(participant => {
                    const participantTeamClasses = getAllTeamClasses(participant.Team);
                    const passes = participantTeamClasses.includes(currentTeamFilter);
                    if (!passes) {
                        console.log(' Participant filtered out by team:', participant.Name || participant.name, 'Team:', participant.Team, 'Classes:', participantTeamClasses);
                    }
                    return passes;
                });
                console.log(' Team filter result:', beforeTeamFilter, '', filteredData.length);
            } else {
                console.log(' Skipping team filter (no team selected)');
            }
            
            // Apply status filter last
            if (!selectedStatuses.has('All') && selectedStatuses.size > 0) {
                console.log(' Applying status filter. Selected statuses:', Array.from(selectedStatuses));
                const beforeStatusFilter = filteredData.length;
                filteredData = filteredData.filter(participant => {
                    const status = participant.Status || 'Unknown';
                    const passes = selectedStatuses.has(status);
                    if (!passes) {
                        console.log(' Participant filtered out by status:', participant.Name || participant.name, 'Status:', status);
                    }
                    return passes;
                });
                console.log(' Status filter result:', beforeStatusFilter, '', filteredData.length);
            } else {
                console.log(' Skipping status filter (All selected or no selection)');
            }
            
            // Update email list based on filtered data
            if (window.allExtractedEmails && window.allExtractedEmails.length > 0) {
                console.log(' Updating email list based on filtered data...');
                updateFilteredEmails(filteredData);
            }
            
            // Update results count with pagination
            console.log(' Updating results count with pagination...');
            updateResultsCount(filteredData);
            
            // Apply pagination to filtered data
            const paginatedData = paginateData(filteredData);
            console.log(` Displaying page ${currentPage} with ${paginatedData.length} records`);
            
            // Render paginated data in all views
            console.log(' Starting render process with', paginatedData.length, 'paginated participants');
            console.log(' Sample of paginated data:', paginatedData.slice(0, 3));
            
            try {
                console.log(' Rendering column view...');
                renderColumnView(paginatedData);
                console.log(' Column view rendered successfully');
            } catch (error) {
                console.error(' Error rendering column view:', error);
                console.error('Stack trace:', error.stack);
                
                // Enhanced error reporting for call stack issues
                if (error.message && error.message.includes('Maximum call stack size exceeded')) {
                    const stackTrace = error.stack || '';
                    const stackLines = stackTrace.split('\n').filter(line => line.trim().length > 0);
                    const stackDepth = stackLines.length;
                    
                    let memoryInfo = '';
                    if (performance && performance.memory) {
                        const memory = performance.memory;
                        const usedMB = Math.round(memory.usedJSHeapSize / 1024 / 1024);
                        const totalMB = Math.round(memory.totalJSHeapSize / 1024 / 1024);
                        const limitMB = Math.round(memory.jsHeapSizeLimit / 1024 / 1024);
                        memoryInfo = ` Memory: ${usedMB}MB used, ${totalMB}MB total, ${limitMB}MB limit.`;
                    }
                    
                    console.error(' Column view call stack overflow - Stack depth:', stackDepth, 'frames.', memoryInfo);
                    appendStatusMessage(`<h4>Column View Error</h4><p>Maximum call stack size exceeded. Stack depth: ~${stackDepth} frames.${memoryInfo}</p>`, 'error');
                }
            }
            
            try {
                console.log(' Rendering table view...');
                renderTableView(paginatedData);
                console.log(' Table view rendered successfully');
            } catch (error) {
                console.error(' Error rendering table view:', error);
                console.error('Stack trace:', error.stack);
                
                // Enhanced error reporting for call stack issues
                if (error.message && error.message.includes('Maximum call stack size exceeded')) {
                    const stackTrace = error.stack || '';
                    const stackLines = stackTrace.split('\n').filter(line => line.trim().length > 0);
                    const stackDepth = stackLines.length;
                    
                    let memoryInfo = '';
                    if (performance && performance.memory) {
                        const memory = performance.memory;
                        const usedMB = Math.round(memory.usedJSHeapSize / 1024 / 1024);
                        const totalMB = Math.round(memory.totalJSHeapSize / 1024 / 1024);
                        const limitMB = Math.round(memory.jsHeapSizeLimit / 1024 / 1024);
                        memoryInfo = ` Memory: ${usedMB}MB used, ${totalMB}MB total, ${limitMB}MB limit.`;
                    }
                    
                    console.error(' Table view call stack overflow - Stack depth:', stackDepth, 'frames.', memoryInfo);
                    appendStatusMessage(`<h4>Table View Error</h4><p>Maximum call stack size exceeded. Stack depth: ~${stackDepth} frames.${memoryInfo}</p>`, 'error');
                }
            }
            
            try {
                console.log(' Rendering gallery view...');
                renderGalleryView(paginatedData);
                console.log(' Gallery view rendered successfully');
            } catch (error) {
                console.error(' Error rendering gallery view:', error);
                console.error('Stack trace:', error.stack);
                
                // Enhanced error reporting for call stack issues
                if (error.message && error.message.includes('Maximum call stack size exceeded')) {
                    const stackTrace = error.stack || '';
                    const stackLines = stackTrace.split('\n').filter(line => line.trim().length > 0);
                    const stackDepth = stackLines.length;
                    
                    let memoryInfo = '';
                    if (performance && performance.memory) {
                        const memory = performance.memory;
                        const usedMB = Math.round(memory.usedJSHeapSize / 1024 / 1024);
                        const totalMB = Math.round(memory.totalJSHeapSize / 1024 / 1024);
                        const limitMB = Math.round(memory.jsHeapSizeLimit / 1024 / 1024);
                        memoryInfo = ` Memory: ${usedMB}MB used, ${totalMB}MB total, ${limitMB}MB limit.`;
                    }
                    
                    console.error(' Gallery view call stack overflow - Stack depth:', stackDepth, 'frames.', memoryInfo);
                    appendStatusMessage(`<h4>Gallery View Error</h4><p>Maximum call stack size exceeded. Stack depth: ~${stackDepth} frames.${memoryInfo}</p>`, 'error');
                }
            }
            
            // Reapply group highlighting
            console.log(' Scheduling group highlighting update in 100ms...');
            setTimeout(() => {
                console.log(' Executing group highlighting update...');
                try {
                    updateGroupHighlighting();
                    console.log(' Group highlighting updated successfully');
                } catch (error) {
                    console.error(' Error updating group highlighting:', error);
                }
            }, 100);
            
            console.log(' applyAllFilters completed successfully');
        }
        
        // Switch between views
        function switchView(viewType) {
            currentView = viewType;
            
            // Save view preference to list-specific localStorage (view mode is list-based, not snapshot-based)
            localStorage.setItem(getListStorageKey('participantsViewMode'), viewType);
            
            // Update URL hash parameter (don't send 'column' since it's the default)
            if (viewType === 'column') {
                setURLHashParam('display', null); // Remove display parameter for column view
            } else {
                setURLHashParam('display', viewType);
            }
            
            // Hide all views
            document.getElementById('column-view').style.display = 'none';
            document.getElementById('table-view').style.display = 'none';
            document.getElementById('gallery-view').style.display = 'none';
            
            // Show selected view
            document.getElementById(viewType + '-view').style.display = 'block';
            
            // Update button states for expanded view
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(viewType + '-view-btn').classList.add('active');
            
            // Update button states for condensed view
            updateCondensedViewButtons();
            
            // Apply group highlighting after view switch
            setTimeout(() => updateGroupHighlighting(), 100);
            
            // If switching to gallery view and there's a saved team filter, restore it
            if (viewType === 'gallery' && currentTeamFilter && allRowsData.length > 0) {
                setTimeout(() => {
                    filterByTeam(currentTeamFilter);
                }, 150);
            }
        }
        
        // Group participants functionality
        function loadGroupParticipants() {
            // Check URL hash parameter first, then fallback to localStorage
            const stored = localStorage.getItem(getListStorageKey('groupParticipants'));
            const groupInput = document.getElementById('group');
            
            let groupString = '';
            if (stored && stored.trim()) {
                // Load from localStorage only (no hash loading)
                groupString = stored;
                console.log(' Loading group participants from localStorage:', stored);
            } else {
                console.log(' No group participants found in localStorage');
            }
            
            if (groupString && groupInput) {
                // Format the group string with proper spacing (replace commas with ", ")
                const formattedGroupString = groupString.replace(/,/g, ', ');
                
                // Populate the field with the group string from localStorage or snapshot
                groupInput.value = formattedGroupString;
                console.log(' Populated group input field with:', formattedGroupString, '(from localStorage/snapshot)');
                // Scroll to the right to show the end of the text
                setTimeout(() => scrollGroupInputToRight(), 100);
                const parsedNames = groupString.split(',').map(name => name.trim()).filter(name => name);
                groupParticipants = new Set(parsedNames);
                
                // Validate names from localStorage or snapshot
                validateGroupNames(parsedNames);
                
                // When loading from localStorage/snapshot, check if the group filter was previously active
                // and restore that state (showOnlyGroup is already loaded from localStorage at startup)
                updateGroupToggleUI();
                console.log(' Restored group participants from localStorage/snapshot');
            } else if (groupString && !groupInput) {
                console.log(' Group string found but input element not available:', groupString);
            } else if (!groupString && groupInput) {
                // No group data found, ensure field is cleared
                console.log(' No group data found, clearing field and participants');
                groupInput.value = '';
                groupParticipants = new Set();
                hideGroupValidationMessage();
            }
            updateGroupCount();
            
            // Initialize previousGroupParam state
            previousGroupParam = getHash().group;
        }
        
        function scrollGroupInputToRight() {
            const groupInput = document.getElementById('group');
            groupInput.scrollLeft = groupInput.scrollWidth - groupInput.clientWidth;
        }
        
        function saveGroupParticipants() {
            const groupList = Array.from(groupParticipants).join(', ');
            localStorage.setItem(getListStorageKey('groupParticipants'), groupList);
            // Don't overwrite the input field value to preserve user's typing
            
            // Update visibility since we now have stored group participants
            updateGroupParticipantsVisibility();
        }
        
        // Removed updateGroupHashParam - no longer updating URL with group data
        
        function updateGroupCount() {
            const count = groupParticipants.size;
            document.getElementById('group-count').textContent = `(${count})`;
        }
        
        function updateGroupHighlighting() {
            // Remove existing highlighting
            document.querySelectorAll('.columns-group').forEach(el => {
                el.classList.remove('columns-group');
            });
            
            // Apply highlighting to group participants
            groupParticipants.forEach(name => {
                const elements = document.querySelectorAll(`[data-columns-name]`);
                elements.forEach(el => {
                    if (el.dataset.participantName.toLowerCase() === name.toLowerCase()) {
                        el.classList.add('columns-group');
                    }
                });
            });
        }
        
        function cleanHTMLFromNames(htmlString) {
            // Create a temporary DOM element to parse HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlString;
            
            // Extract all text content and collect names
            const extractedNames = [];
            
            // First, check if there are HTML elements with names
            const possibleNameElements = tempDiv.querySelectorAll('li, span, div, p, td, th');
            
            if (possibleNameElements.length > 0) {
                // Extract text from structured HTML elements in order
                possibleNameElements.forEach((element, index) => {
                    const text = element.textContent.trim();
                    if (text && text.length > 0) {
                        // Check if this element contains separators
                        if (text.includes(',') || text.includes(';') || text.includes('\n') || text.includes('\t')) {
                            // Split by separators if they exist within the element
                            const names = text.split(/[,;\n\t]/).map(name => name.trim()).filter(name => name.length > 0);
                            extractedNames.push(...names);
                        } else {
                            // Single name in this element
                            extractedNames.push(text);
                        }
                    }
                });
            }
            
            // Also check for any plain text content outside of HTML elements
            // Walk through all nodes to catch plain text between elements
            const walker = document.createTreeWalker(
                tempDiv,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let textNode;
            while (textNode = walker.nextNode()) {
                const text = textNode.textContent.trim();
                if (text && text.length > 0) {
                    // Split by separators and add to extracted names
                    const names = text.split(/[,;\n\t]/).map(name => name.trim()).filter(name => name.length > 0);
                    extractedNames.push(...names);
                }
            }
            
            // Remove duplicates (case-insensitive) and join with commas
            const uniqueNames = removeDuplicatesIgnoreCase(extractedNames);
            const result = uniqueNames.join(', ');
            
            console.log(' Cleaned HTML from names:', htmlString.substring(0, 100) + '...', '', result);
            return result;
        }
        
        // Helper function to remove duplicates ignoring case
        function removeDuplicatesIgnoreCase(names) {
            const seen = new Map();
            const result = [];
            
            names.forEach(name => {
                const lowerName = name.toLowerCase();
                if (!seen.has(lowerName)) {
                    seen.set(lowerName, name);
                    result.push(name);
                }
            });
            
            return result;
        }
        
        function processGroupInput() {
            const input = document.getElementById('group');
            let value = input.value;
            
            // Check if value contains HTML and clean it if necessary
            if (value.includes('<') && value.includes('>')) {
                value = cleanHTMLFromNames(value);
                // Update the input field with cleaned value
                input.value = value;
            }
            
            // Parse names from input and expand full names
            groupParticipants = new Set();
            const inputNames = [];
            const expandedNames = [];
            
            value.split(',').forEach(name => {
                const trimmed = name.trim();
                if (trimmed) {
                    inputNames.push(trimmed);
                    
                    // Check if name contains a space (full name)
                    if (trimmed.includes(' ')) {
                        const nameParts = trimmed.split(' ').filter(part => part.trim().length > 0);
                        if (nameParts.length >= 2) {
                            const firstName = nameParts[0];
                            const lastName = nameParts[nameParts.length - 1]; // Use last part in case of middle names
                            const lastInitial = lastName.charAt(0).toUpperCase();
                            
                            // Add both first name only and first name + last initial
                            expandedNames.push(firstName);
                            expandedNames.push(firstName + lastInitial);
                            groupParticipants.add(firstName);
                            groupParticipants.add(firstName + lastInitial);
                        } else {
                            // Single word with space somehow, treat as regular name
                            expandedNames.push(trimmed);
                            groupParticipants.add(trimmed);
                        }
                    } else {
                        // No space, regular name
                        expandedNames.push(trimmed);
                        groupParticipants.add(trimmed);
                    }
                }
            });
            
            // Remove duplicates (case-insensitive) from expanded names
            const uniqueExpandedNames = removeDuplicatesIgnoreCase(expandedNames);
            
            // Update groupParticipants with deduplicated names
            groupParticipants = new Set(uniqueExpandedNames);
            
            // Update the input field to show the deduplicated expanded names
            if (uniqueExpandedNames.length > 0) {
                input.value = uniqueExpandedNames.join(', ');
            }
            
            // Validate names against dataset (using all expanded names)
            validateGroupNames(Array.from(groupParticipants));
            
            // Save to storage and update URL hash
            saveGroupParticipants();
            updateGroupCount();
            updateGroupHighlighting();
            
            // Note: URL hash parameters for groups have been discontinued
            
            // Update active snapshot with current changes instead of clearing it
            if (currentActiveSnapshot) {
                saveSnapshot(currentActiveSnapshot);
                // Update the UI to reflect the snapshot is still active
                updateGroupSnapshotInfo();
            } else {
                // Auto-save to browser cache with date-based snapshot if no active snapshot
                if (uniqueExpandedNames.length > 0) {
                    saveGroupToDateSnapshot(uniqueExpandedNames);
                }
            }
            
            // If group filter is active, refresh the list to show/hide participants
            if (showOnlyGroup) {
                applyAllFilters();
            }
        }
        
        // Store not found names globally so button can access them
        let currentNotFoundNames = [];
        
        function validateGroupNames(inputNames) {
            if (!allRowsData || allRowsData.length === 0) {
                console.log(' Skipping group name validation - data not yet available');
                return;
            }
            
            if (inputNames.length === 0) {
                // Hide message if no names to validate
                hideGroupValidationMessage();
                currentNotFoundNames = [];
                return;
            }
            
            // Get all participant names from the dataset
            const datasetNames = allRowsData.map(participant => getParticipantName(participant));
            const datasetNamesLower = datasetNames.map(name => name.toLowerCase());
            
            // Find names that don't exist in the dataset
            const notFoundNames = inputNames.filter(inputName => {
                const inputNameLower = inputName.toLowerCase();
                return !datasetNamesLower.includes(inputNameLower);
            });
            
            // Store not found names for button access
            currentNotFoundNames = notFoundNames;
            
            // Show message if there are names not found
            if (notFoundNames.length > 0) {
                const message = `Not found in dataset: ${notFoundNames.join(', ')}`;
                console.warn(' ' + message);
                
                // Show a message to the user with remove button
                showGroupValidationMessage(message, true);
            } else {
                // Hide message if all names are valid
                hideGroupValidationMessage();
            }
        }
        
        function showGroupValidationMessage(message, showButton = false) {
            // Create or update validation message element
            let messageEl = document.getElementById('group-validation-message');
            if (!messageEl) {
                messageEl = document.createElement('div');
                messageEl.id = 'group-validation-message';
                messageEl.style.cssText = `
                    color: #d97706;
                    font-size: 12px;
                    margin-top: 4px;
                    padding: 4px 8px;
                    background: #fef3c7;
                    border: 1px solid #f59e0b;
                    border-radius: 4px;
                    display: none;
                `;
                
                // Insert after the group control
                const groupControl = document.getElementById('group-control');
                if (groupControl && groupControl.parentNode) {
                    groupControl.parentNode.insertBefore(messageEl, groupControl.nextSibling);
                }
            }
            
            // Clear existing content and add message
            messageEl.innerHTML = '';
            
            // Add message text
            const messageSpan = document.createElement('span');
            messageSpan.textContent = message;
            messageEl.appendChild(messageSpan);
            
            // Add remove button if requested
            if (showButton && currentNotFoundNames.length > 0) {
                const buttonSpan = document.createElement('span');
                buttonSpan.style.cssText = `
                    margin-left: 8px;
                `;
                
                const removeButton = document.createElement('button');
                removeButton.textContent = 'Remove Unfound';
                removeButton.style.cssText = `
                    background: #dc2626;
                    color: white;
                    border: none;
                    padding: 2px 6px;
                    border-radius: 3px;
                    font-size: 11px;
                    cursor: pointer;
                `;
                removeButton.onclick = removeUnfoundNames;
                
                buttonSpan.appendChild(removeButton);
                messageEl.appendChild(buttonSpan);
            }
            
            messageEl.style.display = 'block';
        }
        
        function hideGroupValidationMessage() {
            const messageEl = document.getElementById('group-validation-message');
            if (messageEl) {
                messageEl.style.display = 'none';
            }
        }
        
        function removeUnfoundNames() {
            if (currentNotFoundNames.length === 0) {
                return;
            }
            
            const input = document.getElementById('group');
            
            // Get current names from the groupParticipants set
            const validNames = Array.from(groupParticipants).filter(name => 
                !currentNotFoundNames.some(notFound => 
                    notFound.toLowerCase() === name.toLowerCase()
                )
            );
            
            // Update the input field and groupParticipants set
            input.value = validNames.join(', ');
            groupParticipants = new Set(validNames);
            
            // Clear the not found names array
            currentNotFoundNames = [];
            
            // Save to storage
            saveGroupParticipants();
            updateGroupCount();
            updateGroupHighlighting();
            
            // Update active snapshot with the changes
            if (currentActiveSnapshot) {
                console.log(' Updating active snapshot after removing unfound names:', currentActiveSnapshot);
                saveSnapshot(currentActiveSnapshot);
                // Update the UI to reflect the snapshot is still active
                updateGroupSnapshotInfo();
            } else {
                // Auto-save to browser cache with date-based snapshot if no active snapshot
                if (validNames.length > 0) {
                    saveGroupToDateSnapshot(validNames);
                }
            }
            
            // Hide the validation message since we've removed the unfound names
            hideGroupValidationMessage();
            
            // Apply filters if group filter is active
            if (showOnlyGroup) {
                applyAllFilters();
            }
            
            console.log(' Removed unfound names and updated cache snapshot');
        }
        
        function toggleGroupFilter() {
            showOnlyGroup = !showOnlyGroup;
            
            // Clear active snapshot since filter changed manually
            clearActiveSnapshot();
            
            // Save state to localStorage
            localStorage.setItem(getListStorageKey('showOnlyGroup'), JSON.stringify(showOnlyGroup));
            
            // Note: Group toggle button does not alter URL hash
            // Hash is only updated when group participants are manually edited
            
            updateGroupToggleUI();
            
            // Apply all filters (includes group participant filtering)
            applyAllFilters();
        }
        
        function updateGroupToggleUI() {
            const toggle = document.getElementById('group-toggle');
            const toggleText = document.getElementById('group-toggle-text');
            
            // Get cached text choices or use defaults
            const cachedActiveText = localStorage.getItem(getListStorageKey('groupToggleActiveText')) || 'Focus';
            const cachedInactiveText = localStorage.getItem(getListStorageKey('groupToggleInactiveText')) || 'Highlight';
            
            if (showOnlyGroup) {
                toggle.classList.add('active');
                toggleText.textContent = cachedActiveText;
            } else {
                toggle.classList.remove('active');
                toggleText.textContent = cachedInactiveText;
            }
        }
        
        function shouldShowGroupParticipants() {
            // Check current list from hash
            const currentList = getHash().list;
            
            // Check if the current list supports groups (modelteam) AND it exists in fileSelect
            const isGroupList = Array.from(fileSelect.options).find(option => option.value === 'modelteam');
            const isCurrentlyOnGroupList = currentList === 'modelteam';
            
            // Only show if currently on a group-supporting list AND that list is available in fileSelect
            return isCurrentlyOnGroupList && isGroupList;
        }
        
        function updateGroupParticipantsVisibility() {
            const groupControl = document.getElementById('group-control');
            if (groupControl) {
                if (shouldShowGroupParticipants()) {
                    groupControl.style.display = 'block';
                } else {
                    groupControl.style.display = 'none';
                }
            }
        }
        
        // Data preprocessing functions for column name normalization
        function detectCommonPrefix(columns) {
            if (columns.length === 0) return '';
            
            // Find the shortest column name to limit prefix length
            const minLength = Math.min(...columns.map(col => col.length));
            if (minLength === 0) return '';
            
            let commonPrefix = '';
            
            // Check each character position
            for (let i = 0; i < minLength; i++) {
                const char = columns[0][i];
                
                // Check if all columns have the same character at this position
                const allMatch = columns.every(col => col[i] === char);
                
                if (allMatch) {
                    commonPrefix += char;
                } else {
                    break;
                }
            }
            
            // Only return prefix if it ends with an underscore or is substantial
            // and all columns would still have meaningful names after removal
            if (commonPrefix.length > 2 && 
                (commonPrefix.endsWith('_') || commonPrefix.length >= 4)) {
                
                // Verify all columns would have meaningful names after prefix removal
                const wouldBeValid = columns.every(col => {
                    const remaining = col.substring(commonPrefix.length);
                    return remaining.length > 0 && remaining !== '_';
                });
                
                if (wouldBeValid) {
                    return commonPrefix;
                }
            }
            
            return '';
        }
        
        // Add safety check to prevent infinite reprocessing
        let preprocessCallCount = 0;
        let lastPreprocessTime = 0;
        
        function preprocessParticipantData(participants) {
            if (!Array.isArray(participants) || participants.length === 0) {
                return participants;
            }
            
            // Safety check to prevent infinite loops
            const now = Date.now();
            if (now - lastPreprocessTime < 1000) { // If called within 1 second
                preprocessCallCount++;
                if (preprocessCallCount > 5) {
                    console.error(' preprocessParticipantData called too many times rapidly. Preventing infinite loop.');
                    return participants; // Return original data to break the loop
                }
            } else {
                preprocessCallCount = 0;
            }
            lastPreprocessTime = now;
            
            console.log(' preprocessParticipantData called, count:', preprocessCallCount);
            console.log(' Processing', participants.length, 'participants');
            console.log(' First participant sample:', participants[0]);
            console.log(' Second participant sample:', participants[1]);
            console.log(' Last participant sample:', participants[participants.length - 1]);
            
            return participants.map((participant, index) => {
                // Debug first few and last few rows
                if (index < 3 || index > participants.length - 3) {
                    console.log(` Processing participant ${index}:`, participant);
                }
                
                // Create a new object to maintain original data
                const processed = {};
                
                // Step 1: Get all column names
                const allColumns = Object.keys(participant);
                const commonPrefix = detectCommonPrefix(allColumns);
                
                // Step 2: Create a mapping of original to cleaned column names
                const columnMapping = {};
                allColumns.forEach(col => {
                    let cleanedName = col;
                    if (commonPrefix && col.startsWith(commonPrefix)) {
                        cleanedName = col.substring(commonPrefix.length);
                        // Ensure the cleaned name doesn't start with underscore
                        if (cleanedName.startsWith('_')) {
                            cleanedName = cleanedName.substring(1);
                        }
                    }
                    columnMapping[col] = cleanedName;
                });
                
                // Step 3: Identify ID columns and add them first (using cleaned names)
                const idColumns = [];
                const otherColumns = [];
                
                Object.entries(columnMapping).forEach(([originalKey, cleanedKey]) => {
                    if (cleanedKey === 'id' || cleanedKey.endsWith('_id') || cleanedKey.endsWith('ID') || cleanedKey === 'ID') {
                        idColumns.push({ original: originalKey, cleaned: cleanedKey });
                    } else {
                        otherColumns.push({ original: originalKey, cleaned: cleanedKey });
                    }
                });
                
                // Sort ID columns (id first, then others alphabetically)
                idColumns.sort((a, b) => {
                    if (a.cleaned === 'id') return -1;
                    if (b.cleaned === 'id') return 1;
                    return a.cleaned.localeCompare(b.cleaned);
                });
                
                // Step 4: Add ID columns first
                idColumns.forEach(({ original, cleaned }) => {
                    processed[cleaned] = participant[original];
                });
                
                // Step 5: Handle description -> title conversion
                const descriptionColumn = otherColumns.find(({ cleaned, original }) => 
                    cleaned === 'description' || 
                    original === 'project_description' ||
                    cleaned === 'project_description'
                );
                
                if (descriptionColumn && participant[descriptionColumn.original] !== undefined && 
                    participant[descriptionColumn.original] !== null && participant[descriptionColumn.original] !== '') {
                    processed.title = participant[descriptionColumn.original];
                    // Remove from otherColumns to avoid duplication
                    const index = otherColumns.indexOf(descriptionColumn);
                    if (index > -1) {
                        otherColumns.splice(index, 1);
                    }
                } else {
                    // Check for existing title
                    const titleColumn = otherColumns.find(({ cleaned }) => cleaned === 'title');
                    if (titleColumn && participant[titleColumn.original] !== undefined && 
                        participant[titleColumn.original] !== null && participant[titleColumn.original] !== '') {
                        processed.title = participant[titleColumn.original];
                        // Remove from otherColumns to avoid duplication
                        const index = otherColumns.indexOf(titleColumn);
                        if (index > -1) {
                            otherColumns.splice(index, 1);
                        }
                    }
                }
                
                // Step 6: Add Name column only if no existing name field is found
                // Check if there's already a name column in the data
                const existingNameColumn = otherColumns.find(({ cleaned }) => 
                    cleaned === 'name' || 
                    cleaned === 'participant_name' ||
                    cleaned === 'full_name' ||
                    cleaned === 'display_name'
                );
                
                // Only add a Name column if no existing name column is found
                if (!existingNameColumn) {
                    let nameField = null;
                    
                    if (processed.title && processed.title !== '') {
                        // Use title field as name
                        nameField = processed.title;
                    } else if (otherColumns.length > 0) {
                        // Use first non-ID column as name
                        const firstColumn = otherColumns[0];
                        nameField = participant[firstColumn.original] || '';
                        console.log('Name field logic - using column:', firstColumn.cleaned, 'value:', nameField);
                    } else {
                        // Final fallback
                        nameField = 'Unknown';
                    }
                    
                    // Add as "Name" column (not "displayName")
                    processed.Name = nameField;
                }
                
                // Step 7: Add remaining columns with cleaned names
                otherColumns.forEach(({ original, cleaned }) => {
                    processed[cleaned] = participant[original];
                });
                
                return processed;
            });
        }
        
        function getParticipantName(participant, topFieldsFirstField = null) {
            // Helper function to get the appropriate name field from a participant object
            // Prioritizes TopFields first field if provided, then checks for various name field variations
            if (!participant || typeof participant !== 'object') {
                return 'Unknown';
            }
            
            // Check TopFields first field if provided
            if (topFieldsFirstField && participant[topFieldsFirstField] !== undefined && 
                participant[topFieldsFirstField] !== null && participant[topFieldsFirstField] !== '') {
                return participant[topFieldsFirstField];
            }
            
            const nameFields = ['Name', 'name', 'participant_name', 'full_name', 'display_name', 'displayName'];
            
            for (const field of nameFields) {
                if (participant[field] !== undefined && participant[field] !== null && participant[field] !== '') {
                    return participant[field];
                }
            }
            
            return 'Unknown';
        }
        
        // Raw data functionality
        let originalRawData = null;
        let rawDataVisible = false;
        
        function toggleRawData() {
            rawDataVisible = !rawDataVisible;
            const rawDataControl = document.getElementById('raw-data-control');
            const rawDataEditor = document.getElementById('raw-data-editor');
            const rawDataText = document.getElementById('raw-data-text');
            const rawDataSource = document.getElementById('raw-data-source');
            
            if (rawDataVisible) {
                // Show raw data editor
                rawDataControl.style.display = 'block';
                rawDataText.textContent = 'Hide Raw Data';
                
                // Store original data and populate editor
                originalRawData = JSON.parse(JSON.stringify(participantsData));
                rawDataEditor.value = JSON.stringify(participantsData, null, 2);
                
                // Populate data source field
                const currentSource = getCurrentDataSource();
                rawDataSource.value = currentSource;
            } else {
                // Hide raw data editor
                rawDataControl.style.display = 'none';
                rawDataText.textContent = 'View Raw Data';
            }
            
            // Close menu
            document.getElementById('menu-toggle').classList.remove('active');
            document.getElementById('menu-dropdown').classList.remove('active');
        }
        
        function getCurrentDataSource() {
            // Get current data source based on selection and hash parameters
            const listParam = getHash().list;
            
            if (listParam === 'all') {
                return 'Meta-list: All Available Lists';
            } else if (selectedFile === 'all') {
                return 'Meta-list: All Available Lists';
            } else if (selectedFile && selectedFile.startsWith('http')) {
                return selectedFile;
            } else if (selectedFile && selectedFile.startsWith('custom_')) {
                return `Custom file: ${selectedFile.replace('custom_', '')}`;
            } else {
                // Try to get URL from selected dropdown option
                const selectedOption = fileSelect.options[fileSelect.selectedIndex];
                const dataUrl = selectedOption?.getAttribute('data-url');
                
                if (dataUrl && dataUrl !== 'all') {
                    return dataUrl;
                } else {
                    return selectedOption?.textContent || 'Unknown data source';
                }
            }
        }
        
        function applyRawDataChanges() {
            const rawDataEditor = document.getElementById('raw-data-editor');
            
            try {
                // Parse the edited JSON
                const editedData = JSON.parse(rawDataEditor.value);
                
                // Validate that it's an array
                if (!Array.isArray(editedData)) {
                    throw new Error('Data must be an array of participants');
                }
                
                // Update the global participants data
                participantsData = editedData;
                
                // Apply all filters and refresh the display
                applyAllFilters();
                
                // Show success message
                showStatusMessage('Raw data changes applied successfully', 'success');
                
            } catch (error) {
                // Show error message
                showStatusMessage('Error parsing JSON: ' + error.message, 'error');
                console.error('Raw data parsing error:', error);
            }
        }
        
        function revertRawData() {
            const rawDataEditor = document.getElementById('raw-data-editor');
            
            if (originalRawData) {
                // Restore original data
                participantsData = JSON.parse(JSON.stringify(originalRawData));
                rawDataEditor.value = JSON.stringify(originalRawData, null, 2);
                
                // Apply all filters and refresh the display
                applyAllFilters();
                
                // Show success message
                showStatusMessage('Raw data reverted to original', 'info');
            }
        }
        
        function closeRawData() {
            // Close the raw data editor if it's open
            if (rawDataVisible) {
                toggleRawData();
            }
        }
        
        function showStatusMessage(message, type = 'info') {
            // Create or update status message element
            let statusEl = document.getElementById('raw-data-status');
            if (!statusEl) {
                statusEl = document.createElement('div');
                statusEl.id = 'raw-data-status';
                statusEl.className = 'status-message';
                document.getElementById('raw-data-control').appendChild(statusEl);
            }
            
            // Set message and type
            statusEl.textContent = message;
            statusEl.className = `status-message ${type}`;
            statusEl.style.display = 'block';
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 3000);
        }
        
        function exportCSVFromMenu() {
            // Close menu first
            document.getElementById('menu-toggle').classList.remove('active');
            document.getElementById('menu-dropdown').classList.remove('active');
            
            // Call the existing export CSV functionality
            exportParticipantsCSV();
        }
        
        // Snapshot functionality
        let currentActiveSnapshot = null;
        
        function getSnapshotsStorageKey() {
            const listId = getHash().list || 'default';
            return `${listId}_1_snapshots`;
        }
        
        function loadSnapshots() {
            const snapshots = JSON.parse(localStorage.getItem(getSnapshotsStorageKey()) || '{}');
            return snapshots;
        }
        
        function saveSnapshots(snapshots) {
            localStorage.setItem(getSnapshotsStorageKey(), JSON.stringify(snapshots));
        }
        
        function getCurrentFilterState() {
            return {
                sortColumn: currentSortColumn,
                sortOrder: currentSortOrder,
                teamFilter: currentTeamFilter,
                displayMode: currentView,
                statusFilter: Array.from(selectedStatuses),
                groupParticipants: Array.from(groupParticipants),
                showOnlyGroup: showOnlyGroup
            };
        }
        
        function applyFilterState(filterState) {
            // Apply sort
            currentSortColumn = filterState.sortColumn || 'Rows';
            currentSortOrder = filterState.sortOrder || 'asc';
            localStorage.setItem(getListStorageKey('participantsSortColumn'), currentSortColumn);
            localStorage.setItem(getListStorageKey('participantsSortOrder'), currentSortOrder);
            applySortToData();
            generateSortDropdown();
            
            // Apply team filter - respect hash values over filter state
            const hashTeam = getHash().team;
            if (hashTeam) {
                // Hash value takes priority over filter state
                currentTeamFilter = hashTeam;
            } else {
                currentTeamFilter = filterState.teamFilter || null;
            }
            if (currentTeamFilter) {
                localStorage.setItem(getListStorageKey('participantsTeamFilter'), currentTeamFilter);
            } else {
                localStorage.removeItem(getListStorageKey('participantsTeamFilter'));
            }
            
            // Apply display mode - respect hash values over filter state
            const hashDisplay = getHash().display;
            const targetDisplayMode = hashDisplay || filterState.displayMode;
            if (targetDisplayMode && targetDisplayMode !== currentView) {
                switchView(targetDisplayMode);
            }
            
            // Apply status filter - respect hash values over filter state
            const hashStatus = getHash().status;
            if (hashStatus) {
                // Hash value takes priority over filter state
                selectedStatuses = new Set(hashStatus.split(','));
            } else {
                selectedStatuses = new Set(filterState.statusFilter || ['All']);
            }
            localStorage.setItem(getListStorageKey('participantsStatusFilter'), JSON.stringify(Array.from(selectedStatuses)));
            updateStatusButtonText();
            generateStatusDropdown();
            
            // Apply group participants
            groupParticipants = new Set(filterState.groupParticipants || []);
            showOnlyGroup = filterState.showOnlyGroup || false;
            localStorage.setItem(getListStorageKey('showOnlyGroup'), JSON.stringify(showOnlyGroup));
            
            const groupInput = document.getElementById('group');
            if (groupInput) {
                const groupValue = Array.from(groupParticipants).join(', ');
                groupInput.value = groupValue;
                // Also update localStorage to match the snapshot
                localStorage.setItem(getListStorageKey('groupParticipants'), groupValue);
            }
            updateGroupCount();
            updateGroupToggleUI();
            
            // Apply all filters
            applyAllFilters();
            
            // Sync checkboxes after all filters are applied
            setTimeout(syncCheckboxesWithGroup, 50);
        }
        
        function saveSnapshot(name) {
            const snapshots = loadSnapshots();
            const filterState = getCurrentFilterState();
            snapshots[name] = filterState;
            saveSnapshots(snapshots);
            renderSnapshotsList();
        }
        
        function loadSnapshot(name) {
            const snapshots = loadSnapshots();
            console.log(` Loading snapshot "${name}" for list:`, getHash().list);
            console.log(' Available snapshots:', Object.keys(snapshots));
            
            if (snapshots[name]) {
                isLoadingSnapshot = true;
                currentActiveSnapshot = name;
                console.log(' Set currentActiveSnapshot to:', currentActiveSnapshot);
                applyFilterState(snapshots[name]);
                updateListTitle();
                isLoadingSnapshot = false;
            } else {
                console.log(' Snapshot not found:', name);
            }
        }
        
        function deleteSnapshot(name) {
            const snapshots = loadSnapshots();
            delete snapshots[name];
            saveSnapshots(snapshots);
            if (currentActiveSnapshot === name) {
                currentActiveSnapshot = null;
                updateListTitle();
            }
            renderSnapshotsList();
        }
        
        function renderSnapshotsList() {
            const snapshots = loadSnapshots();
            const snapshotsList = document.getElementById('snapshots-list');
            
            if (!snapshotsList) {
                console.warn('snapshots-list element not found, skipping render');
                return;
            }
            
            snapshotsList.innerHTML = '';
            
            Object.keys(snapshots).forEach(name => {
                const snapshotItem = document.createElement('div');
                snapshotItem.className = 'snapshot-item';
                
                snapshotItem.innerHTML = `
                    <input type="text" class="snapshot-name" value="${name}" readonly>
                    <button class="snapshot-save-btn" title="Save current filters">Save</button>
                    <button class="snapshot-view-btn" title="Load this snapshot">View</button>
                    <div class="snapshot-menu">
                        <button class="snapshot-menu-btn" title="More options"></button>
                        <div class="snapshot-menu-dropdown">
                            <div class="snapshot-menu-item" onclick="deleteSnapshot('${name}')">Delete</div>
                        </div>
                    </div>
                `;
                
                const nameInput = snapshotItem.querySelector('.snapshot-name');
                const saveBtn = snapshotItem.querySelector('.snapshot-save-btn');
                const viewBtn = snapshotItem.querySelector('.snapshot-view-btn');
                
                // Click snapshot name to edit it
                nameInput.addEventListener('click', () => {
                    if (!nameInput.classList.contains('editing')) {
                        nameInput.classList.add('editing');
                        nameInput.readOnly = false;
                        nameInput.select();
                    }
                });
                
                // Double-click to edit name (keep for backward compatibility)
                nameInput.addEventListener('dblclick', () => {
                    nameInput.classList.add('editing');
                    nameInput.readOnly = false;
                    nameInput.select();
                });
                
                // Save name on blur or enter
                nameInput.addEventListener('blur', () => saveSnapshotName(nameInput, name));
                nameInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        saveSnapshotName(nameInput, name);
                    }
                });
                
                // Save button - save current filter state to this snapshot
                saveBtn.addEventListener('click', () => {
                    saveSnapshot(name);
                    // Set as current active snapshot and update title
                    currentActiveSnapshot = name;
                    updateListTitle();
                    alert(`Snapshot "${name}" updated with current filters and activated!`);
                });
                
                // View button - load this snapshot
                viewBtn.addEventListener('click', () => {
                    loadSnapshot(name);
                    toggleSnapshots();
                });
                
                // Menu dropdown functionality
                const menuBtn = snapshotItem.querySelector('.snapshot-menu-btn');
                const menuDropdown = snapshotItem.querySelector('.snapshot-menu-dropdown');
                
                menuBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Close all other dropdowns first
                    document.querySelectorAll('.snapshot-menu-dropdown').forEach(dropdown => {
                        if (dropdown !== menuDropdown) {
                            dropdown.style.display = 'none';
                        }
                    });
                    // Toggle current dropdown
                    menuDropdown.style.display = menuDropdown.style.display === 'block' ? 'none' : 'block';
                });
                
                // Close dropdown when clicking outside
                document.addEventListener('click', () => {
                    menuDropdown.style.display = 'none';
                });
                
                snapshotsList.appendChild(snapshotItem);
            });
        }
        
        function saveSnapshotName(input, oldName) {
            const newName = input.value.trim();
            if (newName && newName !== oldName) {
                const snapshots = loadSnapshots();
                snapshots[newName] = snapshots[oldName];
                delete snapshots[oldName];
                saveSnapshots(snapshots);
                
                if (currentActiveSnapshot === oldName) {
                    currentActiveSnapshot = newName;
                    updateListTitle();
                }
                
                renderSnapshotsList();
            } else {
                input.value = oldName;
            }
            input.classList.remove('editing');
            input.readOnly = true;
        }
        
        function toggleSnapshots() {
            const snapshotsControl = document.getElementById('snapshots-control');
            const isVisible = snapshotsControl.style.display === 'block';
            
            if (isVisible) {
                snapshotsControl.style.display = 'none';
            } else {
                snapshotsControl.style.display = 'block';
                renderSnapshotsList();
                
                // Auto-populate new snapshot name with today's date
                const nameInput = document.getElementById('new-snapshot-name');
                if (nameInput) {
                    const today = new Date();
                    const months = ['January', 'February', 'March', 'April', 'May', 'June',
                                  'July', 'August', 'September', 'October', 'November', 'December'];
                    const defaultName = `${months[today.getMonth()]} ${today.getDate()}, ${today.getFullYear()}`;
                    nameInput.value = defaultName;
                }
            }
            
            // Close menu
            document.getElementById('menu-toggle').classList.remove('active');
            document.getElementById('menu-dropdown').classList.remove('active');
        }
        
        function addNewSnapshot() {
            const nameInput = document.getElementById('new-snapshot-name');
            const name = nameInput.value.trim();
            
            if (!name) {
                alert('Please enter a snapshot name');
                return;
            }
            
            const snapshots = loadSnapshots();
            if (snapshots[name]) {
                if (!confirm(`Snapshot "${name}" already exists. Overwrite?`)) {
                    return;
                }
            }
            
            saveSnapshot(name);
            // Set as current active snapshot and update title
            currentActiveSnapshot = name;
            updateListTitle();
            nameInput.value = '';
            alert(`Snapshot "${name}" saved and activated!`);
        }
        
        function updateListTitle() {
            const listTitle = document.getElementById('list-title');
            const baseTitle = listTitle.textContent.split(' - ')[0]; // Remove existing snapshot name
            
            // Keep list title clean - no snapshot name in main title
            listTitle.textContent = baseTitle;
            
            // Update group snapshot info
            updateGroupSnapshotInfo();
        }
        
        function updateGroupSnapshotInfo() {
            const snapshotInfo = document.getElementById('group-snapshot-info');
            const participantsLabel = document.getElementById('group-participants-label');
            console.log(' updateGroupSnapshotInfo called, element found:', !!snapshotInfo);
            console.log(' currentActiveSnapshot:', currentActiveSnapshot);
            
            if (!snapshotInfo) {
                console.error(' group-snapshot-info element not found');
                return;
            }
            
            if (currentActiveSnapshot) {
                // Show active snapshot name
                snapshotInfo.innerHTML = `Active: ${currentActiveSnapshot}`;
                console.log(' Displayed active snapshot in title:', currentActiveSnapshot);
            } else {
                // Show save snapshot link
                snapshotInfo.innerHTML = `<a href="#" onclick="promptSaveSnapshot(); return false;">Save Snapshot</a>`;
                console.log(' Displayed save snapshot link');
            }
        }
        
        function promptSaveSnapshot() {
            // Generate today's date in format "Month D, YYYY"
            const today = new Date();
            const months = ['January', 'February', 'March', 'April', 'May', 'June',
                          'July', 'August', 'September', 'October', 'November', 'December'];
            const defaultName = `${months[today.getMonth()]} ${today.getDate()}, ${today.getFullYear()}`;
            
            const name = prompt('Enter snapshot name:', defaultName);
            if (name && name.trim()) {
                const snapshots = loadSnapshots();
                if (snapshots[name.trim()]) {
                    if (!confirm(`Snapshot "${name.trim()}" already exists. Overwrite?`)) {
                        return;
                    }
                }
                
                saveSnapshot(name.trim());
                currentActiveSnapshot = name.trim();
                updateListTitle();
                alert(`Snapshot "${name.trim()}" saved and activated!`);
            }
        }
        
        let isLoadingSnapshot = false;
        
        function clearActiveSnapshot() {
            if (currentActiveSnapshot && !isLoadingSnapshot) {
                currentActiveSnapshot = null;
                updateListTitle();
                console.log(' Cleared active snapshot due to manual filter change');
            } else if (isLoadingSnapshot) {
                console.log(' Skipped clearing active snapshot - snapshot loading in progress');
            }
        }
        
        function loadSnapshotOnPageLoad() {
            const snapshots = loadSnapshots();
            
            // Find the most recent date-based snapshot
            const dateSnapshots = Object.keys(snapshots).filter(name => {
                // Check if snapshot name matches date format (Month DD, YYYY)
                return /^[A-Za-z]+ \d{2}, \d{4}$/.test(name);
            });
            
            if (dateSnapshots.length > 0) {
                // Sort by date (most recent first)
                dateSnapshots.sort((a, b) => {
                    const dateA = new Date(a);
                    const dateB = new Date(b);
                    return dateB - dateA; // Descending order (newest first)
                });
                
                const mostRecentSnapshot = dateSnapshots[0];
                console.log(` Loading most recent snapshot on page load: ${mostRecentSnapshot}`);
                loadSnapshot(mostRecentSnapshot);
            } else if (snapshots['1']) {
                // Fallback to snapshot '1' if no date-based snapshots exist
                console.log(' Loading fallback snapshot "1" on page load');
                loadSnapshot('1');
            }
        }
        
        function generateFullURL() {
            // Close menu first
            document.getElementById('menu-toggle').classList.remove('active');
            document.getElementById('menu-dropdown').classList.remove('active');
            
            // Start with current URL without hash
            const baseUrl = window.location.origin + window.location.pathname + window.location.search;
            const params = new URLSearchParams();
            
            // Add current hash parameters
            const currentHash = window.location.hash.substring(1);
            if (currentHash) {
                const hashParams = new URLSearchParams(currentHash);
                hashParams.forEach((value, key) => {
                    params.set(key, value);
                });
            }
            
            // Add sort parameters from localStorage
            if (currentSortColumn && currentSortColumn !== 'Rows') {
                params.set('sortby', currentSortColumn);
            }
            if (currentSortOrder && currentSortOrder !== 'asc') {
                params.set('sortorder', currentSortOrder);
            }
            
            // Add team filter if active
            if (currentTeamFilter) {
                params.set('team', currentTeamFilter);
            }
            
            // Add display mode if not default
            if (currentView && currentView !== 'column') {
                params.set('display', currentView);
            }
            
            // Add status filter if not "All"
            const statusArray = Array.from(selectedStatuses);
            if (!statusArray.includes('All') && statusArray.length > 0) {
                params.set('status', statusArray.join(','));
            }
            
            // Add group participants if any
            if (groupParticipants.size > 0) {
                params.set('group', Array.from(groupParticipants).join(','));
            }
            
            // Generate full URL
            const fullUrl = params.toString() ? `${baseUrl}#${params.toString()}` : baseUrl;
            
            // Copy to clipboard
            navigator.clipboard.writeText(fullUrl).then(() => {
                // Show success message
                alert('Full URL copied to clipboard!\n\nThe URL includes all current filters:\n- Sort settings\n- Team filter\n- Status filter\n- Group participants\n- Display mode');
                console.log(' Full URL copied to clipboard:', fullUrl);
            }).catch(err => {
                // Fallback for older browsers
                console.error('Failed to copy to clipboard:', err);
                alert('Full URL:\n\n' + fullUrl + '\n\n(Please copy manually)');
            });
        }
        
        function exportParticipantsCSV() {
            console.log('exportParticipantsCSV called');
            console.log('window.participantsData:', window.participantsData);
            console.log('allRowsData:', allRowsData);
            
            if (!window.participantsData || window.participantsData.length === 0) {
                // Try using allRowsData as fallback
                if (allRowsData && allRowsData.length > 0) {
                    console.log('Using allRowsData as fallback');
                    window.participantsData = allRowsData;
                } else {
                    alert('No participant data to export');
                    return;
                }
            }
            
            // Determine which data to export based on current filter state
            let dataToExport = window.participantsData;
            
            // Generate date string for filename (YYYY-MM-DD format)
            const today = new Date();
            const dateString = today.getFullYear() + '-' + 
                String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                String(today.getDate()).padStart(2, '0');
            
            let filename = `meetup-participants-${dateString}.csv`;
            
            // Apply team filter if active
            if (currentTeamFilter && currentTeamFilter !== 'all') {
                dataToExport = dataToExport.filter(participant => {
                    const teamClasses = getAllTeamClasses(participant.Team);
                    return teamClasses.includes(currentTeamFilter);
                });
                const teamName = teamColors[currentTeamFilter.replace('team-', '')] ? 
                    teamColors[currentTeamFilter.replace('team-', '')].name : 'filtered';
                filename = `meetup-participants-${teamName}-${dateString}.csv`;
            }
            
            // Apply status filter if active (using selectedStatuses)
            if (!selectedStatuses.has('All') && selectedStatuses.size > 0) {
                const statusList = Array.from(selectedStatuses);
                dataToExport = dataToExport.filter(participant => {
                    const status = participant.Status || '';
                    return statusList.includes(status);
                });
                filename = `meetup-participants-${statusList.join('-')}-${dateString}.csv`;
            }
            
            // If showing only group participants, export only those
            if (showOnlyGroup) {
                dataToExport = dataToExport.filter(participant => {
                    const name = getParticipantName(participant);
                    return Array.from(groupParticipants).some(groupName => 
                        groupName.toLowerCase() === name.toLowerCase()
                    );
                });
                filename = `meetup-participants-group-${dateString}.csv`;
            }
            
            if (dataToExport.length === 0) {
                alert('No participants match the current filters');
                return;
            }
            
            console.log('About to export', dataToExport.length, 'rows');
            const headers = Object.keys(dataToExport[0]);
            console.log('Headers:', headers);
            
            // Create CSV content
            let csvContent = headers.join(',') + '\n';
            dataToExport.forEach(row => {
                const values = headers.map(header => {
                    const value = row[header] || '';
                    // Escape quotes and wrap in quotes if contains comma
                    return value.includes(',') ? `"${value.replace(/"/g, '""')}"` : value;
                });
                csvContent += values.join(',') + '\n';
            });
            
            // Download CSV
            console.log('Creating CSV download with filename:', filename);
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            console.log('Triggering download...');
            link.click();
            document.body.removeChild(link);
            console.log('CSV export completed');
        }

        //getParticipantsButton.addEventListener('click', getMeetupParticipants);
        

        // View switching event listeners - Use localsite.js hash functions
        document.getElementById('column-view-btn').addEventListener('click', () => {
            goHash({}, ['display']); // Remove display parameter
        });
        document.getElementById('table-view-btn').addEventListener('click', () => {
            goHash({ display: 'table' }, []); // Set display=table
        });
        document.getElementById('gallery-view-btn').addEventListener('click', () => {
            goHash({ display: 'gallery' }, []); // Set display=gallery
        });
        
        // Team filter event listener (now handled in generateTeamLegend function)
        
        // Sort event listeners
        document.getElementById('sort-toggle').addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            toggleSortDropdown();
        });
        document.getElementById('close-sort').addEventListener('click', () => {
            document.getElementById('sort-dropdown').style.display = 'none';
        });
        
        // Status event listeners
        document.getElementById('status-toggle').addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            toggleStatusDropdown();
        });
        document.getElementById('close-status').addEventListener('click', () => {
            document.getElementById('status-dropdown').style.display = 'none';
        });
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', function(e) {
            const sortDropdown = document.getElementById('sort-dropdown');
            const sortToggle = document.getElementById('sort-toggle');
            const statusDropdown = document.getElementById('status-dropdown');
            const statusToggle = document.getElementById('status-toggle');
            
            if (!sortDropdown.contains(e.target) && !sortToggle.contains(e.target)) {
                sortDropdown.style.display = 'none';
            }
            
            if (!statusDropdown.contains(e.target) && !statusToggle.contains(e.target)) {
                statusDropdown.style.display = 'none';
            }
            
            // Close participant menu dropdowns when clicking outside
            if (!e.target.closest('.columns-menu')) {
                document.querySelectorAll('.columns-menu-dropdown').forEach(dropdown => {
                    dropdown.style.display = 'none';
                });
            }
        });
        
        // Group participants event listeners
        const groupInput = document.getElementById('group');
        groupInput.addEventListener('input', function(e) {
            const value = e.target.value;
            // Process input when comma is typed, but preserve the comma
            if (value.endsWith(',')) {
                // Extract the part before the comma for processing
                const beforeComma = value.substring(0, value.length - 1);
                if (beforeComma.trim()) {
                    // Process the names before the comma
                    const names = beforeComma.split(',').map(name => name.trim()).filter(name => name);
                    names.forEach(name => {
                        if (name) groupParticipants.add(name);
                    });
                    
                    // Validate names against dataset
                    validateGroupNames(names);
                    
                    // Save to storage and update highlighting
                    saveGroupParticipants();
                    updateGroupCount();
                    updateGroupHighlighting();
                    
                    // Note: URL hash parameters for groups have been discontinued
                }
            }
        });
        
        groupInput.addEventListener('keydown', function(e) {
            // Process input when Enter is pressed
            if (e.key === 'Enter') {
                e.preventDefault();
                processGroupInput();
            }
        });
        
        groupInput.addEventListener('blur', function() {
            // Process input when field loses focus
            processGroupInput();
            // Only scroll to the right if already near the right edge
            if (groupInput.scrollLeft >= groupInput.scrollWidth - groupInput.clientWidth - 10) {
                setTimeout(() => scrollGroupInputToRight(), 10); // Very fast, 10th of 10th
            }
        });
        
        document.getElementById('group-toggle').addEventListener('click', toggleGroupFilter);
        
        // Group toggle text editing functionality
        const groupToggleText = document.getElementById('group-toggle-text');
        
        // Make toggle text editable on double-click
        groupToggleText.addEventListener('dblclick', function() {
            const currentText = this.textContent;
            this.contentEditable = true;
            this.focus();
            
            // Select all text for easy editing
            const range = document.createRange();
            range.selectNodeContents(this);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
        });
        
        // Save changes when editing is complete
        groupToggleText.addEventListener('blur', function() {
            this.contentEditable = false;
            const newText = this.textContent.trim();
            
            if (newText) {
                // Save the new text based on current toggle state
                if (showOnlyGroup) {
                    localStorage.setItem(getListStorageKey('groupToggleActiveText'), newText);
                } else {
                    localStorage.setItem(getListStorageKey('groupToggleInactiveText'), newText);
                }
                console.log(` Saved group toggle text: "${newText}" for ${showOnlyGroup ? 'active' : 'inactive'} state`);
            } else {
                // Restore previous text if empty
                updateGroupToggleUI();
            }
        });
        
        // Save changes when Enter is pressed
        groupToggleText.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.blur(); // Trigger blur event to save
            }
            if (e.key === 'Escape') {
                e.preventDefault();
                // Restore original text and exit editing
                updateGroupToggleUI();
                this.contentEditable = false;
            }
        });
        
        // Raw data event listeners
        document.getElementById('apply-raw-data').addEventListener('click', applyRawDataChanges);
        document.getElementById('revert-raw-data').addEventListener('click', revertRawData);
        document.getElementById('raw-data-close').addEventListener('click', closeRawData);
        
        // Hide UI elements when changing to a new list
        function hideListDisplayElements() {
            // Hide team legend panel
            const teamLegend = document.getElementById('team-legend');
            if (teamLegend) {
                teamLegend.style.display = 'none';
            }
            
            // Hide view controls
            const viewControls = document.querySelector('.view-controls');
            if (viewControls) {
                viewControls.style.display = 'none';
            }
            
            // Hide table view and other views
            const tableView = document.getElementById('table-view');
            const columnView = document.getElementById('column-view');
            const galleryView = document.getElementById('gallery-view');
            
            if (tableView) tableView.style.display = 'none';
            if (columnView) columnView.style.display = 'none';
            if (galleryView) galleryView.style.display = 'none';
            
            // Clear all view containers immediately when list changes
            const columnGrid = document.getElementById('participants-column-grid');
            const tableBody = document.querySelector('#participants-table tbody');
            const galleryGrid = document.getElementById('participants-gallery-grid');
            const tableContainer = document.getElementById('participants-table-container');
            const loadStatus = document.getElementById('loadStatus');
            
            if (columnGrid) columnGrid.innerHTML = '';
            if (tableBody) tableBody.innerHTML = '';
            if (galleryGrid) galleryGrid.innerHTML = '';
            if (tableContainer) tableContainer.innerHTML = '';
            if (loadStatus) {
                loadStatus.innerHTML = '';
                loadStatus.style.display = 'none';
            }
            
            // Clear data arrays
            allRowsData = [];
            filteredData = [];
            
            console.log('List display elements hidden and data cleared');
        }
        
        // Show UI elements when new list loads successfully
        function showListDisplayElements() {
            // Show view controls
            const viewControls = document.querySelector('.view-controls');
            if (viewControls) {
                viewControls.style.display = 'flex';
            }
            
            // Show the current view based on currentView setting
            const tableView = document.getElementById('table-view');
            const columnView = document.getElementById('column-view');
            const galleryView = document.getElementById('gallery-view');
            
            // Hide all views first
            if (tableView) tableView.style.display = 'none';
            if (columnView) columnView.style.display = 'none';
            if (galleryView) galleryView.style.display = 'none';
            
            // Show the current view
            if (currentView === 'table' && tableView) {
                tableView.style.display = 'block';
            } else if (currentView === 'gallery' && galleryView) {
                galleryView.style.display = 'block';
            } else if (columnView) {
                // Default to column view
                columnView.style.display = 'block';
            }
            
            // Team legend will be shown by generateTeamLegend if there's a Team column
            
            // Show group control only for modelteam list (if available in fileSelect)
            const groupControl = document.getElementById('group-control');
            const currentList = getHash().list;
            if (groupControl) {
                // Check if modelteam option exists in fileSelect before showing group control
                const isGroupList = Array.from(fileSelect.options).find(option => option.value === 'modelteam');
                if (currentList === 'modelteam' && isGroupList) {
                    groupControl.style.display = 'block';
                } else {
                    groupControl.style.display = 'none';
                }
            }
            
            // Update group snapshot info after elements are shown (only for modelteam if available)
            const isGroupList = Array.from(fileSelect.options).find(option => option.value === 'modelteam');
            if (currentList === 'modelteam' && isGroupList) {
                waitForElm('#group-snapshot-info').then(() => {
                    updateGroupSnapshotInfo();
                });
            }
            
            console.log('List display elements shown');
        }
        
        // Update menu visibility based on current list
        function updateMenuVisibility() {
            const listParam = getHash().list;
            const allFeedsToggle = document.getElementById('list-feeds-toggle');
            
            if (allFeedsToggle) {
                // Hide "All Lists" option when already viewing all lists
                if (listParam === 'all' || fileSelect.value === 'all') {
                    allFeedsToggle.style.display = 'none';
                } else {
                    allFeedsToggle.style.display = 'block';
                }
            }
        }
        
        // Clear all filters when changing lists
        function clearAllFilters() {
            // Clear team filter
            currentTeamFilter = null;
            localStorage.removeItem(getListStorageKey('participantsTeamFilter'));
            
            // Clear status filter - reset to "All"
            selectedStatuses.clear();
            selectedStatuses.add('All');
            localStorage.setItem(getListStorageKey('participantsStatusFilter'), JSON.stringify(['All']));
            
            // Clear group participants filter
            showOnlyGroup = false;
            localStorage.setItem(getListStorageKey('showOnlyGroup'), 'false');
            const groupInput = document.getElementById('group');
            if (groupInput) {
                groupInput.value = '';
            }
            groupParticipants = new Set();
            updateGroupCount();
            
            // Hide validation message
            hideGroupValidationMessage();
            
            // Clear URL hash parameters (sortby/sortorder/group are not in hash anymore)
            setURLHashParam('status', null);
            
            // Reset team legend flag to allow regeneration
            initialTeamLegendGenerated = false;
            
            console.log('All filters cleared for new list selection');
        }
        
        
        // File selection handling functions
        function handleFileDropdownChange() {
            const value = fileSelect.value;
            
            console.log('DROPDOWN CHANGE: Selected value:', value, '- updating hash');
            
            // Only update hash - let hashchange event handle all processing
            if (value === 'custom') {
                // Show custom file selection without hash update
                customFileSection.style.display = 'block';
                selectedFile = null;
            } else {
                // Hide custom file selection and update hash
                customFileSection.style.display = 'none';
                
                // Update hash parameter - hashchange event will handle everything else
                updateListHashParam(value);
                
                // Save selection to storage
                saveFileSelectionToStorage(value, STORAGE_KEY);
            }
        }
        
        function updateParticipantListTitle(customTitle = null) {
            const participantListTitle = document.getElementById('list-title');
            let titleText;
            
            if (customTitle) {
                // Use custom title provided
                titleText = customTitle;
                participantListTitle.textContent = ` ${customTitle}`;
            } else {
                // Check if there's a list parameter in the hash
                const listParam = getHash().list;
                if (listParam) {
                    // Special case for geo - use "Location Visits" title
 
                    // Look for matching option in dropdown to get proper title
                    const matchingOption = Array.from(fileSelect.options).find(option => option.value === listParam);
                    if (matchingOption && matchingOption.textContent) {
                        titleText = matchingOption.textContent;
                        participantListTitle.textContent = ` ${matchingOption.textContent}`;
                        // Update dropdown selection to match
                        fileSelect.value = listParam;
                    } else {
                        // List parameter not available in this site's fileSelect options
                        // Just use the parameter as title without changing dropdown
                        titleText = listParam;
                        participantListTitle.textContent = ` ${listParam}`;
                        console.log('List param not found in fileSelect options:', listParam, 'keeping original selection');
                        
                        // Display user-visible message about unavailable list
                        appendStatusMessage(` List "${listParam}" is not available in the current dropdown options. Showing default selection instead.`, 'info');
                    }

                } else {
                    const selectedOption = fileSelect.options[fileSelect.selectedIndex];
                    if (selectedOption && selectedOption.textContent && selectedOption.value !== 'custom') {
                        // Use the title from the selected option
                        titleText = selectedOption.textContent;
                        participantListTitle.textContent = ` ${selectedOption.textContent}`;
                    } else {
                        // Default title
                        titleText = 'Participants List';
                        participantListTitle.textContent = ' Participants List';
                    }
                }
            }
            
            // Update browser title
            document.title = titleText;
        }
        
        // Show/hide header based on list parameter
        function updateHeaderVisibility() {
            const listParam = getHash().list;
            const header = document.getElementById('teamHeader');
            
            if (header) {
                // Only show header when list=modelteam AND modelteam option exists in fileSelect
                const fileSelectElement = document.getElementById('fileSelect');
                let isGroupList = false;
                
                if (fileSelectElement && fileSelectElement.options) {
                    isGroupList = Array.from(fileSelectElement.options).find(option => option.value === 'modelteam');
                }
                
                const shouldShowHeader = (listParam === 'modelteam') && isGroupList;
                header.style.display = shouldShowHeader ? 'block' : 'none';
                console.log(' Header visibility updated:', shouldShowHeader ? 'visible' : 'hidden', 
                           'for list:', listParam, 'modelteam available:', !!isGroupList, 
                           'fileSelect options count:', fileSelectElement?.options?.length || 0);
            } else {
                console.error(' teamHeader element not found!');
            }
        }
        
        // Update both header visibility and title when hash changes
        function updateUIForHashChange() {
            updateHeaderVisibility();
            updateParticipantListTitle();
            
            // Clear status messages when list changes
            statusMessages.innerHTML = '';
        }
        
        function handleCustomFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Store the file object
            customFiles[file.name] = file;
            selectedFile = file;
            
            // Add the new file to the dropdown
            const fileName = file.name;
            const fileValue = `custom_${fileName}`;
            
            // Check if this file is already in the dropdown
            let existingOption = Array.from(fileSelect.options).find(option => option.value === fileValue);
            if (!existingOption) {
                // Add new option before "Choose File..."
                const newOption = document.createElement('option');
                newOption.value = fileValue;
                newOption.textContent = fileName;
                newOption.selected = true;
                
                // Insert before the "Choose File..." option (last option)
                fileSelect.insertBefore(newOption, fileSelect.lastElementChild);
            } else {
                // Select the existing option
                existingOption.selected = true;
            }
            
            // Update display
            const fileSize = (file.size / 1024 / 1024).toFixed(2);
            const fileType = file.name.toLowerCase().endsWith('.csv') ? 'CSV' : 'Excel';
            fileDisplay.innerHTML = `
                <div class="file-info">
                    <div class="file-name">${fileName}</div>
                    <div class="file-details">${fileType} file, ${fileSize} MB</div>
                </div>
            `;
            
            // Hide custom file section
            customFileSection.style.display = 'none';
        }
        
        // Hash parameter utility functions are now available from list.js
        // getURLHashParam, setURLHashParam, updateListHashParam
        
        
        async function initializeFileSelection() {
            // Use shared function for Google Sheet loading and initialization
            const selectedOption = await initializeFileSelectionWithGoogleSheet(fileSelect, 'list', STORAGE_KEY);
            
            // Add "All Lists" option after dynamic options are loaded
            addAllListsOption();
            
            // Add geo option for location visits
            // Saving for a sample dataset
            // addGeoOption();
            
            // Check for geo-related domains or hash parameter
            const listParam = getHash().list;
            const shouldDefaultToGeo = !listParam && isGeoSite();
            
            if (listParam === 'all') {
                fileSelect.value = 'all';
                selectedFile = 'all';
            } else {
                selectedFile = selectedOption.getAttribute('data-url') || selectedOption.value;
            }
            
            // Update the participant list title with the selected option
            updateParticipantListTitle();
            
            // Update list select visibility based on geo parameter
            updateListSelectVisibility();
            
            // Add event listeners
            fileSelect.addEventListener('change', handleFileDropdownChange);
            fileInput.addEventListener('change', handleCustomFileSelect);
            
            // Make file display clickable
            fileDisplay.addEventListener('click', () => {
                fileInput.click();
            });
        }
        
        function addAllListsOption() {
            // Check if "All Lists" option already exists
            const existingAllOption = Array.from(fileSelect.options).find(option => option.value === 'all');
            if (existingAllOption) return;
            
            // Add "All Lists" option at the top (first position)
            const allListsOption = document.createElement('option');
            allListsOption.value = 'all';
            allListsOption.textContent = 'All Lists';
            allListsOption.setAttribute('data-url', 'all');
            
            // Insert as the first option
            fileSelect.insertBefore(allListsOption, fileSelect.firstChild);
        }
        
        function addGeoOption() {
            // Check if "Location Visits" option already exists
            const existingGeoOption = Array.from(fileSelect.options).find(option => option.value === 'geo');
            if (existingGeoOption) return;
            
            // Add "Location Visits" option
            const geoOption = document.createElement('option');
            geoOption.value = 'geo';
            geoOption.textContent = 'Location Visits';
            geoOption.setAttribute('data-url', 'map/cities.csv');
            
            // Insert after "All Lists" option if it exists, otherwise at the beginning
            const allListsOption = Array.from(fileSelect.options).find(option => option.value === 'all');
            if (allListsOption) {
                fileSelect.insertBefore(geoOption, allListsOption.nextSibling);
            } else {
                fileSelect.insertBefore(geoOption, fileSelect.firstChild);
            }
        }
        
        function addModelteamOption() {
            // Check if "modelteam" option already exists
            const existingModelteamOption = Array.from(fileSelect.options).find(option => option.value === 'modelteam');
            if (existingModelteamOption) return;
            
            // Don't add Model Earth Team option for geo sites
            if (isGeoSite()) {
                return;
            }
            
            // Add "Model Earth Team" option (from lists.csv line 4)
            const modelteamOption = document.createElement('option');
            modelteamOption.value = 'modelteam';
            modelteamOption.textContent = 'Model Earth Team';
            modelteamOption.setAttribute('data-url', 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRh5-bIR4hC1f9H3NtDCNT19hZXnqz8WRrBwTuLGnZiA5PWhFILUv2nS2FKE2TZ4dZ-RnJkZwHx1t2Y/pub?gid=1054734503&single=true&output=csv');
            
            // Insert after other options but before "Choose File..."
            const chooseFileOption = Array.from(fileSelect.options).find(option => option.value === 'custom');
            if (chooseFileOption) {
                fileSelect.insertBefore(modelteamOption, chooseFileOption);
            } else {
                fileSelect.appendChild(modelteamOption);
            }
        }
        
        function updateListSelectVisibility() {
            const listParam = getHash().list;
            const pageControls = document.getElementById('pageControls');
            const breadcrumb = document.querySelector('.breadcrumb');
            const addVisitBtn = document.getElementById('add-visit-btn');
            const mapBtn = document.getElementById('map-btn');
            const insightsBtn = document.getElementById('insights-btn');
            const signInBtn = document.getElementById('sign-in-btn');
            
            if (listParam === 'geo') {
                pageControls.style.display = 'flex';
                if (breadcrumb) {
                    breadcrumb.style.display = 'none';
                }
                if (addVisitBtn) {
                    addVisitBtn.style.display = 'inline-block';
                }
                if (mapBtn) {
                    mapBtn.style.display = 'inline-block';
                }
                if (signInBtn) {
                    signInBtn.style.display = 'inline-block';
                }
            } else {
                pageControls.style.display = 'flex';
                if (breadcrumb) {
                    breadcrumb.style.display = 'block';
                }
                if (addVisitBtn) {
                    addVisitBtn.style.display = 'none';
                }
                if (mapBtn) {
                    mapBtn.style.display = 'none';
                }
                if (signInBtn) {
                    signInBtn.style.display = 'none';
                }
            }
            
            // Always show insights button for all lists
            if (insightsBtn) {
                insightsBtn.style.display = 'inline-block';
            }
        }
        
        // Insights toggle functionality
        function toggleInsights() {
            const aiInsights = document.getElementById('aiInsights');
            const insightsBtn = document.getElementById('insights-btn');
            // Use getComputedStyle to check actual visibility since we use CSS !important
            const computedStyle = window.getComputedStyle(aiInsights);
            const isCurrentlyVisible = computedStyle.display === 'block';
            
            if (isCurrentlyVisible) {
                // Hide insights
                aiInsights.style.setProperty('display', 'none', 'important');
                insightsBtn.textContent = 'Insights';
                removeURLHashParam('insights');
            } else {
                // Show insights
                aiInsights.style.setProperty('display', 'block', 'important');
                insightsBtn.textContent = 'Hide Insights';
                setURLHashParam('insights', 'all');
            }
        }
        
        // Remove URL hash parameter (uses existing setURLHashParam)
        function removeURLHashParam(key) {
            setURLHashParam(key, null);
        }
        
        // Check for insights parameter in URL and show/hide accordingly
        function checkInsightsFromURL() {
            const insightsParam = getHash().insights;
            const aiInsights = document.getElementById('aiInsights');
            const insightsBtn = document.getElementById('insights-btn');
            
            // Ensure elements exist before trying to manipulate them
            if (!aiInsights) {
                console.warn('aiInsights element not found');
                return;
            }
            
            if (insightsParam === 'all') {
                aiInsights.style.setProperty('display', 'block', 'important');
                if (insightsBtn) {
                    insightsBtn.textContent = 'Hide Insights';
                }
                console.log('Insights panel shown from URL parameter');
            } else {
                aiInsights.style.setProperty('display', 'none', 'important');
                if (insightsBtn) {
                    insightsBtn.textContent = 'Insights';
                }
                console.log('Insights panel hidden (no URL parameter)');
            }
        }
        
        // Restore saved view state
        function restoreViewState() {
            // Restore the saved view mode (currentView is already loaded from localStorage)
            switchView(currentView);
        }
        
        // 3-dot menu functionality
        function toggleMenu() {
            const dropdown = document.getElementById('menu-dropdown');
            const button = document.getElementById('menu-toggle');
            const isVisible = dropdown.style.display === 'block';
            
            if (isVisible) {
                dropdown.style.display = 'none';
                button.classList.remove('active');
            } else {
                dropdown.style.display = 'block';
                button.classList.add('active');
            }
        }
        
        function toggleFullscreen() {
            isFullscreen = !isFullscreen;
            localStorage.setItem('isFullscreen', JSON.stringify(isFullscreen));
            
            const fullscreenText = document.getElementById('fullscreen-text');
            
            if (isFullscreen) {
                // Apply fullscreen to the body/container to include file selection
                document.body.classList.add('fullscreen-mode');
                fullscreenText.textContent = 'Exit Fullscreen';
                // Allow scrolling in fullscreen mode
                document.body.style.overflow = 'auto';
            } else {
                document.body.classList.remove('fullscreen-mode');
                fullscreenText.textContent = 'View Fullscreen';
                document.body.style.overflow = 'auto';
            }
            
            // Close menu
            document.getElementById('menu-dropdown').style.display = 'none';
            document.getElementById('menu-toggle').classList.remove('active');
        }
        
        function toggleCondensed() {
            isCondensed = !isCondensed;
            localStorage.setItem('isCondensed', JSON.stringify(isCondensed));
            
            const card = document.getElementById('participants-table-card');
            const condensedText = document.getElementById('condensed-text');
            
            if (isCondensed) {
                card.classList.add('condensed-mode');
                condensedText.textContent = 'Expand Layout';
            } else {
                card.classList.remove('condensed-mode');
                condensedText.textContent = 'Condense Layout';
            }
            
            // Close menu
            document.getElementById('menu-dropdown').style.display = 'none';
            document.getElementById('menu-toggle').classList.remove('active');
        }
        
        function parseCSVRobust(csvText) {
            // Robust CSV parser that handles quoted fields with newlines, escaped quotes, and proper field separation
            // This prevents line returns within quoted field values from being treated as new rows
            const rows = [];
            let current = '';
            let inQuotes = false;
            let currentRow = [];
            let currentField = '';
            
            for (let i = 0; i < csvText.length; i++) {
                const char = csvText[i];
                const nextChar = csvText[i + 1];
                
                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        // Handle escaped quotes ("" inside quoted field)
                        currentField += '"';
                        i++; // Skip next quote
                    } else {
                        // Toggle quote state
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    // End of field
                    currentRow.push(currentField.trim());
                    currentField = '';
                } else if ((char === '\n' || char === '\r\n') && !inQuotes) {
                    // End of row (only if not inside quotes)
                    currentRow.push(currentField.trim());
                    if (currentRow.length > 0 && currentRow.some(field => field !== '')) {
                        rows.push(currentRow);
                    }
                    currentRow = [];
                    currentField = '';
                    
                    // Skip \r if we're at \r\n
                    if (char === '\r' && nextChar === '\n') {
                        i++;
                    }
                } else if (char === '\r' && !inQuotes) {
                    // Handle standalone \r as row separator
                    currentRow.push(currentField.trim());
                    if (currentRow.length > 0 && currentRow.some(field => field !== '')) {
                        rows.push(currentRow);
                    }
                    currentRow = [];
                    currentField = '';
                } else {
                    // Regular character or newline inside quotes
                    currentField += char;
                }
            }
            
            // Handle last field and row
            if (currentField !== '' || currentRow.length > 0) {
                currentRow.push(currentField.trim());
                if (currentRow.length > 0 && currentRow.some(field => field !== '')) {
                    rows.push(currentRow);
                }
            }
            
            return rows;
        }

        function showAllLists() {
            // Show loading status for list of lists
            document.getElementById('loadStatus').innerHTML = '<div class="loading-message">Loading list of lists...</div>';
            document.getElementById('loadStatus').style.display = 'block';
            
            // Load and display the meta-list Google Sheet with all feeds
            const masterSheetUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSxfv7lxikjrmro3EJYGE_134vm5HdDszZKt4uKswHhsNJ_-afSaG9RoA4oeNV656r4mTuG3wTu38pM/pub?output=csv';
            
            // Clear current data immediately to prevent flash
            const tableContainer = document.getElementById('participants-table-container');
            const participantsTableCard = document.getElementById('participants-table-card');
            
            // Hide the table card first to prevent flash
            if (participantsTableCard) {
                participantsTableCard.style.display = 'none';
            }
            
            // Clear table content and show loading state
            if (tableContainer) {
                tableContainer.innerHTML = '<div class="loading-state">Loading feeds list...</div>';
            }
            
            // Load the master sheet data
            fetch(masterSheetUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(csvText => {
                    // Check if we got HTML instead of CSV (redirect or error)
                    if (csvText.trim().toLowerCase().startsWith('<html')) {
                        throw new Error('Received HTML instead of CSV data');
                    }
                    
                    // Parse CSV data with robust parser that handles newlines in quoted fields
                    const rows = parseCSVRobust(csvText);
                    if (rows.length === 0) {
                        throw new Error('No data found in CSV');
                    }
                    
                    // First row contains headers
                    const headers = rows[0];
                    const feedsData = [];
                    
                    // Check if this is a geo site for filtering
                    const isGeoSiteCheck = isGeoSite();
                    const allowedGeoOptions = ['geo', 'film-scouting', 'nasa'];
                    
                    // Track skipped binary files for reporting
                    const skippedBinaryFiles = [];
                    
                    // Parse data rows
                    for (let i = 1; i < rows.length; i++) {
                        const values = rows[i];
                        if (values.length > 0) {
                            const feedEntry = {};
                            headers.forEach((header, index) => {
                                feedEntry[header] = values[index] || '';
                            });
                            
                            // Filter entries for geo sites (check the 'List' field)
                            if (isGeoSiteCheck) {
                                const listValue = feedEntry['List'] || feedEntry['list'];
                                if (!allowedGeoOptions.includes(listValue)) {
                                    continue; // Skip this entry for geo sites
                                }
                            }
                            
                            // Filter out large binary/non-data files to prevent CPU overload
                            const url = feedEntry['URL'] || '';
                            const binaryExtensions = ['.tiff', '.tif', '.hdf5', '.h5', '.pdf', '.png', '.jpg', '.jpeg', '.zip', '.tar', '.gz'];
                            const isBinaryFile = binaryExtensions.some(ext => url.toLowerCase().includes(ext));
                            
                            if (isBinaryFile) {
                                const title = feedEntry['Title'] || feedEntry['List'] || 'Unknown';
                                skippedBinaryFiles.push({ title, url: url.split('/').pop() });
                                console.log(`Skipping binary file: ${title} (${url})`);
                                continue; // Skip binary files to prevent processing overload
                            }
                            
                            feedsData.push(feedEntry);
                        }
                    }
                    
                    // Display the feeds data using the existing display system
                    currentData = feedsData;
                    // Reset team legend flag for new data
                    initialTeamLegendGenerated = false;
                    displayTableLayout(feedsData, 'All Available Lists');
                    
                    // Update the page title
                    //document.title = 'All Available Lists';
                    
                    // Show UI elements after successful feeds load
                    showListDisplayElements();
                    
                    // Update status to show completion
                    document.getElementById('loadStatus').innerHTML = `<div class="success-message">Loaded ${feedsData.length} lists.</div>`;
                    document.getElementById('loadStatus').style.display = 'block';
                    
                    // Report skipped binary files if any
                    if (skippedBinaryFiles.length > 0) {
                        const skippedList = skippedBinaryFiles.map(item => ` ${item.title} (${item.url})`).join('<br>');
                        showTopMessage(
                            `<strong>Binary Files Excluded</strong><br>` +
                            `${skippedBinaryFiles.length} binary files were excluded from the list to prevent performance issues:<br><br>` +
                            `${skippedList}<br><br>` +
                            `<small>These files cannot be processed as tabular data.</small>`,
                            'warning',
                            10000
                        );
                    }
                    
                    // Update URL hash to list=all
                    updateListHashParam('all');
                    
                    // Close menu
                    document.getElementById('menu-dropdown').style.display = 'none';
                    document.getElementById('menu-toggle').classList.remove('active');
                })
                .catch(error => {
                    console.error('Error loading feeds list:', error);
                    if (tableContainer) {
                        tableContainer.innerHTML = '<div class="error-state">Error loading feeds list. Please try again.<br><small>Error: ' + error.message + '</small></div>';
                    }
                    
                    // Show error in status
                    document.getElementById('loadStatus').innerHTML = '<div class="error-message">Error loading list of lists</div>';
                    document.getElementById('loadStatus').style.display = 'block';
                    
                    // Update URL hash to list=all even on error to maintain state
                    updateListHashParam('all');
                });
        }

        async function refreshListsCSV() {
            const SHEET_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSxfv7lxikjrmro3EJYGE_134vm5HdDszZKt4uKswHhsNJ_-afSaG9RoA4oeNV656r4mTuG3wTu38pM/pub?output=csv';
            const refreshItem = document.getElementById('refresh-csv-toggle');
            const refreshText = refreshItem.querySelector('span');
            const originalText = refreshText.textContent;
            
            // Show loading message in top area
            showTopMessage(
                '<strong>Refreshing Lists.csv</strong><br>Downloading latest data from Google Sheets and comparing with local file...', 
                'warning', 
                0 // Don't auto-hide while processing
            );
            
            // Function to parse CSV text into array of objects using robust parser
            function parseCSV(csvText) {
                const rows = parseCSVRobust(csvText);
                if (rows.length === 0) return [];
                
                const headers = rows[0];
                return rows.slice(1).map(values => {
                    const obj = {};
                    headers.forEach((header, index) => {
                        obj[header] = values[index] || '';
                    });
                    return obj;
                });
            }
            
            // Function to compare CSV data and find changes
            function compareCSVData(oldData, newData) {
                const changes = {
                    added: [],
                    removed: [],
                    modified: []
                };
                
                // Create maps for easier comparison (using List as unique identifier)
                const oldMap = new Map(oldData.map(row => [row.List, row]));
                const newMap = new Map(newData.map(row => [row.List, row]));
                
                // Find added rows
                for (const [list, row] of newMap) {
                    if (!oldMap.has(list)) {
                        changes.added.push(row);
                    }
                }
                
                // Find removed and modified rows
                for (const [list, oldRow] of oldMap) {
                    if (!newMap.has(list)) {
                        changes.removed.push(oldRow);
                    } else {
                        const newRow = newMap.get(list);
                        // Check if any fields changed
                        const fieldsChanged = Object.keys(oldRow).some(key => 
                            oldRow[key] !== newRow[key]
                        );
                        if (fieldsChanged) {
                            changes.modified.push({
                                old: oldRow,
                                new: newRow,
                                list: list
                            });
                        }
                    }
                }
                
                return changes;
            }
            
            try {
                // Show loading state
                refreshText.textContent = 'Refreshing...';
                refreshItem.style.opacity = '0.6';
                
                // Load current cached data for comparison
                let currentCSVText = '';
                let currentData = [];
                
                try {
                    // Try to load from local file first
                    const currentResponse = await fetch('./lists.csv');
                    if (currentResponse.ok) {
                        currentCSVText = await currentResponse.text();
                        currentData = parseCSV(currentCSVText);
                    }
                } catch (fileError) {
                    // Fallback to localStorage if file not accessible
                    const fallbackCSV = localStorage.getItem('fallbackCSV');
                    if (fallbackCSV) {
                        currentCSVText = fallbackCSV;
                        currentData = parseCSV(currentCSVText);
                    }
                }
                
                const beforeRowCount = currentData.length;
                console.log(`Current cached list has ${beforeRowCount} rows`);
                
                console.log('Manually refreshing lists.csv from Google Sheets...');
                const response = await fetch(SHEET_URL);
                
                if (!response.ok) {
                    throw new Error(`Google Sheets fetch failed: ${response.status} ${response.statusText}`);
                }
                
                const csvText = await response.text();
                const newData = parseCSV(csvText);
                const afterRowCount = newData.length;
                
                // Compare data and generate change report
                const changes = compareCSVData(currentData, newData);
                const totalChanges = changes.added.length + changes.removed.length + changes.modified.length;
                
                // Log detailed comparison results
                console.log(`\n=== CSV Refresh Results ===`);
                console.log(`Before: ${beforeRowCount} rows`);
                console.log(`After: ${afterRowCount} rows`);
                console.log(`Net change: ${afterRowCount - beforeRowCount > 0 ? '+' : ''}${afterRowCount - beforeRowCount} rows`);
                console.log(`Total changes: ${totalChanges}`);
                
                if (changes.added.length > 0) {
                    console.log(`\n Added (${changes.added.length}):`);
                    changes.added.forEach(row => {
                        console.log(`  + ${row.List}: ${row.Title || 'No title'}`);
                    });
                }
                
                if (changes.removed.length > 0) {
                    console.log(`\n Removed (${changes.removed.length}):`);
                    changes.removed.forEach(row => {
                        console.log(`  - ${row.List}: ${row.Title || 'No title'}`);
                    });
                }
                
                if (changes.modified.length > 0) {
                    console.log(`\n Modified (${changes.modified.length}):`);
                    changes.modified.forEach(change => {
                        console.log(`  ~ ${change.list}: ${change.new.Title || 'No title'}`);
                        // Log specific field changes
                        Object.keys(change.old).forEach(key => {
                            if (change.old[key] !== change.new[key]) {
                                console.log(`    ${key}: "${change.old[key]}"  "${change.new[key]}"`);
                            }
                        });
                    });
                }
                
                if (totalChanges === 0) {
                    console.log(`\n No changes detected`);
                }
                console.log(`=========================\n`);

                // Save to local file using Rust API endpoint
                try {
                    const saveResponse = await fetch('http://localhost:8081/api/files/csv', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            filename: 'lists.csv',
                            content: csvText
                        })
                    });
                    
                    if (saveResponse.ok) {
                        const result = await saveResponse.json();
                        console.log('Successfully saved CSV to ./lists.csv:', result);
                        
                        // Show detailed success message with change count
                        const changeText = totalChanges > 0 ? ` (${totalChanges} changes)` : ' (no changes)';
                        refreshText.textContent = `Refreshed ${changeText}`;
                        
                        // Show success message in top area
                        const changeMessage = totalChanges > 0 ? 
                            `<strong>Lists.csv Successfully Refreshed</strong><br>Updated with ${totalChanges} changes from Google Sheets and saved to the server.` :
                            `<strong>Lists.csv Successfully Refreshed</strong><br>No changes detected. File is up to date with Google Sheets.`;
                        
                        showTopMessage(changeMessage, 'success', 5000);
                        
                        // Always reload dropdown options from updated lists.csv (even if no changes detected)
                        if (typeof loadGoogleSheetConfig === 'function') {
                            console.log('Reloading dropdown options from updated lists.csv...');
                            
                            // Clear any potential browser cache for lists.csv by adding cache-busting parameter
                            const timestamp = Date.now();
                            console.log('Cache-busting timestamp:', timestamp);
                            
                            await loadGoogleSheetConfig(fileSelect, 'list');
                            console.log('Dropdown options reloaded successfully');
                        }
                        
                        // Show success feedback briefly
                        setTimeout(() => {
                            refreshText.textContent = originalText;
                        }, 4000); // Extended time to read change info
                        
                        // Close menu
                        document.getElementById('menu-dropdown').style.display = 'none';
                        document.getElementById('menu-toggle').classList.remove('active');
                        
                    } else {
                        const error = await saveResponse.json();
                        throw new Error(error.error || 'Server save failed');
                    }
                    
                } catch (saveError) {
                    console.error('Failed to save CSV file:', saveError);
                    
                    // Check if this is a connection refused error (Rust server not running)
                    if (saveError.message.includes('Failed to fetch') || saveError.toString().includes('ERR_CONNECTION_REFUSED')) {
                        showTopMessage(
                            '<strong>Rust API Server Not Running</strong><br>' +
                            'The Rust server at localhost:8081 is not available. ' +
                            'To start it, run:<br>' +
                            '<code style="background: rgba(0,0,0,0.1); padding: 2px 4px; border-radius: 3px;">cd team && cargo run --bin partner_tools -- serve</code><br>' +
                            'CSV data has been cached in browser storage as a fallback.',
                            'error',
                            15000 // Show for 15 seconds
                        );
                    } else {
                        showTopMessage(
                            '<strong>Failed to Save CSV</strong><br>' +
                            'Error: ' + saveError.message + '<br>' +
                            'CSV data has been cached in browser storage as a fallback.',
                            'error',
                            10000
                        );
                    }
                    
                    // Fallback to localStorage
                    localStorage.setItem('fallbackCSV', csvText);
                    localStorage.setItem('fallbackCSVTimestamp', Date.now().toString());
                    
                    console.log('Stored CSV in localStorage as fallback');
                    
                    // Show cached message with change count
                    const changeText = totalChanges > 0 ? ` (${totalChanges} changes)` : ' (no changes)';
                    refreshText.textContent = `Cached ${changeText}`;
                    
                    // Still try to reload dropdown options even when data is cached
                    if (typeof loadGoogleSheetConfig === 'function') {
                        console.log('Attempting to reload dropdown options after caching fallback...');
                        try {
                            await loadGoogleSheetConfig(fileSelect, 'list');
                            console.log('Dropdown options reloaded successfully from cached data');
                        } catch (error) {
                            console.log('Could not reload dropdown options:', error.message);
                        }
                    }
                    
                    setTimeout(() => {
                        refreshText.textContent = originalText;
                    }, 4000); // Extended time to read change info
                    
                    // Close menu
                    document.getElementById('menu-dropdown').style.display = 'none';
                    document.getElementById('menu-toggle').classList.remove('active');
                }
                
            } catch (error) {
                console.error('Failed to refresh lists.csv:', error);
                refreshText.textContent = 'Failed ';
                
                setTimeout(() => {
                    refreshText.textContent = originalText;
                }, 2000);
            } finally {
                refreshItem.style.opacity = '1';
            }
        }

        function toggleSelectList() {
            const fileSelectContainer = document.querySelector('#fileSelect').parentElement.parentElement;
            const selectListText = document.getElementById('select-list-text');
            
            if (!fileSelectContainer) {
                console.error('File selection container not found!');
                return;
            }
            
            // Use getComputedStyle to get the actual display value
            const computedStyle = window.getComputedStyle(fileSelectContainer);
            const isVisible = computedStyle.display !== 'none';
            
            if (isVisible) {
                fileSelectContainer.style.display = 'none';
                selectListText.textContent = 'Select List';
            } else {
                fileSelectContainer.style.display = 'block';
                selectListText.textContent = 'Hide List';
            }
            
            // Close menu
            document.getElementById('menu-dropdown').style.display = 'none';
            document.getElementById('menu-toggle').classList.remove('active');
        }
        
        function updateCondensedViewButtons() {
            // Update active state for condensed view buttons
            document.querySelectorAll('.view-buttons-condensed .condensed-icon-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const activeBtn = document.getElementById(currentView + '-view-condensed');
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
        }
        
        function toggleFiltersDropdown() {
            const dropdown = document.getElementById('filters-dropdown');
            const isVisible = dropdown.style.display === 'block';
            
            if (isVisible) {
                dropdown.style.display = 'none';
            } else {
                dropdown.style.display = 'block';
            }
        }
        
        function restoreLayoutState() {
            const fullscreenText = document.getElementById('fullscreen-text');
            const condensedText = document.getElementById('condensed-text');
            
            // Restore fullscreen state
            if (isFullscreen) {
                document.body.classList.add('fullscreen-mode');
                fullscreenText.textContent = 'Exit Fullscreen';
                document.body.style.overflow = 'hidden';
            } else {
                fullscreenText.textContent = 'View Fullscreen';
            }
            
            // Restore condensed state
            const card = document.getElementById('participants-table-card');
            if (isCondensed) {
                card.classList.add('condensed-mode');
                condensedText.textContent = 'Expand Layout';
            } else {
                condensedText.textContent = 'Condense Layout';
            }
        }
        // Load README documentation and configuration
        document.addEventListener('DOMContentLoaded', async function() {
            
            // Load dropdown options from lists.csv with proper CORS attributes
            if (typeof loadGoogleSheetConfig === 'function') {
                const fileSelect = document.getElementById('fileSelect');
                if (fileSelect) {
                    console.log('Loading dropdown options from lists.csv...');
                    await loadGoogleSheetConfig(fileSelect, 'list');
                }
            }
            
            // Restore saved view state
            restoreViewState();
            restoreLayoutState();
            
            // Initialize condensed view buttons
            updateCondensedViewButtons();
            
            // Note: loadGroupParticipants() is now called after file initialization
            
            // Check and update group participants panel visibility on page load
            updateGroupParticipantsVisibility();
            
            // Initialize group snapshot info display
            updateGroupSnapshotInfo();
            
            // Initialize group field event listeners for checkbox synchronization
            const groupField = document.getElementById('group');
            if (groupField) {
                // Sync checkboxes when group field changes
                groupField.addEventListener('input', syncCheckboxesWithGroup);
                groupField.addEventListener('change', syncCheckboxesWithGroup);
                
                // Auto-format names when user clicks off the field
                groupField.addEventListener('blur', function() {
                    formatGroupFieldNames();
                    syncCheckboxesWithGroup();
                });
                
                // Initial sync when page loads
                setTimeout(syncCheckboxesWithGroup, 100);
            }
            
            // Add modelteam option to dropdown if it doesn't exist (temporary fix)
            addModelteamOption();
            
            // Set initial header visibility based on current hash (with delay to ensure dropdown is populated)
            setTimeout(updateHeaderVisibility, 500);
            
            // Initialize insights visibility from URL (with delay to ensure DOM is ready)
            setTimeout(checkInsightsFromURL, 100);
            
            // Listen for URL changes to handle list parameter changes
            // hashChangeEvent and getHash reside in localsite/js/localsite.js
            document.addEventListener('hashChangeEvent', function (elem) { 

                console.log("team/projects detects hashChangeEvent")

                updateGroupParticipantsVisibility();

                const listParam = getHash().list;
                console.log('HASHCHANGE: Processing list parameter:', listParam);
                
                // Update UI for hash changes (header visibility and title)
                updateUIForHashChange();
                
                // Update list select visibility
                updateListSelectVisibility();
                
                // Update group control visibility
                updateGroupParticipantsVisibility();
                
                // Update menu visibility
                updateMenuVisibility();
                
                checkInsightsFromURL();

                // Handle list parameter changes - only load data if list actually changed
                if (listParam && listParam !== currentLoadedList) {
                    console.log('HASHCHANGE: List changed from', currentLoadedList, 'to', listParam);
                    currentLoadedList = listParam;
                    
                    // Hide UI elements and clear filters when list changes
                    hideListDisplayElements();
                    clearAllFilters();
                    
                    // Check if the option exists in the dropdown
                    const targetOption = Array.from(fileSelect.options).find(option => option.value === listParam);
                    if (targetOption) {
                        console.log('HASHCHANGE: Found option for:', listParam);
                        
                        // Update dropdown selection if needed
                        if (listParam !== fileSelect.value) {
                            console.log('HASHCHANGE: Updating dropdown to match hash:', listParam);
                            fileSelect.value = listParam;
                        }
                        
                        // Update selectedFile and load data
                        selectedFile = targetOption.getAttribute('data-url') || listParam;
                        
                        // Load the corresponding data
                        if (listParam === 'all') {
                            console.log('HASHCHANGE: Loading all feeds');
                            showAllLists();
                        } else {
                            console.log('HASHCHANGE: Loading participant data for:', listParam, 'URL:', selectedFile);
                            getSubsetUsingSnapshot();
                        }
                    } else {
                        console.log('HASHCHANGE: List param not found in dropdown options:', listParam);
                        // Display user-visible message about unavailable list
                        appendStatusMessage(` List "${listParam}" is not available in the current dropdown options. Please select from available options.`, 'info');
                    }
                } else if (listParam) {
                    console.log('HASHCHANGE: List param unchanged:', listParam, '- skipping data reload');
                }

                const displayParam = getHash().display || 'column'; // Default to column if absent
                if (['column', 'table', 'gallery'].includes(displayParam) && displayParam !== currentView) {
                    switchView(displayParam);
                }

            
            
                const teamParam = getHash().team;
                if (teamParam !== currentTeamFilter) {
                    console.log(' Team parameter changed in URL hash:', teamParam);
                    currentTeamFilter = teamParam;
                    
                    // Save to localStorage
                    if (currentTeamFilter) {
                        localStorage.setItem(getListStorageKey('participantsTeamFilter'), currentTeamFilter);
                    } else {
                        localStorage.removeItem(getListStorageKey('participantsTeamFilter'));
                    }
                    
                    // Apply filters
                    applyAllFilters();
                }

                const statusParam = getHash().status;
                const newStatuses = statusParam ? statusParam.split(',') : ['All'];
                const currentStatusArray = Array.from(selectedStatuses);
                
                // Only update if the status selection has actually changed to avoid infinite loops
                if (JSON.stringify(currentStatusArray.sort()) !== JSON.stringify(newStatuses.sort())) {
                    console.log(' Status parameter changed in URL hash:', statusParam);
                    selectedStatuses = new Set(newStatuses);
                    
                    // Save to localStorage
                    localStorage.setItem(getListStorageKey('participantsStatusFilter'), JSON.stringify(Array.from(selectedStatuses)));
                    
                    // Update UI
                    updateStatusButtonText();
                    generateStatusDropdown();
                    
                    // Apply filters
                    applyAllFilters();
                }
            });
            
            // Initialize file selection
            await initializeFileSelection();
            
            // Load group participants after file initialization is complete
            // This ensures clearAllFilters() doesn't wipe out localStorage values
            // Add small delay to ensure DOM is fully ready
            setTimeout(() => {
                console.log(' Loading group participants after DOM is ready');
                loadGroupParticipants();
            }, 100);
            
            // Check for list=all in URL hash to auto-load meta list
            const listParam = getHash().list;
            if (listParam === 'all') {
                showAllLists();
            } else if (listParam === 'geo') {
                // Auto-load geo data
                getSubsetUsingSnapshot();
            } else if (!listParam) {
                // No list parameter - check if should default to geo
                const shouldDefaultToGeo = isGeoSite();
                if (shouldDefaultToGeo) {
                    window.location.hash = 'list=geo';
                    fileSelect.value = 'geo';
                    selectedFile = 'map/cities.csv';
                    getSubsetUsingSnapshot();
                } else {
                    // Auto-load data if default option is selected
                    const selectedOption = fileSelect.options[fileSelect.selectedIndex];
                    if (selectedOption && selectedOption.getAttribute('data-url')) {
                        getSubsetUsingSnapshot();
                    }
                }
            } else {
                // Auto-load data if default option is selected
                const selectedOption = fileSelect.options[fileSelect.selectedIndex];
                if (selectedOption && selectedOption.getAttribute('data-url')) {
                    getSubsetUsingSnapshot();
                }
            }
            
            // Set initial menu visibility state
            updateMenuVisibility();
            
            // Initialize group snapshot info display
            updateGroupSnapshotInfo();
            
            // Show "Refresh lists.csv" option only on localhost
            if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
                document.getElementById('refresh-csv-toggle').style.display = 'block';
            }
            
            // Load snapshot if no auto-data loading occurred
            setTimeout(() => {
                // Only load snapshot if no data was auto-loaded
                if (!window.participantsData || window.participantsData.length === 0) {
                    loadSnapshotOnPageLoad();
                }
            }, 500);
            
            // Add event listeners for 3-dot menu
            document.getElementById('menu-toggle').addEventListener('click', toggleMenu);
            
            document.getElementById('list-feeds-toggle').addEventListener('click', showAllLists);
            document.getElementById('refresh-csv-toggle').addEventListener('click', refreshListsCSV);
            
            document.getElementById('fullscreen-toggle').addEventListener('click', toggleFullscreen);
            document.getElementById('condensed-toggle').addEventListener('click', toggleCondensed);
            document.getElementById('raw-data-toggle').addEventListener('click', toggleRawData);
            document.getElementById('export-csv-menu').addEventListener('click', exportCSVFromMenu);
            document.getElementById('full-url-toggle').addEventListener('click', generateFullURL);
            const snapshotsToggle = document.getElementById('snapshots-toggle');
            if (snapshotsToggle) {
                snapshotsToggle.addEventListener('click', toggleSnapshots);
            }
            
            // Snapshots event listeners
            const closeSnapshots = document.getElementById('close-snapshots');
            if (closeSnapshots) {
                closeSnapshots.addEventListener('click', () => {
                    const snapshotsControl = document.getElementById('snapshots-control');
                    if (snapshotsControl) {
                        snapshotsControl.style.display = 'none';
                    }
                });
            }
            
            const addSnapshotBtn = document.getElementById('add-snapshot-btn');
            if (addSnapshotBtn) {
                addSnapshotBtn.addEventListener('click', addNewSnapshot);
            }
            
            const newSnapshotName = document.getElementById('new-snapshot-name');
            if (newSnapshotName) {
                newSnapshotName.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        addNewSnapshot();
                    }
                });
            }
            
            // Add event listeners for condensed view controls
            document.getElementById('filters-toggle').addEventListener('click', toggleFiltersDropdown);
            
            // Add event listeners for condensed view buttons
            document.querySelectorAll('.view-buttons-condensed .condensed-icon-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const view = this.dataset.view;
                    switchView(view);
                });
            });
            
            // Add event listeners for condensed filters dropdown
            document.getElementById('condensed-sort-toggle').addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                document.getElementById('filters-dropdown').style.display = 'none';
                toggleSortDropdown();
            });
            
            document.getElementById('condensed-status-toggle').addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                document.getElementById('filters-dropdown').style.display = 'none';
                toggleStatusDropdown();
            });
            
            // Close dropdowns when clicking outside
            document.addEventListener('click', function(e) {
                const menuDropdown = document.getElementById('menu-dropdown');
                const menuToggle = document.getElementById('menu-toggle');
                const filtersDropdown = document.getElementById('filters-dropdown');
                const filtersToggle = document.getElementById('filters-toggle');
                
                if (!menuDropdown.contains(e.target) && !menuToggle.contains(e.target)) {
                    menuDropdown.style.display = 'none';
                    menuToggle.classList.remove('active');
                }
                
                if (!filtersDropdown.contains(e.target) && !filtersToggle.contains(e.target)) {
                    filtersDropdown.style.display = 'none';
                }
            });
        });
        
        // Pagination functions
        function updatePaginationControls() {
            const totalPages = Math.ceil(totalRecords / recordsPerPage);
            const paginationControls = document.querySelector('.pagination-controls');
            const prevBtn = document.getElementById('prev-page');
            const nextBtn = document.getElementById('next-page');
            
            if (totalRecords > recordsPerPage) {
                paginationControls.style.display = 'flex';
                prevBtn.disabled = currentPage <= 1;
                nextBtn.disabled = currentPage >= totalPages;
            } else {
                paginationControls.style.display = 'none';
            }
        }
        
        function updateResultsCount(filteredData) {
            const resultsCount = document.getElementById('results-count');
            if (!resultsCount) return;
            
            totalRecords = filteredData.length;
            const originalTotal = originalLoadedCount || totalRecords;
            const totalPages = Math.ceil(totalRecords / recordsPerPage);
            const startRecord = Math.min((currentPage - 1) * recordsPerPage + 1, totalRecords);
            const endRecord = Math.min(currentPage * recordsPerPage, totalRecords);
            
            if (totalRecords === 0) {
                resultsCount.textContent = `0 results in ${totalRecords} (of ${originalTotal})`;
            } else if (totalRecords <= recordsPerPage) {
                if (totalRecords === originalTotal) {
                    // No filtering applied
                    resultsCount.textContent = `${totalRecords} result${totalRecords !== 1 ? 's' : ''}`;
                } else {
                    // Filtering applied
                    resultsCount.textContent = `${totalRecords} result${totalRecords !== 1 ? 's' : ''} (of ${originalTotal})`;
                }
            } else {
                resultsCount.textContent = `${startRecord} to ${endRecord} results in ${totalRecords} (of ${originalTotal})`;
            }
            
            updatePaginationControls();
        }
        
        function paginateData(data) {
            const startIndex = (currentPage - 1) * recordsPerPage;
            const endIndex = Math.min(startIndex + recordsPerPage, data.length);
            
            // For large datasets, check if we need to load more data
            if (window.isLargeDataset && endIndex >= data.length && window.originalLargeDataset) {
                const totalNeeded = currentPage * recordsPerPage;
                const currentAvailable = data.length;
                
                if (totalNeeded > currentAvailable && window.originalLargeDataset.length > currentAvailable) {
                    console.log(` Page ${currentPage} needs more data. Loading additional chunk...`);
                    
                    // Calculate how much more data we need
                    const additionalNeeded = Math.min(
                        recordsPerPage * 3, // Load 3 pages worth
                        window.originalLargeDataset.length - currentAvailable
                    );
                    
                    if (additionalNeeded > 0) {
                        const nextChunk = window.originalLargeDataset.slice(
                            currentAvailable, 
                            currentAvailable + additionalNeeded
                        );
                        
                        console.log(` Processing additional ${nextChunk.length} records (${currentAvailable} to ${currentAvailable + additionalNeeded})`);
                        const processedChunk = preprocessParticipantData(nextChunk);
                        
                        // Add to existing data
                        if (window.allRowsData) {
                            window.allRowsData = window.allRowsData.concat(processedChunk);
                            data = window.allRowsData;
                        }
                        
                        console.log(` Total processed data now: ${data.length} records`);
                    }
                }
            }
            
            const finalEndIndex = Math.min(startIndex + recordsPerPage, data.length);
            const result = data.slice(startIndex, finalEndIndex);
            
            if (result.length > 0) {
                console.log(` Pagination: Showing page ${currentPage}, records ${startIndex + 1}-${startIndex + result.length} of ${window.originalLargeDataset ? window.originalLargeDataset.length : data.length}`);
            }
            
            return result;
        }
        
        function goToPage(page) {
            const totalPages = Math.ceil(totalRecords / recordsPerPage);
            if (page >= 1 && page <= totalPages) {
                currentPage = page;
                applyAllFilters(); // Re-apply filters and refresh display
            }
        }
        
        // Add pagination event listeners
        document.getElementById('prev-page').addEventListener('click', () => {
            goToPage(currentPage - 1);
        });
        
        document.getElementById('next-page').addEventListener('click', () => {
            goToPage(currentPage + 1);
        });

        // Image Gallery Functionality
        
        // Extract image paths from participant data
        function extractImagePaths(participantData) {
            const imagePaths = [];
            const imageExtensions = /\.(jpg|jpeg|png|gif|webp|svg)$/i;
            
            // Check all fields for image paths
            Object.values(participantData).forEach(value => {
                if (typeof value === 'string') {
                    // Split by common delimiters and check each part
                    const parts = value.split(/[,;\s\n\r]+/);
                    parts.forEach(part => {
                        const trimmed = part.trim();
                        if (trimmed && imageExtensions.test(trimmed)) {
                            // Convert relative paths to absolute if needed
                            let imagePath = trimmed;
                            if (!imagePath.startsWith('http') && !imagePath.startsWith('/')) {
                                imagePath = imagePath.startsWith('../') ? imagePath : '../' + imagePath;
                            }
                            imagePaths.push(imagePath);
                        }
                    });
                }
            });
            
            return imagePaths.slice(0, 9); // Limit to 9 images max
        }

        // Create image container with navigation
        function createImageContainer(imagePaths, isGalleryView = false) {
            if (!imagePaths || imagePaths.length === 0) {
                return `<div class="no-image-placeholder">No images available</div>`;
            }

            const containerId = 'img-' + Math.random().toString(36).substr(2, 9);
            const height = isGalleryView ? 140 : 120;
            
            let html = `<div class="columns-image-container" id="${containerId}" data-current="0" data-auto-advance="false" data-image-paths='${JSON.stringify(imagePaths)}'>`;
            
            // Add the first image
            html += `<img class="columns-image" src="${imagePaths[0]}" alt="Project Image" style="height: ${height}px" onclick="openImageInNewTab('${imagePaths[0]}')" onerror="this.style.display='none'; this.nextElementSibling?.style.display='flex';">`;
            
            // Add placeholder for failed images
            html += `<div class="no-image-placeholder" style="display: none;">Image not found</div>`;
            
            // Add navigation dots if multiple images
            if (imagePaths.length > 1) {
                html += `<div class="image-dots-container">`;
                imagePaths.forEach((_, index) => {
                    const activeClass = index === 0 ? ' active' : '';
                    html += `<div class="image-dot${activeClass}" onclick="showImageByIndex('${containerId}', ${index})"></div>`;
                });
                html += `</div>`;
            }
            
            html += `</div>`;
            return html;
        }

        // Show specific image by index
        function showImageByIndex(containerId, index) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            // Get image paths from container data attribute
            const imagePaths = container.dataset.imagePaths ? JSON.parse(container.dataset.imagePaths) : [];
            if (index >= imagePaths.length) return;
            
            const img = container.querySelector('.columns-image');
            const placeholder = container.querySelector('.no-image-placeholder');
            const dots = container.querySelectorAll('.image-dot');
            
            // Update image
            img.src = imagePaths[index];
            img.style.display = 'block';
            placeholder.style.display = 'none';
            
            // Update dots
            dots.forEach((dot, i) => {
                dot.classList.toggle('active', i === index);
            });
            
            // Update current index
            container.dataset.current = index;
        }

        // Auto-advance functionality
        let autoAdvanceIntervals = new Map();

        function startAutoAdvance(containerId, imagePaths) {
            if (imagePaths.length <= 1) return;
            
            const container = document.getElementById(containerId);
            if (!container) return;
            
            container.classList.add('auto-advancing');
            container.dataset.autoAdvance = 'true';
            
            const interval = setInterval(() => {
                if (container.dataset.autoAdvance !== 'true') {
                    clearInterval(interval);
                    return;
                }
                
                const current = parseInt(container.dataset.current) || 0;
                const next = (current + 1) % imagePaths.length;
                showImage(containerId, next, imagePaths);
            }, 3000);
            
            autoAdvanceIntervals.set(containerId, interval);
        }

        function stopAutoAdvance(containerId) {
            const container = document.getElementById(containerId);
            if (container) {
                container.classList.remove('auto-advancing');
                container.dataset.autoAdvance = 'false';
            }
            
            if (autoAdvanceIntervals.has(containerId)) {
                clearInterval(autoAdvanceIntervals.get(containerId));
                autoAdvanceIntervals.delete(containerId);
            }
        }

        // Keyboard navigation
        let focusedContainer = null;

        function handleKeyboardNavigation(event, containerId, imagePaths) {
            if (!focusedContainer || focusedContainer !== containerId) return;
            
            const container = document.getElementById(containerId);
            if (!container || imagePaths.length <= 1) return;
            
            const current = parseInt(container.dataset.current) || 0;
            
            switch(event.key) {
                case 'ArrowRight':
                    event.preventDefault();
                    const next = (current + 1) % imagePaths.length;
                    showImage(containerId, next, imagePaths);
                    break;
                case 'ArrowLeft':
                    event.preventDefault();
                    const prev = (current - 1 + imagePaths.length) % imagePaths.length;
                    showImage(containerId, prev, imagePaths);
                    break;
                case ' ':
                    event.preventDefault();
                    if (container.dataset.autoAdvance === 'true') {
                        stopAutoAdvance(containerId);
                    } else {
                        startAutoAdvance(containerId, imagePaths);
                    }
                    break;
            }
        }

        // Open image in new tab
        function openImageInNewTab(imagePath) {
            window.open(imagePath, '_blank');
        }

        // Gallery view toggle functionality
        function toggleGalleryTextMode(cardElement) {
            cardElement.classList.toggle('text-mode');
            const toggleBtn = cardElement.querySelector('.gallery-toggle-btn');
            const icon = toggleBtn.querySelector('i[data-feather]');
            
            if (cardElement.classList.contains('text-mode')) {
                icon.setAttribute('data-feather', 'image');
                toggleBtn.title = 'Show image';
            } else {
                icon.setAttribute('data-feather', 'info');
                toggleBtn.title = 'Show info';
            }
            
            // Feather icons will be refreshed by nav.js
        }

        // Add event listeners for hover and keyboard navigation
        document.addEventListener('mouseover', (event) => {
            const container = event.target.closest('.columns-image-container');
            if (container && container.querySelectorAll('.image-dot').length > 1) {
                const imagePaths = Array.from(container.querySelectorAll('.image-dot')).map((_, index) => {
                    return container.querySelector('.columns-image').src.replace(/\/[^\/]*$/, '/image' + index + '.jpg'); // This will be replaced with actual paths
                });
                
                // Extract actual image paths from the dots' onclick attributes
                const actualPaths = [];
                container.querySelectorAll('.image-dot').forEach(dot => {
                    const onclickAttr = dot.getAttribute('onclick');
                    if (onclickAttr) {
                        const match = onclickAttr.match(/\[(.*?)\]/);
                        if (match) {
                            try {
                                const paths = JSON.parse(match[1].replace(/&quot;/g, '"'));
                                paths.forEach(path => {
                                    if (!actualPaths.includes(path)) actualPaths.push(path);
                                });
                            } catch (e) {
                                console.warn('Could not parse image paths from onclick attribute');
                            }
                        }
                    }
                });
                
                focusedContainer = container.id;
                if (actualPaths.length > 1) {
                    startAutoAdvance(container.id, actualPaths);
                }
            }
        });

        document.addEventListener('mouseout', (event) => {
            const container = event.target.closest('.columns-image-container');
            if (container && focusedContainer === container.id) {
                stopAutoAdvance(container.id);
                focusedContainer = null;
            }
        });

        document.addEventListener('keydown', (event) => {
            if (focusedContainer) {
                const container = document.getElementById(focusedContainer);
                if (container) {
                    // Extract image paths from dots
                    const actualPaths = [];
                    container.querySelectorAll('.image-dot').forEach(dot => {
                        const onclickAttr = dot.getAttribute('onclick');
                        if (onclickAttr) {
                            const match = onclickAttr.match(/\[(.*?)\]/);
                            if (match) {
                                try {
                                    const paths = JSON.parse(match[1].replace(/&quot;/g, '"'));
                                    paths.forEach(path => {
                                        if (!actualPaths.includes(path)) actualPaths.push(path);
                                    });
                                } catch (e) {
                                    console.warn('Could not parse image paths from onclick attribute');
                                }
                            }
                        }
                    });
                    
                    if (actualPaths.length > 1) {
                        handleKeyboardNavigation(event, focusedContainer, actualPaths);
                    }
                }
            }
        });

        // README and Cache Management Functions
        function showReadmeSection() {
            const readmeSection = document.getElementById('readme-section');
            const toggleBtn = document.getElementById('toggle-readme');
            
            // Show the section
            readmeSection.style.display = 'block';
            toggleBtn.textContent = 'Hide Documentation';
            
            // Close the menu dropdown
            const menuDropdown = document.getElementById('menu-dropdown');
            const menuToggle = document.getElementById('menu-toggle');
            if (menuDropdown) {
                menuDropdown.style.display = 'none';
                menuToggle.classList.remove('active');
            }
            
            // Scroll to the pageControls instead of the documentation section
            const pageControls = document.getElementById('pageControls');
            if (pageControls) {
                pageControls.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }
        
        function toggleReadmeSection() {
            const readmeSection = document.getElementById('readme-section');
            const toggleBtn = document.getElementById('toggle-readme');
            
            if (readmeSection.style.display === 'none' || readmeSection.style.display === '') {
                // Show the section
                readmeSection.style.display = 'block';
                toggleBtn.textContent = 'Hide Documentation';
                
                // Scroll to the pageControls
                const pageControls = document.getElementById('pageControls');
                if (pageControls) {
                    pageControls.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            } else {
                // Hide the section
                readmeSection.style.display = 'none';
                toggleBtn.textContent = 'Show Documentation';
            }
        }

        function loadReadmeDocumentation() {
            // Use the displayFile function from common.js to load README.md
            if (typeof displayFile === 'function') {
                displayFile('README.md', 'readme-content');
            } else {
                // Fallback if displayFile is not available
                fetch('README.md')
                    .then(response => response.text())
                    .then(text => {
                        const readmeContent = document.getElementById('readme-content');
                        // Simple markdown to HTML conversion for basic formatting
                        const html = text
                            .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                            .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                            .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                            .replace(/\*\*(.*)\*\*/gim, '<strong>$1</strong>')
                            .replace(/\*(.*)\*/gim, '<em>$1</em>')
                            .replace(/```([^`]+)```/gim, '<pre><code>$1</code></pre>')
                            .replace(/`([^`]+)`/gim, '<code>$1</code>')
                            .replace(/\n\n/gim, '</p><p>')
                            .replace(/\n/gim, '<br>');
                        readmeContent.innerHTML = '<p>' + html + '</p>';
                    })
                    .catch(error => {
                        console.warn('Could not load README.md:', error);
                        document.getElementById('readme-content').innerHTML = '<p>README.md documentation could not be loaded.</p>';
                    });
            }
        }

        function getAllCacheData() {
            const currentListId = getHash().list || 'default';
            const cacheData = {
                currentList: currentListId,
                globalSettings: {},
                listSpecificSettings: {},
                allSnapshots: {}
            };
            
            // Get all localStorage keys to find all list-specific data
            const allKeys = Object.keys(localStorage);
            const listPattern = /^([^_]+)_1_(.+)$/;
            const discoveredLists = new Set();
            
            // Global settings (not list-specific)
            const participantsViewMode = localStorage.getItem('participantsViewMode');
            if (participantsViewMode) cacheData.globalSettings.participantsViewMode = participantsViewMode;
            
            const isFullscreen = localStorage.getItem('isFullscreen');
            if (isFullscreen) {
                try {
                    cacheData.globalSettings.isFullscreen = JSON.parse(isFullscreen);
                } catch (e) {
                    cacheData.globalSettings.isFullscreen = isFullscreen;
                }
            }
            
            const isCondensed = localStorage.getItem('isCondensed');
            if (isCondensed) {
                try {
                    cacheData.globalSettings.isCondensed = JSON.parse(isCondensed);
                } catch (e) {
                    cacheData.globalSettings.isCondensed = isCondensed;
                }
            }
            
            // AI Insights cache (global)
            const aiInsightsCache = localStorage.getItem('aiInsightsCache');
            if (aiInsightsCache) {
                try {
                    cacheData.globalSettings.aiInsightsCache = JSON.parse(aiInsightsCache);
                } catch (e) {
                    cacheData.globalSettings.aiInsightsCache = aiInsightsCache;
                }
            }
            
            const claudeInsightsCache = localStorage.getItem('claudeInsightsCache');
            if (claudeInsightsCache) {
                try {
                    cacheData.globalSettings.claudeInsightsCache = JSON.parse(claudeInsightsCache);
                } catch (e) {
                    cacheData.globalSettings.claudeInsightsCache = claudeInsightsCache;
                }
            }
            
            // File selection storage
            const fileSelection = localStorage.getItem('PartnerTools_selected_file');
            if (fileSelection) cacheData.globalSettings.lastSelectedFile = fileSelection;
            
            // Custom files
            const customFilesPrefix = 'PartnerTools_customFile_';
            allKeys.forEach(key => {
                if (key.startsWith(customFilesPrefix)) {
                    const fileName = key.replace(customFilesPrefix, '');
                    if (!cacheData.globalSettings.customFiles) cacheData.globalSettings.customFiles = {};
                    try {
                        cacheData.globalSettings.customFiles[fileName] = JSON.parse(localStorage.getItem(key));
                    } catch (e) {
                        cacheData.globalSettings.customFiles[fileName] = localStorage.getItem(key);
                    }
                }
            });
            
            // Scan for all list-specific data
            allKeys.forEach(key => {
                const match = key.match(listPattern);
                if (match) {
                    const listId = match[1];
                    const settingKey = match[2];
                    discoveredLists.add(listId);
                    
                    if (!cacheData.listSpecificSettings[listId]) {
                        cacheData.listSpecificSettings[listId] = {};
                    }
                    
                    const value = localStorage.getItem(key);
                    try {
                        // Try to parse as JSON for arrays and objects
                        if (value && (value.startsWith('[') || value.startsWith('{'))) {
                            cacheData.listSpecificSettings[listId][settingKey] = JSON.parse(value);
                        } else if (value === 'true' || value === 'false') {
                            cacheData.listSpecificSettings[listId][settingKey] = JSON.parse(value);
                        } else {
                            cacheData.listSpecificSettings[listId][settingKey] = value;
                        }
                    } catch (e) {
                        cacheData.listSpecificSettings[listId][settingKey] = value;
                    }
                }
            });
            
            // Get snapshots for all discovered lists
            discoveredLists.forEach(listId => {
                const snapshotsKey = `${listId}_1_snapshots`;
                const snapshots = localStorage.getItem(snapshotsKey);
                if (snapshots) {
                    try {
                        cacheData.allSnapshots[listId] = JSON.parse(snapshots);
                    } catch (e) {
                        cacheData.allSnapshots[listId] = snapshots;
                    }
                }
            });
            
            // Summary information
            cacheData.summary = {
                discoveredLists: Array.from(discoveredLists).sort(),
                totalListSpecificKeys: Object.values(cacheData.listSpecificSettings).reduce((acc, settings) => acc + Object.keys(settings).length, 0),
                totalGlobalKeys: Object.keys(cacheData.globalSettings).length,
                totalSnapshotCollections: Object.keys(cacheData.allSnapshots).length,
                totalSnapshots: Object.values(cacheData.allSnapshots).reduce((acc, snapshots) => {
                    return acc + (typeof snapshots === 'object' ? Object.keys(snapshots).length : 0);
                }, 0)
            };
            
            return cacheData;
        }

        function objectToYaml(obj, indent = 0) {
            const spaces = '  '.repeat(indent);
            let yaml = '';
            
            for (const [key, value] of Object.entries(obj)) {
                if (value === null || value === undefined) {
                    yaml += `${spaces}${key}: null\n`;
                } else if (typeof value === 'object' && !Array.isArray(value)) {
                    yaml += `${spaces}${key}:\n`;
                    yaml += objectToYaml(value, indent + 1);
                } else if (Array.isArray(value)) {
                    yaml += `${spaces}${key}:\n`;
                    value.forEach(item => {
                        if (typeof item === 'object') {
                            yaml += `${spaces}  -\n`;
                            yaml += objectToYaml(item, indent + 2);
                        } else {
                            yaml += `${spaces}  - ${JSON.stringify(item)}\n`;
                        }
                    });
                } else if (typeof value === 'string') {
                    yaml += `${spaces}${key}: "${value}"\n`;
                } else {
                    yaml += `${spaces}${key}: ${JSON.stringify(value)}\n`;
                }
            }
            
            return yaml;
        }

        function yamlToObject(yamlText) {
            // Simple YAML parser for our specific use case
            const lines = yamlText.split('\n');
            const result = {};
            const stack = [{ obj: result, indent: -1 }];
            
            for (let line of lines) {
                if (line.trim() === '' || line.trim().startsWith('#')) continue;
                
                const match = line.match(/^(\s*)([^:]+):\s*(.*)$/);
                if (!match) continue;
                
                const indent = match[1].length;
                const key = match[2].trim();
                const value = match[3].trim();
                
                // Find the correct parent based on indentation
                while (stack.length > 1 && stack[stack.length - 1].indent >= indent) {
                    stack.pop();
                }
                
                const parent = stack[stack.length - 1].obj;
                
                if (value === '' || value === 'null') {
                    parent[key] = null;
                } else if (value.startsWith('"') && value.endsWith('"')) {
                    parent[key] = value.slice(1, -1);
                } else if (value === 'true') {
                    parent[key] = true;
                } else if (value === 'false') {
                    parent[key] = false;
                } else if (!isNaN(value) && value !== '') {
                    parent[key] = parseFloat(value);
                } else if (value.startsWith('[') && value.endsWith(']')) {
                    try {
                        parent[key] = JSON.parse(value);
                    } catch (e) {
                        parent[key] = value;
                    }
                } else if (value.startsWith('{') && value.endsWith('}')) {
                    try {
                        parent[key] = JSON.parse(value);
                    } catch (e) {
                        parent[key] = value;
                    }
                } else if (value === '') {
                    // This is a parent key for nested values
                    parent[key] = {};
                    stack.push({ obj: parent[key], indent: indent });
                } else {
                    parent[key] = value;
                }
            }
            
            return result;
        }

        function refreshCacheYaml() {
            const cacheData = getAllCacheData();
            const yaml = objectToYaml(cacheData);
            document.getElementById('pageCacheYaml').value = yaml;
        }

        // Auto-update YAML when cache changes
        function updateYamlDisplay() {
            const yamlTextarea = document.getElementById('pageCacheYaml');
            const readmeSection = document.getElementById('readme-section');
            
            // Only update if the documentation section is visible and textarea exists
            if (yamlTextarea && readmeSection && readmeSection.style.display !== 'none') {
                refreshCacheYaml();
            }
        }

        // Override localStorage.setItem to trigger YAML updates
        const originalSetItem = localStorage.setItem;
        localStorage.setItem = function(key, value) {
            originalSetItem.apply(this, arguments);
            
            // Check if this is a cache-related key and update YAML display
            if (key.includes('_1_') || key === 'aiInsightsCache' || key === 'claudeInsightsCache' || 
                key === 'participantsViewMode' || key === 'isFullscreen' || key === 'isCondensed' ||
                key === 'PartnerTools_selected_file' || key.startsWith('PartnerTools_customFile_')) {
                setTimeout(updateYamlDisplay, 100); // Small delay to ensure storage is updated
            }
        };

        function copyCacheYaml() {
            const textarea = document.getElementById('pageCacheYaml');
            if (textarea.value.trim() === '') {
                refreshCacheYaml();
            }
            
            textarea.select();
            textarea.setSelectionRange(0, 99999); // For mobile devices
            
            try {
                document.execCommand('copy');
                // Visual feedback
                const btn = document.getElementById('copy-cache-btn');
                const originalText = btn.textContent;
                btn.textContent = ' Copied';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 1500);
            } catch (err) {
                console.error('Failed to copy text: ', err);
                alert('Copy failed. Please select and copy manually.');
            }
        }

        function saveCacheFromYaml() {
            const yamlText = document.getElementById('pageCacheYaml').value;
            
            try {
                const cacheData = yamlToObject(yamlText);
                let itemsUpdated = 0;
                
                // Handle the new structured format
                if (cacheData.globalSettings) {
                    // Apply global settings
                    Object.entries(cacheData.globalSettings).forEach(([key, value]) => {
                        if (key === 'aiInsightsCache' || key === 'claudeInsightsCache') {
                            localStorage.setItem(key, JSON.stringify(value));
                            itemsUpdated++;
                        } else if (key === 'participantsViewMode' || key === 'isFullscreen' || key === 'isCondensed') {
                            if (typeof value === 'boolean') {
                                localStorage.setItem(key, JSON.stringify(value));
                            } else {
                                localStorage.setItem(key, value);
                            }
                            itemsUpdated++;
                        } else if (key === 'lastSelectedFile') {
                            localStorage.setItem('PartnerTools_selected_file', value);
                            itemsUpdated++;
                        } else if (key === 'customFiles' && typeof value === 'object') {
                            // Handle custom files
                            Object.entries(value).forEach(([fileName, fileData]) => {
                                const storageKey = `PartnerTools_customFile_${fileName}`;
                                localStorage.setItem(storageKey, JSON.stringify(fileData));
                                itemsUpdated++;
                            });
                        }
                    });
                }
                
                // Handle list-specific settings
                if (cacheData.listSpecificSettings) {
                    Object.entries(cacheData.listSpecificSettings).forEach(([listId, settings]) => {
                        Object.entries(settings).forEach(([settingKey, value]) => {
                            const storageKey = `${listId}_1_${settingKey}`;
                            if (typeof value === 'object') {
                                localStorage.setItem(storageKey, JSON.stringify(value));
                            } else {
                                localStorage.setItem(storageKey, value);
                            }
                            itemsUpdated++;
                        });
                    });
                }
                
                // Handle snapshots for all lists
                if (cacheData.allSnapshots) {
                    Object.entries(cacheData.allSnapshots).forEach(([listId, snapshots]) => {
                        const storageKey = `${listId}_1_snapshots`;
                        localStorage.setItem(storageKey, JSON.stringify(snapshots));
                        itemsUpdated++;
                    });
                }
                
                // Handle legacy format (flat structure) for backward compatibility
                if (!cacheData.globalSettings && !cacheData.listSpecificSettings && !cacheData.allSnapshots) {
                    Object.entries(cacheData).forEach(([key, value]) => {
                        if (key === 'aiInsightsCache' || key === 'claudeInsightsCache' || key === 'snapshots') {
                            localStorage.setItem(key, JSON.stringify(value));
                            itemsUpdated++;
                        } else if (key === 'participantsViewMode' || key === 'isFullscreen' || key === 'isCondensed') {
                            if (typeof value === 'boolean') {
                                localStorage.setItem(key, JSON.stringify(value));
                            } else {
                                localStorage.setItem(key, value);
                            }
                            itemsUpdated++;
                        } else if (key !== 'currentList' && key !== 'summary') {
                            // List-specific settings for current list
                            const storageKey = getListStorageKey(key);
                            if (typeof value === 'object') {
                                localStorage.setItem(storageKey, JSON.stringify(value));
                            } else {
                                localStorage.setItem(storageKey, value);
                            }
                            itemsUpdated++;
                        }
                    });
                }
                
                // Visual feedback
                const btn = document.getElementById('save-cache-btn');
                const originalText = btn.textContent;
                btn.textContent = ` Saved (${itemsUpdated} items)`;
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 2500);
                
                // Suggest page reload to apply changes
                if (confirm(`Cache updated successfully! ${itemsUpdated} items were saved to localStorage.\n\nWould you like to reload the page to apply the changes?`)) {
                    location.reload();
                }
                
            } catch (error) {
                console.error('Failed to parse YAML:', error);
                alert('Failed to parse YAML. Please check the syntax and try again.\n\nError: ' + error.message);
            }
        }

        // ===== NEW SNAPSHOT DROPDOWN FUNCTIONALITY =====
        
        // Initialize snapshot dropdown when page loads
        function initializeSnapshotDropdown() {
            populateSnapshotDropdown();
            
            // Event listeners for snapshot dropdown
            const snapshotSelect = document.getElementById('snapshot');
            const editBtn = document.getElementById('edit-snapshot-btn');
            const deleteBtn = document.getElementById('delete-snapshot-btn');
            const nameEditor = document.getElementById('snapshot-name-editor');
            const nameInput = document.getElementById('snapshot-name-input');
            const saveBtn = document.getElementById('save-snapshot-btn');
            const cancelBtn = document.getElementById('cancel-snapshot-btn');
            
            if (snapshotSelect) {
                snapshotSelect.addEventListener('change', handleSnapshotChange);
            }
            
            if (editBtn) {
                editBtn.addEventListener('click', showSnapshotEditor);
            }
            
            if (deleteBtn) {
                deleteBtn.addEventListener('click', deleteCurrentSnapshot);
            }
            
            if (saveBtn) {
                saveBtn.addEventListener('click', saveSnapshotFromEditor);
            }
            
            if (cancelBtn) {
                cancelBtn.addEventListener('click', hideSnapshotEditor);
            }
        }
        
        // Populate snapshot dropdown with existing snapshots
        function populateSnapshotDropdown() {
            const snapshots = loadSnapshots();
            const snapshotSelect = document.getElementById('snapshot');
            
            if (!snapshotSelect) return;
            
            // Clear existing options and add blank "Snapshots..." option first
            snapshotSelect.innerHTML = '<option value="" disabled selected>Snapshots...</option>';
            
            // Add existing snapshots
            Object.keys(snapshots).forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                snapshotSelect.appendChild(option);
            });
            
            // Add "Add new snapshot" at the end
            const addNewOption = document.createElement('option');
            addNewOption.value = 'add_new';
            addNewOption.textContent = 'Add new snapshot';
            snapshotSelect.appendChild(addNewOption);
            
            // Set current selection if there's an active snapshot
            if (currentActiveSnapshot && snapshots[currentActiveSnapshot]) {
                snapshotSelect.value = currentActiveSnapshot;
                showEditDeleteButtons();
            } else {
                hideEditDeleteButtons();
            }
        }
        
        // Handle snapshot dropdown selection change
        function handleSnapshotChange(event) {
            const selectedValue = event.target.value;
            const editBtn = document.getElementById('edit-snapshot-btn');
            const deleteBtn = document.getElementById('delete-snapshot-btn');
            
            if (selectedValue === 'add_new') {
                // "Add new snapshot" selected
                showSnapshotEditor();
                clearGroupField();
                hideEditDeleteButtons();
            } else if (selectedValue === '') {
                // "Snapshots..." placeholder selected - do nothing
                return;
            } else {
                // Existing snapshot selected
                loadSnapshot(selectedValue);
                showEditDeleteButtons();
                hideSnapshotEditor();
            }
        }
        
        // Show the snapshot name editor
        function showSnapshotEditor() {
            const nameEditor = document.getElementById('snapshot-name-editor');
            const nameInput = document.getElementById('snapshot-name-input');
            
            if (nameEditor) {
                nameEditor.style.display = 'block';
                
                // Pre-populate with current selection if editing
                const snapshotSelect = document.getElementById('snapshot');
                if (snapshotSelect && snapshotSelect.value !== '') {
                    nameInput.value = snapshotSelect.value;
                } else {
                    // Generate default name with today's date
                    const today = new Date();
                    const months = ['January', 'February', 'March', 'April', 'May', 'June',
                                  'July', 'August', 'September', 'October', 'November', 'December'];
                    nameInput.value = `${months[today.getMonth()]} ${today.getDate()}, ${today.getFullYear()}`;
                }
                
                nameInput.focus();
            }
        }
        
        // Hide the snapshot name editor
        function hideSnapshotEditor() {
            const nameEditor = document.getElementById('snapshot-name-editor');
            const nameInput = document.getElementById('snapshot-name-input');
            
            if (nameEditor) {
                nameEditor.style.display = 'none';
                nameInput.value = '';
            }
        }
        
        // Save snapshot from the editor
        function saveSnapshotFromEditor() {
            const nameInput = document.getElementById('snapshot-name-input');
            const snapshotSelect = document.getElementById('snapshot');
            const newName = nameInput.value.trim();
            
            if (!newName) {
                alert('Please enter a snapshot name');
                return;
            }
            
            const snapshots = loadSnapshots();
            const oldName = snapshotSelect.value;
            
            // Check if name already exists (and it's not the same snapshot being renamed)
            if (snapshots[newName] && newName !== oldName) {
                if (!confirm(`Snapshot "${newName}" already exists. Overwrite?`)) {
                    return;
                }
            }
            
            // If renaming, delete old snapshot
            if (oldName && oldName !== newName) {
                delete snapshots[oldName];
            }
            
            // Save current filter state to the new/renamed snapshot
            const filterState = getCurrentFilterState();
            snapshots[newName] = filterState;
            saveSnapshots(snapshots);
            
            // Update current active snapshot
            currentActiveSnapshot = newName;
            
            // Refresh dropdown and update UI
            populateSnapshotDropdown();
            updateListTitle();
            hideSnapshotEditor();
            
            alert(`Snapshot "${newName}" saved successfully!`);
        }
        
        // Delete current snapshot
        function deleteCurrentSnapshot() {
            const snapshotSelect = document.getElementById('snapshot');
            const currentName = snapshotSelect.value;
            
            if (!currentName) return;
            
            if (confirm(`Are you sure you want to delete snapshot "${currentName}"?`)) {
                const snapshots = loadSnapshots();
                delete snapshots[currentName];
                saveSnapshots(snapshots);
                
                // Clear current active snapshot if it was deleted
                if (currentActiveSnapshot === currentName) {
                    currentActiveSnapshot = null;
                    updateListTitle();
                }
                
                // Reset dropdown to "Snapshots..." placeholder
                snapshotSelect.value = '';
                hideEditDeleteButtons();
                
                // Clear group field
                clearGroupField();
                
                // Refresh the list display
                refreshDisplay();
                
                populateSnapshotDropdown();
            }
        }
        
        // Show edit and delete buttons
        function showEditDeleteButtons() {
            const editBtn = document.getElementById('edit-snapshot-btn');
            const deleteBtn = document.getElementById('delete-snapshot-btn');
            
            if (editBtn) editBtn.style.display = 'flex';
            if (deleteBtn) deleteBtn.style.display = 'flex';
        }
        
        // Hide edit and delete buttons
        function hideEditDeleteButtons() {
            const editBtn = document.getElementById('edit-snapshot-btn');
            const deleteBtn = document.getElementById('delete-snapshot-btn');
            
            if (editBtn) editBtn.style.display = 'none';
            if (deleteBtn) deleteBtn.style.display = 'none';
        }
        
        // Clear the group field
        function clearGroupField() {
            const groupInput = document.getElementById('group');
            if (groupInput) {
                groupInput.value = '';
                // Trigger any existing change events
                const event = new Event('input', { bubbles: true });
                groupInput.dispatchEvent(event);
            }
        }
        
        // Refresh the display (trigger filter updates)
        function refreshDisplay() {
            // Call existing filter/display update functions
            if (typeof applyGroupFilter === 'function') {
                applyGroupFilter();
            }
        }

        // Initialize README and cache functionality when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Load README documentation
            setTimeout(() => {
                loadReadmeDocumentation();
                // Initialize cache YAML display
                refreshCacheYaml();
                // Initialize new snapshot dropdown functionality
                initializeSnapshotDropdown();
            }, 1000); // Delay to ensure other scripts have loaded
        });
    </script>

</body>
</html>
